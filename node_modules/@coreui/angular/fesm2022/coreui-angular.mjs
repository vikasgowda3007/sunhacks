import * as i0 from '@angular/core';
import { inject, ElementRef, Directive, input, Renderer2, effect, TemplateRef, booleanAttribute, untracked, NgModule, computed, Injectable, Component, afterNextRender, linkedSignal, output, signal, contentChildren, numberAttribute, DestroyRef, DOCUMENT, RendererFactory2, PLATFORM_ID, forwardRef, NgZone, ChangeDetectorRef, contentChild, afterEveryRender, viewChild, ViewContainerRef, model, afterRenderEffect, Pipe, ViewChild, HostBinding, Input, ContentChildren, ChangeDetectionStrategy, HostListener, Injector, runInInjectionContext } from '@angular/core';
import { NgTemplateOutlet, NgClass, isPlatformServer, isPlatformBrowser, NgStyle } from '@angular/common';
import { animation, animate, style, AnimationBuilder, useAnimation, trigger, state, transition, group, query, animateChild } from '@angular/animations';
import { takeUntilDestroyed, toSignal, toObservable } from '@angular/core/rxjs-interop';
import { fromEvent, Subject, BehaviorSubject, merge, takeWhile } from 'rxjs';
import * as i1 from '@angular/router';
import { RouterModule, Router, ActivatedRoute, NavigationEnd, RouterLink } from '@angular/router';
import { filter, tap, finalize, zipWith, withLatestFrom, debounceTime } from 'rxjs/operators';
import { createPopper } from '@popperjs/core';
import * as i1$1 from '@angular/cdk/a11y';
import { FocusKeyManager, FocusMonitor, A11yModule } from '@angular/cdk/a11y';
import { BreakpointObserver } from '@angular/cdk/layout';
import { IconDirective } from '@coreui/icons-angular';

var BreakpointInfix;
(function (BreakpointInfix) {
    BreakpointInfix["xs"] = "xs";
    BreakpointInfix["sm"] = "sm";
    BreakpointInfix["md"] = "md";
    BreakpointInfix["lg"] = "lg";
    BreakpointInfix["xl"] = "xl";
    BreakpointInfix["xxl"] = "xxl";
})(BreakpointInfix || (BreakpointInfix = {}));

class ElementRefDirective {
    elementRef = inject(ElementRef);
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: ElementRefDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "20.3.2", type: ElementRefDirective, isStandalone: true, selector: "[cElementRef]", exportAs: ["cElementRef"], ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: ElementRefDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[cElementRef]',
                    exportAs: 'cElementRef'
                }]
        }] });

class HtmlAttributesDirective {
    cHtmlAttr = input(...(ngDevMode ? [undefined, { debugName: "cHtmlAttr" }] : []));
    #renderer = inject(Renderer2);
    #elementRef = inject(ElementRef);
    #attrEffect = effect(() => {
        const attribs = this.cHtmlAttr();
        for (const attr in attribs) {
            if (attr === 'style' && typeof attribs[attr] === 'object') {
                this.setStyle(attribs[attr]);
            }
            else if (attr === 'class') {
                this.addClass(attribs[attr]);
            }
            else {
                this.setAttrib(attr, attribs[attr]);
            }
        }
    }, ...(ngDevMode ? [{ debugName: "#attrEffect" }] : []));
    setStyle(styles) {
        for (const style in styles) {
            if (style) {
                this.#renderer.setStyle(this.#elementRef.nativeElement, style, styles[style]);
            }
        }
    }
    addClass(classes) {
        const classArray = Array.isArray(classes) ? classes : classes.split(' ');
        classArray
            .filter((element) => element.length > 0)
            .forEach((element) => {
            this.#renderer.addClass(this.#elementRef.nativeElement, element);
        });
    }
    setAttrib(key, value) {
        value !== null
            ? this.#renderer.setAttribute(this.#elementRef.nativeElement, key, value)
            : this.#renderer.removeAttribute(this.#elementRef.nativeElement, key);
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: HtmlAttributesDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.1.0", version: "20.3.2", type: HtmlAttributesDirective, isStandalone: true, selector: "[cHtmlAttr]", inputs: { cHtmlAttr: { classPropertyName: "cHtmlAttr", publicName: "cHtmlAttr", isSignal: true, isRequired: false, transformFunction: null } }, exportAs: ["cHtmlAttr"], ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: HtmlAttributesDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[cHtmlAttr]',
                    exportAs: 'cHtmlAttr'
                }]
        }] });

class TemplateIdDirective {
    templateRef = inject(TemplateRef);
    cTemplateId = input.required(...(ngDevMode ? [{ debugName: "cTemplateId" }] : []));
    get id() {
        return this.cTemplateId();
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: TemplateIdDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.1.0", version: "20.3.2", type: TemplateIdDirective, isStandalone: true, selector: "[cTemplateId]", inputs: { cTemplateId: { classPropertyName: "cTemplateId", publicName: "cTemplateId", isSignal: true, isRequired: true, transformFunction: null } }, ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: TemplateIdDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[cTemplateId]'
                }]
        }] });

class ThemeDirective {
    #hostElement = inject(ElementRef);
    #renderer = inject(Renderer2);
    /**
     * Add dark theme attribute.
     * @return 'dark' | 'light' | undefined
     */
    colorScheme = input(...(ngDevMode ? [undefined, { debugName: "colorScheme" }] : []));
    #colorSchemeChange = effect(() => {
        const colorScheme = this.colorScheme();
        colorScheme ? this.setTheme(colorScheme) : this.unsetTheme();
    }, ...(ngDevMode ? [{ debugName: "#colorSchemeChange" }] : []));
    dark = input(false, ...(ngDevMode ? [{ debugName: "dark", transform: booleanAttribute }] : [{ transform: booleanAttribute }]));
    #darkChange = effect(() => {
        const darkTheme = this.dark() || untracked(this.colorScheme) === 'dark';
        darkTheme ? this.setTheme('dark') : this.unsetTheme();
    }, ...(ngDevMode ? [{ debugName: "#darkChange" }] : []));
    setTheme(theme) {
        if (theme) {
            this.#renderer.setAttribute(this.#hostElement.nativeElement, 'data-coreui-theme', theme);
        }
    }
    unsetTheme() {
        this.#renderer.removeAttribute(this.#hostElement.nativeElement, 'data-coreui-theme');
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: ThemeDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.1.0", version: "20.3.2", type: ThemeDirective, isStandalone: true, selector: "[cTheme]", inputs: { colorScheme: { classPropertyName: "colorScheme", publicName: "colorScheme", isSignal: true, isRequired: false, transformFunction: null }, dark: { classPropertyName: "dark", publicName: "dark", isSignal: true, isRequired: false, transformFunction: null } }, exportAs: ["cTheme"], ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: ThemeDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[cTheme]',
                    exportAs: 'cTheme'
                }]
        }] });

class SharedModule {
    static forRoot() {
        return {
            ngModule: SharedModule,
        };
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: SharedModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
    static ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "20.3.2", ngImport: i0, type: SharedModule, imports: [ElementRefDirective, HtmlAttributesDirective, TemplateIdDirective, ThemeDirective], exports: [ElementRefDirective, HtmlAttributesDirective, TemplateIdDirective, ThemeDirective] });
    static ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: SharedModule });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: SharedModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [ElementRefDirective, HtmlAttributesDirective, TemplateIdDirective, ThemeDirective],
                    exports: [ElementRefDirective, HtmlAttributesDirective, TemplateIdDirective, ThemeDirective],
                }]
        }] });

class AccordionButtonDirective {
    /**
     * Toggles an accordion button collapsed state. Use in accordionHeaderTemplate. [docs]
     * @type boolean
     */
    collapsed = input(undefined, ...(ngDevMode ? [{ debugName: "collapsed" }] : []));
    /**
     * Default type for cAccordionButton. [docs]
     * @type string
     * @default 'button'
     */
    type = input('button', ...(ngDevMode ? [{ debugName: "type" }] : []));
    hostClasses = computed(() => {
        return {
            'accordion-button': true,
            collapsed: this.collapsed()
        };
    }, ...(ngDevMode ? [{ debugName: "hostClasses" }] : []));
    ariaExpanded = computed(() => !this.collapsed(), ...(ngDevMode ? [{ debugName: "ariaExpanded" }] : []));
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: AccordionButtonDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.1.0", version: "20.3.2", type: AccordionButtonDirective, isStandalone: true, selector: "[cAccordionButton]", inputs: { collapsed: { classPropertyName: "collapsed", publicName: "collapsed", isSignal: true, isRequired: false, transformFunction: null }, type: { classPropertyName: "type", publicName: "type", isSignal: true, isRequired: false, transformFunction: null } }, host: { properties: { "class": "hostClasses()", "attr.type": "type()", "attr.aria-expanded": "ariaExpanded()" } }, ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: AccordionButtonDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[cAccordionButton]',
                    host: { '[class]': 'hostClasses()', '[attr.type]': 'type()', '[attr.aria-expanded]': 'ariaExpanded()' }
                }]
        }] });

class AccordionService {
    items = [];
    alwaysOpen = false;
    addItem(item) {
        this.items.push(item);
    }
    removeItem(item) {
        const index = this.items.indexOf(item);
        if (index !== -1) {
            this.items.splice(index, 1);
        }
    }
    toggleItem(item) {
        item.itemVisible.update((value) => !value);
        this.closeOtherItems(item);
    }
    closeOtherItems(openItem) {
        if (!this.alwaysOpen) {
            this.items.forEach((item) => {
                if (item !== openItem) {
                    item.itemVisible.set(false);
                }
            });
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: AccordionService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: AccordionService });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: AccordionService, decorators: [{
            type: Injectable
        }] });

class AccordionComponent {
    #accordionService = inject(AccordionService);
    /**
     * Removes the default background-color, some borders, and some rounded corners to render accordions edge-to-edge with their parent container.
     * @type boolean
     */
    flush = input(false, ...(ngDevMode ? [{ debugName: "flush", transform: booleanAttribute }] : [{ transform: booleanAttribute }]));
    /**
     * Make accordion items stay open when another item is opened
     * @type boolean
     */
    alwaysOpen = input(false, ...(ngDevMode ? [{ debugName: "alwaysOpen", transform: booleanAttribute }] : [{ transform: booleanAttribute }]));
    #alwaysOpenEffect = effect(() => {
        this.#accordionService.alwaysOpen = this.alwaysOpen();
    }, ...(ngDevMode ? [{ debugName: "#alwaysOpenEffect" }] : []));
    hostClasses = computed(() => ({
        accordion: true,
        'accordion-flush': this.flush()
    }), ...(ngDevMode ? [{ debugName: "hostClasses" }] : []));
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: AccordionComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.1.0", version: "20.3.2", type: AccordionComponent, isStandalone: true, selector: "c-accordion", inputs: { flush: { classPropertyName: "flush", publicName: "flush", isSignal: true, isRequired: false, transformFunction: null }, alwaysOpen: { classPropertyName: "alwaysOpen", publicName: "alwaysOpen", isSignal: true, isRequired: false, transformFunction: null } }, host: { properties: { "class": "hostClasses()" } }, providers: [AccordionService], exportAs: ["cAccordionItem"], ngImport: i0, template: '<ng-content />', isInline: true, styles: [":host{display:block}\n"] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: AccordionComponent, decorators: [{
            type: Component,
            args: [{ selector: 'c-accordion', template: '<ng-content />', exportAs: 'cAccordionItem', providers: [AccordionService], host: { '[class]': 'hostClasses()' }, styles: [":host{display:block}\n"] }]
        }] });

const expandAnimation = animation([animate('{{ time }} {{ easing }}')]);
const collapseAnimation = animation([
    style({ height: '*', minHeight: '*' }),
    animate('{{ time }} {{ easing }}', style({ height: 0, minHeight: 0 }))
]);
const expandHorizontalAnimation = animation([animate('{{ time }} {{ easing }}')]);
const collapseHorizontalAnimation = animation([animate('{{ time }} {{ easing }}')]);

class CollapseDirective {
    #animationBuilder = inject(AnimationBuilder);
    #hostElement = inject(ElementRef);
    #renderer = inject(Renderer2);
    #player = undefined;
    constructor() {
        afterNextRender({
            read: () => {
                this.#initialized.set(true);
            }
        });
    }
    /**
     * @ignore
     */
    animateInput = input(true, ...(ngDevMode ? [{ debugName: "animateInput", transform: booleanAttribute, alias: 'animate' }] : [{ transform: booleanAttribute, alias: 'animate' }]));
    animate = linkedSignal({
        source: this.animateInput,
        computation: (value) => value
    });
    /**
     * Set horizontal collapsing to transition the width instead of height.
     * @type boolean
     * @default false
     */
    horizontal = input(false, ...(ngDevMode ? [{ debugName: "horizontal", transform: booleanAttribute }] : [{ transform: booleanAttribute }]));
    /**
     * Toggle the visibility of collapsible element.
     * @type boolean
     * @default false
     */
    visibleInput = input(false, ...(ngDevMode ? [{ debugName: "visibleInput", transform: booleanAttribute, alias: 'visible' }] : [{ transform: booleanAttribute, alias: 'visible' }]));
    visibleChange = output();
    visible = linkedSignal({ source: this.visibleInput, computation: (value) => value });
    #initialized = signal(false, ...(ngDevMode ? [{ debugName: "#initialized" }] : []));
    #visibleEffect = effect(() => {
        const visible = this.visible();
        if (this.#initialized()) {
            this.createPlayer(visible);
        }
    }, ...(ngDevMode ? [{ debugName: "#visibleEffect" }] : []));
    /**
     * Add `navbar` prop for grouping and hiding navbar contents by a parent breakpoint.
     * @type boolean
     * @default false
     */
    navbar = input(false, ...(ngDevMode ? [{ debugName: "navbar", transform: booleanAttribute }] : [{ transform: booleanAttribute }]));
    /**
     * @ignore
     */
    duration = input('350ms', ...(ngDevMode ? [{ debugName: "duration" }] : []));
    /**
     * @ignore
     */
    transition = input('ease', ...(ngDevMode ? [{ debugName: "transition" }] : []));
    /**
     * Event emitted on visibility change. [docs]
     * @type string
     */
    collapseChange = output();
    hostClasses = computed(() => {
        return {
            'navbar-collapse': this.navbar(),
            'collapse-horizontal': this.horizontal()
        };
    }, ...(ngDevMode ? [{ debugName: "hostClasses" }] : []));
    ngOnDestroy() {
        this.destroyPlayer();
    }
    toggle(visible = !this.visible()) {
        this.visible.set(visible);
    }
    destroyPlayer() {
        this.#player?.destroy();
        this.#player = undefined;
    }
    createPlayer(visible = this.visible()) {
        if (this.#player?.hasStarted()) {
            this.destroyPlayer();
        }
        const host = this.#hostElement.nativeElement;
        if (visible) {
            this.#renderer.removeStyle(host, 'display');
        }
        const duration = this.animate() ? this.duration() : '0ms';
        const expand = this.horizontal() ? expandHorizontalAnimation : expandAnimation;
        const collapse = this.horizontal() ? collapseHorizontalAnimation : collapseAnimation;
        const dimension = this.horizontal() ? 'width' : 'height';
        const capitalizedDimension = dimension[0].toUpperCase() + dimension.slice(1);
        const scrollSize = `scroll${capitalizedDimension}`;
        const animationFactory = this.#animationBuilder?.build(useAnimation(visible ? expand : collapse, { params: { time: duration, easing: this.transition() } }));
        this.#player = animationFactory.create(host);
        !visible && host.offsetHeight && host.style[dimension] && host.scrollHeight;
        this.#renderer.setStyle(host, dimension, visible ? 0 : `${host.getBoundingClientRect()[dimension]}px`);
        this.#player.onStart(() => {
            this.setMaxSize();
            this.#renderer.removeClass(host, 'collapse');
            this.#renderer.addClass(host, 'collapsing');
            this.#renderer.removeClass(host, 'show');
            this.#renderer.setStyle(host, dimension, visible ? `${host[scrollSize]}px` : '');
            if (this.#player) {
                this.collapseChange?.emit(visible ? 'opening' : 'collapsing');
            }
        });
        this.#player.onDone(() => {
            this.#renderer.removeClass(host, 'collapsing');
            this.#renderer.addClass(host, 'collapse');
            if (visible) {
                this.#renderer.addClass(host, 'show');
                this.#renderer.setStyle(host, dimension, '');
            }
            else {
                this.#renderer.removeClass(host, 'show');
            }
            if (this.#player) {
                this.collapseChange?.emit(visible ? 'open' : 'collapsed');
                this.visibleChange?.emit(visible);
            }
            this.destroyPlayer();
        });
        this.#player?.play();
    }
    setMaxSize() {
        const host = this.#hostElement.nativeElement;
        if (this.horizontal()) {
            host.scrollWidth > 0 && this.#renderer.setStyle(host, 'maxWidth', `${host.scrollWidth}px`);
            // } else {
            //   host.scrollHeight > 0 && this.#renderer.setStyle(host, 'maxHeight', `${host.scrollHeight}px`);
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: CollapseDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.1.0", version: "20.3.2", type: CollapseDirective, isStandalone: true, selector: "[cCollapse]", inputs: { animateInput: { classPropertyName: "animateInput", publicName: "animate", isSignal: true, isRequired: false, transformFunction: null }, horizontal: { classPropertyName: "horizontal", publicName: "horizontal", isSignal: true, isRequired: false, transformFunction: null }, visibleInput: { classPropertyName: "visibleInput", publicName: "visible", isSignal: true, isRequired: false, transformFunction: null }, navbar: { classPropertyName: "navbar", publicName: "navbar", isSignal: true, isRequired: false, transformFunction: null }, duration: { classPropertyName: "duration", publicName: "duration", isSignal: true, isRequired: false, transformFunction: null }, transition: { classPropertyName: "transition", publicName: "transition", isSignal: true, isRequired: false, transformFunction: null } }, outputs: { visibleChange: "visibleChange", collapseChange: "collapseChange" }, host: { properties: { "class": "hostClasses()", "style": "{ display: \"none\" }" } }, exportAs: ["cCollapse"], ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: CollapseDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[cCollapse]',
                    exportAs: 'cCollapse',
                    host: { '[class]': 'hostClasses()', '[style]': '{ display: "none" }' }
                }]
        }], ctorParameters: () => [] });

class CollapseModule {
    static forRoot() {
        return { ngModule: CollapseModule, providers: [] };
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: CollapseModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
    static ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "20.3.2", ngImport: i0, type: CollapseModule, imports: [CollapseDirective], exports: [CollapseDirective] });
    static ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: CollapseModule });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: CollapseModule, decorators: [{
            type: NgModule,
            args: [{
                    exports: [CollapseDirective],
                    imports: [CollapseDirective]
                }]
        }] });

let nextId$2 = 0;
class AccordionItemComponent {
    #accordionService = inject(AccordionService);
    /**
     * Toggle an accordion item programmatically
     * @return boolean
     * @default false
     */
    visibleInput = input(false, ...(ngDevMode ? [{ debugName: "visibleInput", transform: booleanAttribute, alias: 'visible' }] : [{ transform: booleanAttribute, alias: 'visible' }]));
    itemVisible = signal(false, ...(ngDevMode ? [{ debugName: "itemVisible" }] : []));
    #visibleInputChange = effect(() => {
        this.visible = this.visibleInput();
    }, ...(ngDevMode ? [{ debugName: "#visibleInputChange" }] : []));
    set visible(value) {
        this.itemVisible.set(value);
    }
    get visible() {
        return this.itemVisible();
    }
    contentId = `accordion-item-${nextId$2++}`;
    get itemContext() {
        return { $implicit: this.itemVisible() };
    }
    contentTemplates = contentChildren(TemplateIdDirective, ...(ngDevMode ? [{ debugName: "contentTemplates", descendants: true }] : [{ descendants: true }]));
    templates = computed(() => {
        return this.contentTemplates().reduce((acc, child) => {
            acc[child.id] = child.templateRef;
            return acc;
        }, {});
    }, ...(ngDevMode ? [{ debugName: "templates" }] : []));
    ngOnInit() {
        this.#accordionService.addItem(this);
    }
    ngOnDestroy() {
        this.#accordionService.removeItem(this);
    }
    toggleItem() {
        this.#accordionService.toggleItem(this);
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: AccordionItemComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.2.0", version: "20.3.2", type: AccordionItemComponent, isStandalone: true, selector: "c-accordion-item", inputs: { visibleInput: { classPropertyName: "visibleInput", publicName: "visible", isSignal: true, isRequired: false, transformFunction: null } }, host: { classAttribute: "accordion-item" }, queries: [{ propertyName: "contentTemplates", predicate: TemplateIdDirective, descendants: true, isSignal: true }], exportAs: ["cAccordionItem"], ngImport: i0, template: "@let tmpl = templates();\n<ng-container>\n  <div class=\"accordion-header\">\n    <ng-container *ngTemplateOutlet=\"tmpl['accordionHeaderTemplate'] || defaultAccordionHeaderTemplate; context: itemContext\" />\n  </div>\n  <div class=\"accordion-collapse\" cCollapse [visible]=\"itemVisible()\" [attr.aria-expanded]=\"itemVisible()\" [id]=\"contentId\">\n    <ng-container *ngTemplateOutlet=\"tmpl['accordionBodyTemplate'] || defaultAccordionBodyTemplate; context: itemContext\" />\n  </div>\n</ng-container>\n\n<ng-template #defaultAccordionHeaderTemplate>\n  <button cAccordionButton [collapsed]=\"!itemVisible()\" [attr.aria-controls]=\"contentId\" (click)=\"toggleItem()\">\n    <ng-container\n      *ngTemplateOutlet=\"tmpl['accordionHeader'] || defaultAccordionHeaderContentTemplate; context: itemContext\">\n    </ng-container>\n  </button>\n</ng-template>\n\n<ng-template #defaultAccordionHeaderContentTemplate>\n  <ng-content />\n</ng-template>\n\n<ng-template #defaultAccordionBodyTemplate>\n  <div class=\"accordion-body\">\n    <ng-container\n      *ngTemplateOutlet=\"tmpl['accordionBody'] || defaultAccordionBodyContentTemplate; context: itemContext\">\n    </ng-container>\n  </div>\n</ng-template>\n\n<ng-template #defaultAccordionBodyContentTemplate>\n  <ng-content />\n</ng-template>\n", styles: [":host{display:block;overflow:hidden}\n"], dependencies: [{ kind: "directive", type: AccordionButtonDirective, selector: "[cAccordionButton]", inputs: ["collapsed", "type"] }, { kind: "directive", type: NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }, { kind: "directive", type: CollapseDirective, selector: "[cCollapse]", inputs: ["animate", "horizontal", "visible", "navbar", "duration", "transition"], outputs: ["visibleChange", "collapseChange"], exportAs: ["cCollapse"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: AccordionItemComponent, decorators: [{
            type: Component,
            args: [{ selector: 'c-accordion-item', exportAs: 'cAccordionItem', imports: [AccordionButtonDirective, NgTemplateOutlet, CollapseDirective], host: { class: 'accordion-item' }, template: "@let tmpl = templates();\n<ng-container>\n  <div class=\"accordion-header\">\n    <ng-container *ngTemplateOutlet=\"tmpl['accordionHeaderTemplate'] || defaultAccordionHeaderTemplate; context: itemContext\" />\n  </div>\n  <div class=\"accordion-collapse\" cCollapse [visible]=\"itemVisible()\" [attr.aria-expanded]=\"itemVisible()\" [id]=\"contentId\">\n    <ng-container *ngTemplateOutlet=\"tmpl['accordionBodyTemplate'] || defaultAccordionBodyTemplate; context: itemContext\" />\n  </div>\n</ng-container>\n\n<ng-template #defaultAccordionHeaderTemplate>\n  <button cAccordionButton [collapsed]=\"!itemVisible()\" [attr.aria-controls]=\"contentId\" (click)=\"toggleItem()\">\n    <ng-container\n      *ngTemplateOutlet=\"tmpl['accordionHeader'] || defaultAccordionHeaderContentTemplate; context: itemContext\">\n    </ng-container>\n  </button>\n</ng-template>\n\n<ng-template #defaultAccordionHeaderContentTemplate>\n  <ng-content />\n</ng-template>\n\n<ng-template #defaultAccordionBodyTemplate>\n  <div class=\"accordion-body\">\n    <ng-container\n      *ngTemplateOutlet=\"tmpl['accordionBody'] || defaultAccordionBodyContentTemplate; context: itemContext\">\n    </ng-container>\n  </div>\n</ng-template>\n\n<ng-template #defaultAccordionBodyContentTemplate>\n  <ng-content />\n</ng-template>\n", styles: [":host{display:block;overflow:hidden}\n"] }]
        }] });

class AccordionModule {
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: AccordionModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
    static ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "20.3.2", ngImport: i0, type: AccordionModule, imports: [AccordionButtonDirective,
            AccordionComponent,
            AccordionItemComponent], exports: [AccordionComponent,
            AccordionButtonDirective,
            AccordionItemComponent] });
    static ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: AccordionModule, providers: [
            AccordionService
        ] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: AccordionModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        AccordionButtonDirective,
                        AccordionComponent,
                        AccordionItemComponent
                    ],
                    exports: [
                        AccordionComponent,
                        AccordionButtonDirective,
                        AccordionItemComponent
                    ],
                    providers: [
                        AccordionService
                    ]
                }]
        }] });

class AlertHeadingDirective {
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: AlertHeadingDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "20.3.2", type: AlertHeadingDirective, isStandalone: true, selector: "[cAlertHeading]", host: { classAttribute: "alert-heading" }, ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: AlertHeadingDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[cAlertHeading]',
                    host: { class: 'alert-heading' }
                }]
        }] });

class AlertLinkDirective {
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: AlertLinkDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "20.3.2", type: AlertLinkDirective, isStandalone: true, selector: "[cAlertLink]", host: { classAttribute: "alert-link" }, ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: AlertLinkDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[cAlertLink]',
                    host: { class: 'alert-link' }
                }]
        }] });

class ButtonDirective {
    static ngAcceptInputType_active;
    static ngAcceptInputType_disabled;
    /**
     * Toggle the active state for the component. [docs]
     * @type InputSignalWithTransform<boolean, unknown>
     */
    active = input(false, ...(ngDevMode ? [{ debugName: "active", transform: booleanAttribute }] : [{ transform: booleanAttribute }]));
    /**
     * Sets the color context of the component to one of CoreUI’s themed colors. [docs]
     * @type InputSignal<Colors>
     */
    color = input('primary', ...(ngDevMode ? [{ debugName: "color" }] : []));
    /**
     * Toggle the disabled state for the component.
     * @type InputSignalWithTransform<boolean, unknown>
     */
    disabled = input(false, ...(ngDevMode ? [{ debugName: "disabled", transform: booleanAttribute }] : [{ transform: booleanAttribute }]));
    /**
     * Select the shape of the component.
     * @type InputSignal<Shapes>
     */
    shape = input(...(ngDevMode ? [undefined, { debugName: "shape" }] : []));
    /**
     * Size the component small or large.
     * @type InputSignal<'sm' | 'lg' | ''>
     */
    size = input('', ...(ngDevMode ? [{ debugName: "size" }] : []));
    /**
     * The tabindex attribute specifies the tab order of an element (when the "tab" button is used for navigating).
     */
    tabindex = input(undefined, ...(ngDevMode ? [{ debugName: "tabindex", transform: numberAttribute }] : [{ transform: numberAttribute }]));
    /**
     * Specifies the type of button. Always specify the type attribute for the `<button>` element.
     * Different browsers may use different default types for the `<button>` element.
     * @type InputSignal<ButtonType>
     * @default 'button'
     */
    type = input('button', ...(ngDevMode ? [{ debugName: "type" }] : []));
    /**
     * Set the button variant to an outlined button or a ghost button.
     * @type InputSignal<'ghost' | 'outline' | undefined>
     */
    variant = input(...(ngDevMode ? [undefined, { debugName: "variant" }] : []));
    hostClasses = computed(() => {
        return {
            btn: true,
            [`btn-${this.color()}`]: !!this.color() && !this.variant(),
            [`btn-${this.variant()}`]: !!this.variant() && !this.color(),
            [`btn-${this.variant()}-${this.color()}`]: !!this.variant() && !!this.color(),
            [`btn-${this.size()}`]: !!this.size(),
            [`${this.shape()}`]: !!this.shape(),
            active: this.active(),
            disabled: this._disabled()
        };
    }, ...(ngDevMode ? [{ debugName: "hostClasses" }] : []));
    _disabled = computed(() => this.disabled(), ...(ngDevMode ? [{ debugName: "_disabled" }] : []));
    ariaDisabled = computed(() => {
        return this._disabled() ? true : null;
    }, ...(ngDevMode ? [{ debugName: "ariaDisabled" }] : []));
    attrDisabled = computed(() => {
        return this._disabled() ? '' : null;
    }, ...(ngDevMode ? [{ debugName: "attrDisabled" }] : []));
    tabIndex = computed(() => {
        return this._disabled() ? '-1' : (this.tabindex() ?? null);
    }, ...(ngDevMode ? [{ debugName: "tabIndex" }] : []));
    isActive = computed(() => {
        return this.active() || null;
    }, ...(ngDevMode ? [{ debugName: "isActive" }] : []));
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: ButtonDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.1.0", version: "20.3.2", type: ButtonDirective, isStandalone: true, selector: "[cButton]", inputs: { active: { classPropertyName: "active", publicName: "active", isSignal: true, isRequired: false, transformFunction: null }, color: { classPropertyName: "color", publicName: "color", isSignal: true, isRequired: false, transformFunction: null }, disabled: { classPropertyName: "disabled", publicName: "disabled", isSignal: true, isRequired: false, transformFunction: null }, shape: { classPropertyName: "shape", publicName: "shape", isSignal: true, isRequired: false, transformFunction: null }, size: { classPropertyName: "size", publicName: "size", isSignal: true, isRequired: false, transformFunction: null }, tabindex: { classPropertyName: "tabindex", publicName: "tabindex", isSignal: true, isRequired: false, transformFunction: null }, type: { classPropertyName: "type", publicName: "type", isSignal: true, isRequired: false, transformFunction: null }, variant: { classPropertyName: "variant", publicName: "variant", isSignal: true, isRequired: false, transformFunction: null } }, host: { properties: { "class": "hostClasses()", "attr.aria-disabled": "ariaDisabled()", "attr.aria-pressed": "isActive()", "attr.disabled": "attrDisabled()", "attr.tabindex": "tabIndex()", "attr.type": "type()" }, classAttribute: "btn" }, exportAs: ["cButton"], ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: ButtonDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[cButton]',
                    exportAs: 'cButton',
                    host: {
                        class: 'btn',
                        '[class]': 'hostClasses()',
                        '[attr.aria-disabled]': 'ariaDisabled()',
                        '[attr.aria-pressed]': 'isActive()',
                        '[attr.disabled]': 'attrDisabled()',
                        '[attr.tabindex]': 'tabIndex()',
                        '[attr.type]': 'type()'
                    }
                }]
        }] });

class ButtonCloseDirective extends ButtonDirective {
    /**
     * Change the default color to white.
     * @type boolean
     * @deprecated 5.0.0. Use `cButtonClose.dark` instead.
     */
    white = input(false, ...(ngDevMode ? [{ debugName: "white", transform: booleanAttribute }] : [{ transform: booleanAttribute }]));
    hostClasses = computed(() => {
        return {
            btn: true,
            'btn-close': true,
            'btn-close-white': this.white(),
            [`btn-${this.size()}`]: !!this.size(),
            active: this.active(),
            disabled: this._disabled()
        };
    }, ...(ngDevMode ? [{ debugName: "hostClasses" }] : []));
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: ButtonCloseDirective, deps: null, target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.1.0", version: "20.3.2", type: ButtonCloseDirective, isStandalone: true, selector: "[cButtonClose]", inputs: { white: { classPropertyName: "white", publicName: "white", isSignal: true, isRequired: false, transformFunction: null } }, host: { properties: { "class": "hostClasses()", "attr.aria-disabled": "ariaDisabled()", "attr.aria-pressed": "isActive()", "attr.disabled": "attrDisabled()", "attr.tabindex": "tabIndex()", "attr.type": "type()" }, classAttribute: "btn btn-close" }, usesInheritance: true, hostDirectives: [{ directive: ThemeDirective, inputs: ["dark", "dark"] }], ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: ButtonCloseDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[cButtonClose]',
                    hostDirectives: [{ directive: ThemeDirective, inputs: ['dark'] }],
                    host: {
                        class: 'btn btn-close',
                        '[class]': 'hostClasses()',
                        '[attr.aria-disabled]': 'ariaDisabled()',
                        '[attr.aria-pressed]': 'isActive()',
                        '[attr.disabled]': 'attrDisabled()',
                        '[attr.tabindex]': 'tabIndex()',
                        '[attr.type]': 'type()'
                    }
                }]
        }] });

class ButtonModule {
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: ButtonModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
    static ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "20.3.2", ngImport: i0, type: ButtonModule, imports: [ButtonDirective,
            ButtonCloseDirective], exports: [ButtonDirective,
            ButtonCloseDirective] });
    static ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: ButtonModule });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: ButtonModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        ButtonDirective,
                        ButtonCloseDirective
                    ],
                    exports: [
                        ButtonDirective,
                        ButtonCloseDirective
                    ]
                }]
        }] });

class AlertComponent {
    /**
     * Sets the color context of the component to one of CoreUI’s themed colors.
     * @return Colors
     * @default 'primary'
     */
    color = input('primary', ...(ngDevMode ? [{ debugName: "color" }] : []));
    /**
     * Default role for alert. [docs]
     * @return string
     * @default 'alert'
     */
    role = input('alert', ...(ngDevMode ? [{ debugName: "role" }] : []));
    /**
     * Set the alert variant to a solid.
     * @return string
     */
    variant = input(...(ngDevMode ? [undefined, { debugName: "variant" }] : []));
    /**
     * Optionally adds a close button to alert and allow it to self dismiss.
     * @return boolean
     * @default false
     */
    dismissibleInput = input(false, ...(ngDevMode ? [{ debugName: "dismissibleInput", transform: booleanAttribute, alias: 'dismissible' }] : [{ transform: booleanAttribute, alias: 'dismissible' }]));
    #dismissible = linkedSignal({
        source: this.dismissibleInput,
        computation: (value) => {
            return value;
        }
    });
    set dismissible(value) {
        this.#dismissible.set(value);
    }
    get dismissible() {
        return this.#dismissible();
    }
    /**
     * Adds animation for dismissible alert.
     * @return boolean
     */
    fade = input(false, ...(ngDevMode ? [{ debugName: "fade", transform: booleanAttribute }] : [{ transform: booleanAttribute }]));
    /**
     * Toggle the visibility of alert component.
     * @return boolean
     */
    visibleInput = input(true, ...(ngDevMode ? [{ debugName: "visibleInput", transform: booleanAttribute, alias: 'visible' }] : [{ transform: booleanAttribute, alias: 'visible' }]));
    #visible = linkedSignal({
        source: this.visibleInput,
        computation: (value) => {
            return value;
        }
    });
    set visible(value) {
        if (this.#visible() !== value) {
            this.#visible.set(value);
            this.visibleChange?.emit(value);
        }
    }
    get visible() {
        return this.#visible();
    }
    hide = signal(false, ...(ngDevMode ? [{ debugName: "hide" }] : []));
    /**
     * Event triggered on the alert dismiss.
     */
    visibleChange = output();
    contentTemplates = contentChildren(TemplateIdDirective, ...(ngDevMode ? [{ debugName: "contentTemplates", descendants: true }] : [{ descendants: true }]));
    templates = computed(() => {
        return this.contentTemplates().reduce((acc, child) => {
            acc[child.id] = child.templateRef;
            return acc;
        }, {});
    }, ...(ngDevMode ? [{ debugName: "templates" }] : []));
    get animateType() {
        return this.visible ? 'show' : 'hide';
    }
    hostClasses = computed(() => {
        const color = this.color();
        const variant = this.variant();
        return {
            alert: true,
            'alert-dismissible': this.dismissible,
            fade: this.fade(),
            show: !this.hide(),
            [`alert-${color}`]: !!color && variant !== 'solid',
            [`bg-${color}`]: !!color && variant === 'solid',
            'text-white': !!color && variant === 'solid'
        };
    }, ...(ngDevMode ? [{ debugName: "hostClasses" }] : []));
    onAnimationStart($event) {
        this.onAnimationEvent($event);
    }
    onAnimationDone($event) {
        this.onAnimationEvent($event);
    }
    onAnimationEvent(event) {
        this.hide.set(event.phaseName === 'start' && event.toState === 'show');
        if (event.phaseName === 'done') {
            this.hide.set(event.toState === 'hide' || event.toState === 'void');
            if (event.toState === 'show') {
                this.hide.set(false);
            }
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: AlertComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "20.3.2", type: AlertComponent, isStandalone: true, selector: "c-alert", inputs: { color: { classPropertyName: "color", publicName: "color", isSignal: true, isRequired: false, transformFunction: null }, role: { classPropertyName: "role", publicName: "role", isSignal: true, isRequired: false, transformFunction: null }, variant: { classPropertyName: "variant", publicName: "variant", isSignal: true, isRequired: false, transformFunction: null }, dismissibleInput: { classPropertyName: "dismissibleInput", publicName: "dismissible", isSignal: true, isRequired: false, transformFunction: null }, fade: { classPropertyName: "fade", publicName: "fade", isSignal: true, isRequired: false, transformFunction: null }, visibleInput: { classPropertyName: "visibleInput", publicName: "visible", isSignal: true, isRequired: false, transformFunction: null } }, outputs: { visibleChange: "visibleChange" }, host: { listeners: { "@fadeInOut.start": "onAnimationStart($event)", "@fadeInOut.done": "onAnimationDone($event)" }, properties: { "@.disabled": "!fade()", "@fadeInOut": "animateType", "attr.role": "role()", "class": "hostClasses()" } }, queries: [{ propertyName: "contentTemplates", predicate: TemplateIdDirective, descendants: true, isSignal: true }], exportAs: ["cAlert"], ngImport: i0, template: "@if (visible || !hide()) {\n  @if (dismissible) {\n    <ng-container *ngTemplateOutlet=\"templates()?.['alertButtonCloseTemplate'] || defaultAlertButtonCloseTemplate\" />\n  }\n  <ng-content />\n}\n<ng-template #defaultAlertButtonCloseTemplate>\n  <button (click)=\"visible=false\" aria-label=\"Close\" cButtonClose></button>\n</ng-template>\n", styles: [":host{display:block;overflow:hidden}\n"], dependencies: [{ kind: "directive", type: NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }, { kind: "directive", type: ButtonCloseDirective, selector: "[cButtonClose]", inputs: ["white"] }], animations: [
            trigger('fadeInOut', [
                state('show', style({ opacity: 1, height: '*', padding: '*', border: '*', margin: '*' })),
                state('hide', style({ opacity: 0, height: 0, padding: 0, border: 0, margin: 0 })),
                state('void', style({ opacity: 0, height: 0, padding: 0, border: 0, margin: 0 })),
                transition('show => hide', [animate('.3s ease-out')]),
                transition('hide => show', [animate('.3s ease-in')]),
                transition('show => void', [animate('.3s ease-out')]),
                transition('void => show', [animate('.3s ease-in')])
            ])
        ] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: AlertComponent, decorators: [{
            type: Component,
            args: [{ selector: 'c-alert', exportAs: 'cAlert', imports: [NgTemplateOutlet, ButtonCloseDirective], animations: [
                        trigger('fadeInOut', [
                            state('show', style({ opacity: 1, height: '*', padding: '*', border: '*', margin: '*' })),
                            state('hide', style({ opacity: 0, height: 0, padding: 0, border: 0, margin: 0 })),
                            state('void', style({ opacity: 0, height: 0, padding: 0, border: 0, margin: 0 })),
                            transition('show => hide', [animate('.3s ease-out')]),
                            transition('hide => show', [animate('.3s ease-in')]),
                            transition('show => void', [animate('.3s ease-out')]),
                            transition('void => show', [animate('.3s ease-in')])
                        ])
                    ], host: {
                        '[@.disabled]': '!fade()',
                        '[@fadeInOut]': 'animateType',
                        '[attr.role]': 'role()',
                        '[class]': 'hostClasses()',
                        '(@fadeInOut.start)': 'onAnimationStart($event)',
                        '(@fadeInOut.done)': 'onAnimationDone($event)'
                    }, template: "@if (visible || !hide()) {\n  @if (dismissible) {\n    <ng-container *ngTemplateOutlet=\"templates()?.['alertButtonCloseTemplate'] || defaultAlertButtonCloseTemplate\" />\n  }\n  <ng-content />\n}\n<ng-template #defaultAlertButtonCloseTemplate>\n  <button (click)=\"visible=false\" aria-label=\"Close\" cButtonClose></button>\n</ng-template>\n", styles: [":host{display:block;overflow:hidden}\n"] }]
        }] });

class AlertModule {
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: AlertModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
    static ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "20.3.2", ngImport: i0, type: AlertModule, imports: [AlertComponent,
            AlertHeadingDirective,
            AlertLinkDirective], exports: [AlertComponent,
            AlertHeadingDirective,
            AlertLinkDirective] });
    static ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: AlertModule });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: AlertModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        AlertComponent,
                        AlertHeadingDirective,
                        AlertLinkDirective
                    ],
                    exports: [
                        AlertComponent,
                        AlertHeadingDirective,
                        AlertLinkDirective
                    ]
                }]
        }] });

class AlignDirective {
    /**
     * Set vertical alignment of inline, inline-block, inline-table, and table cell elements
     * @return Alignment
     */
    align = input(undefined, ...(ngDevMode ? [{ debugName: "align", alias: 'cAlign' }] : [{ alias: 'cAlign' }]));
    hostClasses = computed(() => {
        const align = this.align();
        return {
            [`align-${align}`]: !!align
        };
    }, ...(ngDevMode ? [{ debugName: "hostClasses" }] : []));
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: AlignDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.1.0", version: "20.3.2", type: AlignDirective, isStandalone: true, selector: "[cAlign]", inputs: { align: { classPropertyName: "align", publicName: "cAlign", isSignal: true, isRequired: false, transformFunction: null } }, host: { properties: { "class": "hostClasses()" } }, exportAs: ["cAlign"], ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: AlignDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[cAlign]',
                    exportAs: 'cAlign',
                    host: { '[class]': 'hostClasses()' }
                }]
        }] });

class BgColorDirective {
    /**
     * Set the background of an element to any contextual class
     */
    cBgColor = input('', ...(ngDevMode ? [{ debugName: "cBgColor" }] : []));
    /**
     * Add linear gradient as background image to the backgrounds.
     * @return boolean
     */
    gradient = input(...(ngDevMode ? [undefined, { debugName: "gradient" }] : []));
    hostClasses = computed(() => {
        const color = this.cBgColor();
        return {
            [`bg-${color}`]: !!color,
            'bg-gradient': this.gradient()
        };
    }, ...(ngDevMode ? [{ debugName: "hostClasses" }] : []));
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: BgColorDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.1.0", version: "20.3.2", type: BgColorDirective, isStandalone: true, selector: "[cBgColor]", inputs: { cBgColor: { classPropertyName: "cBgColor", publicName: "cBgColor", isSignal: true, isRequired: false, transformFunction: null }, gradient: { classPropertyName: "gradient", publicName: "gradient", isSignal: true, isRequired: false, transformFunction: null } }, host: { properties: { "class": "hostClasses()" } }, exportAs: ["cBgColor"], ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: BgColorDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[cBgColor]',
                    exportAs: 'cBgColor',
                    host: { '[class]': 'hostClasses()' }
                }]
        }] });

class BorderDirective {
    /**
     * Add or remove an element’s borders
     * @return Border
     */
    cBorder = input(true, ...(ngDevMode ? [{ debugName: "cBorder" }] : []));
    hostClasses = computed(() => {
        const border = this.cBorder();
        if (typeof border === 'boolean') {
            return { border: border };
        }
        if (typeof border === 'number' || typeof border === 'string') {
            return {
                border: true,
                [`border-${border}`]: true
            };
        }
        if (typeof border === 'object') {
            const borderObj = {
                top: undefined,
                end: undefined,
                bottom: undefined,
                start: undefined,
                color: undefined,
                ...border
            };
            // @ts-ignore
            const keys = Object.keys(borderObj).filter((key) => borderObj[key] !== undefined);
            const classes = {};
            keys.forEach((key) => {
                // @ts-ignore
                const val = borderObj[key];
                if (typeof val === 'boolean') {
                    // @ts-ignore
                    classes[`border-${key}`] = true;
                }
                else if (typeof val === 'number' || typeof val === 'string') {
                    // @ts-ignore
                    classes[`border-${key}-${val}`] = true;
                }
                else if (typeof val === 'object') {
                    if ('color' in val) {
                        // @ts-ignore
                        classes[`border-${key}-${val.color}`] = true;
                    }
                    if ('width' in val) {
                        // @ts-ignore
                        classes[`border-${key}-${val.width}`] = true;
                    }
                }
            });
            return Object.entries(classes).length === 0 ? { border: false } : classes;
        }
        return { border: false };
    }, ...(ngDevMode ? [{ debugName: "hostClasses" }] : []));
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: BorderDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.1.0", version: "20.3.2", type: BorderDirective, isStandalone: true, selector: "[cBorder]", inputs: { cBorder: { classPropertyName: "cBorder", publicName: "cBorder", isSignal: true, isRequired: false, transformFunction: null } }, host: { properties: { "class": "hostClasses()" } }, exportAs: ["cBorder"], ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: BorderDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[cBorder]',
                    exportAs: 'cBorder',
                    host: { '[class]': 'hostClasses()' }
                }]
        }] });

class RoundedDirective {
    /**
     * Set border radius variant and radius size
     * @type Rounded
     */
    cRounded = input(true, ...(ngDevMode ? [{ debugName: "cRounded" }] : []));
    hostClasses = computed(() => {
        const rounded = this.cRounded();
        if (typeof rounded === 'boolean') {
            return { rounded: rounded };
        }
        if (typeof rounded === 'number' || typeof rounded === 'string') {
            return {
                [`rounded-${rounded}`]: true
            };
        }
        if (typeof rounded === 'object') {
            const roundedObj = {
                top: undefined,
                end: undefined,
                bottom: undefined,
                start: undefined,
                circle: undefined,
                pill: undefined,
                size: undefined,
                ...rounded
            };
            // @ts-ignore
            const keys = Object.keys(roundedObj).filter((key) => roundedObj[key] !== undefined);
            const classes = {};
            keys.forEach((key) => {
                // @ts-ignore
                const val = roundedObj[key];
                if (typeof val === 'boolean') {
                    // @ts-ignore
                    classes[`rounded-${key}`] = val;
                }
                else {
                    // @ts-ignore
                    classes[`rounded-${val}`] = true;
                }
            });
            // console.log('rounded keys', keys, classes);
            return Object.entries(classes).length === 0 ? { rounded: false } : classes;
        }
        return { rounded: false };
    }, ...(ngDevMode ? [{ debugName: "hostClasses" }] : []));
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: RoundedDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.1.0", version: "20.3.2", type: RoundedDirective, isStandalone: true, selector: "[cRounded]", inputs: { cRounded: { classPropertyName: "cRounded", publicName: "cRounded", isSignal: true, isRequired: false, transformFunction: null } }, host: { properties: { "class": "hostClasses()" } }, exportAs: ["cRounded"], ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: RoundedDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[cRounded]',
                    exportAs: 'cRounded',
                    host: { '[class]': 'hostClasses()' }
                }]
        }] });

class ShadowOnScrollDirective {
    #destroyRef = inject(DestroyRef);
    #document = inject(DOCUMENT);
    #elementRef = inject(ElementRef);
    #scrolled = signal(false, ...(ngDevMode ? [{ debugName: "#scrolled" }] : []));
    #scrollEffect = effect(() => {
        this.#elementRef.nativeElement.classList.toggle(this.#shadowClass, this.#scrolled());
    }, ...(ngDevMode ? [{ debugName: "#scrollEffect" }] : []));
    #observable;
    #shadowClass = 'shadow-sm';
    constructor() {
        this.#destroyRef.onDestroy(() => {
            this.#scrollEffect?.destroy();
        });
    }
    cShadowOnScroll = input(true, ...(ngDevMode ? [{ debugName: "cShadowOnScroll" }] : []));
    #shadowOnScrollEffect = effect(() => {
        const value = this.cShadowOnScroll();
        untracked(() => {
            this.#scrolled.set(false);
            if (value) {
                this.#shadowClass = value === true ? 'shadow' : `shadow-${value}`;
                this.#observable = fromEvent(this.#document, 'scroll')
                    .pipe(takeUntilDestroyed(this.#destroyRef))
                    .subscribe((scrolled) => {
                    this.#scrolled.set(this.#document.documentElement.scrollTop > 0);
                });
            }
            else {
                this.#observable?.unsubscribe();
            }
        });
    }, ...(ngDevMode ? [{ debugName: "#shadowOnScrollEffect" }] : []));
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: ShadowOnScrollDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.1.0", version: "20.3.2", type: ShadowOnScrollDirective, isStandalone: true, selector: "[cShadowOnScroll]", inputs: { cShadowOnScroll: { classPropertyName: "cShadowOnScroll", publicName: "cShadowOnScroll", isSignal: true, isRequired: false, transformFunction: null } }, exportAs: ["cShadowOnScroll"], ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: ShadowOnScrollDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[cShadowOnScroll]',
                    exportAs: 'cShadowOnScroll'
                }]
        }], ctorParameters: () => [] });

class TextColorDirective {
    /**
     * Set text-color of element
     * @type TextColors
     */
    color = input('', ...(ngDevMode ? [{ debugName: "color", alias: 'cTextColor' }] : [{ alias: 'cTextColor' }]));
    hostClasses = computed(() => {
        const color = this.color();
        return {
            [`text-${color}`]: !!color
        };
    }, ...(ngDevMode ? [{ debugName: "hostClasses" }] : []));
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: TextColorDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.1.0", version: "20.3.2", type: TextColorDirective, isStandalone: true, selector: "[cTextColor]", inputs: { color: { classPropertyName: "color", publicName: "cTextColor", isSignal: true, isRequired: false, transformFunction: null } }, host: { properties: { "class": "hostClasses()" } }, ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: TextColorDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[cTextColor]',
                    host: {
                        '[class]': 'hostClasses()'
                    }
                }]
        }] });

class TextBgColorDirective {
    /**
     * Set text-bg-color of element
     * @type Colors
     */
    textBgColor = input('', ...(ngDevMode ? [{ debugName: "textBgColor", alias: 'cTextBgColor' }] : [{ alias: 'cTextBgColor' }]));
    hostClasses = computed(() => {
        const color = this.textBgColor();
        return {
            [`text-bg-${color}`]: !!color
        };
    }, ...(ngDevMode ? [{ debugName: "hostClasses" }] : []));
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: TextBgColorDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.1.0", version: "20.3.2", type: TextBgColorDirective, isStandalone: true, selector: "[cTextBgColor]", inputs: { textBgColor: { classPropertyName: "textBgColor", publicName: "cTextBgColor", isSignal: true, isRequired: false, transformFunction: null } }, host: { properties: { "class": "hostClasses()" } }, ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: TextBgColorDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[cTextBgColor]',
                    host: {
                        '[class]': 'hostClasses()'
                    }
                }]
        }] });

const UTILITY_DIRECTIVES = [
    AlignDirective,
    BgColorDirective,
    BorderDirective,
    RoundedDirective,
    ShadowOnScrollDirective,
    TextColorDirective,
    TextBgColorDirective
];
class UtilitiesModule {
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: UtilitiesModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
    static ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "20.3.2", ngImport: i0, type: UtilitiesModule, imports: [AlignDirective,
            BgColorDirective,
            BorderDirective,
            RoundedDirective,
            ShadowOnScrollDirective,
            TextColorDirective,
            TextBgColorDirective], exports: [AlignDirective,
            BgColorDirective,
            BorderDirective,
            RoundedDirective,
            ShadowOnScrollDirective,
            TextColorDirective,
            TextBgColorDirective] });
    static ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: UtilitiesModule });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: UtilitiesModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [...UTILITY_DIRECTIVES],
                    exports: [...UTILITY_DIRECTIVES]
                }]
        }] });

class AvatarComponent {
    /**
     * Sets the background color context of the component to one of CoreUI’s themed colors.
     * @type Colors
     */
    color = input(...(ngDevMode ? [undefined, { debugName: "color" }] : []));
    /**
     * Select the shape of the component.
     * @type Shapes
     */
    shape = input(...(ngDevMode ? [undefined, { debugName: "shape" }] : []));
    /**
     * Size the component small, large, or extra large.
     * @default 'md'
     */
    size = input('', ...(ngDevMode ? [{ debugName: "size" }] : []));
    /**
     * The alt attribute for the img element alternate text.
     * @type string
     */
    alt = input('', ...(ngDevMode ? [{ debugName: "alt" }] : []));
    /**
     * The src attribute for the img element.
     * @type string
     */
    src = input(...(ngDevMode ? [undefined, { debugName: "src" }] : []));
    /**
     * Sets the color context of the status indicator to one of CoreUI’s themed colors.
     * @type Colors
     */
    status = input(...(ngDevMode ? [undefined, { debugName: "status" }] : []));
    /**
     * Sets the text color of the component to one of CoreUI’s themed colors.
     * via TextColorDirective
     * @type TextColors
     */
    textColor = input(...(ngDevMode ? [undefined, { debugName: "textColor" }] : []));
    statusClass = computed(() => {
        return {
            'avatar-status': true,
            [`bg-${this.status()}`]: !!this.status()
        };
    }, ...(ngDevMode ? [{ debugName: "statusClass" }] : []));
    hostClasses = computed(() => {
        return {
            avatar: true,
            [`avatar-${this.size()}`]: !!this.size(),
            [`bg-${this.color()}`]: !!this.color(),
            [`${this.shape()}`]: !!this.shape()
        };
    }, ...(ngDevMode ? [{ debugName: "hostClasses" }] : []));
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: AvatarComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "20.3.2", type: AvatarComponent, isStandalone: true, selector: "c-avatar", inputs: { color: { classPropertyName: "color", publicName: "color", isSignal: true, isRequired: false, transformFunction: null }, shape: { classPropertyName: "shape", publicName: "shape", isSignal: true, isRequired: false, transformFunction: null }, size: { classPropertyName: "size", publicName: "size", isSignal: true, isRequired: false, transformFunction: null }, alt: { classPropertyName: "alt", publicName: "alt", isSignal: true, isRequired: false, transformFunction: null }, src: { classPropertyName: "src", publicName: "src", isSignal: true, isRequired: false, transformFunction: null }, status: { classPropertyName: "status", publicName: "status", isSignal: true, isRequired: false, transformFunction: null }, textColor: { classPropertyName: "textColor", publicName: "textColor", isSignal: true, isRequired: false, transformFunction: null } }, host: { properties: { "class": "hostClasses()" }, classAttribute: "avatar" }, hostDirectives: [{ directive: TextColorDirective, inputs: ["cTextColor", "textColor"] }], ngImport: i0, template: "<ng-content>\n  @if (src()) {\n    @defer (prefetch on idle) {\n      <img src=\"{{src() ?? ''}}\" class=\"avatar-img\" alt=\"{{alt()}}\" />\n    } @placeholder () {\n      <svg aria-label=\"Avatar placeholder\"\n           focusable=\"false\"\n           preserveAspectRatio=\"xMidYMid slice\"\n           role=\"img\"\n           xmlns=\"http://www.w3.org/2000/svg\"\n           class=\"avatar-img\"\n           style=\"position: absolute; width: 100%; height: 100%; inset: 0;\">\n        <rect fill=\"#868e96\" height=\"100%\" width=\"100%\"></rect>\n      </svg>\n    }\n  }\n</ng-content>\n@if (!!status()) {\n  <span [ngClass]=\"statusClass()\"></span>\n}\n\n", styles: [":host .avatar-img{object-fit:cover}\n"], dependencies: [{ kind: "directive", type: NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: AvatarComponent, decorators: [{
            type: Component,
            args: [{ selector: 'c-avatar', imports: [NgClass], hostDirectives: [
                        {
                            directive: TextColorDirective,
                            inputs: ['cTextColor: textColor']
                        }
                    ], host: { class: 'avatar', '[class]': 'hostClasses()' }, template: "<ng-content>\n  @if (src()) {\n    @defer (prefetch on idle) {\n      <img src=\"{{src() ?? ''}}\" class=\"avatar-img\" alt=\"{{alt()}}\" />\n    } @placeholder () {\n      <svg aria-label=\"Avatar placeholder\"\n           focusable=\"false\"\n           preserveAspectRatio=\"xMidYMid slice\"\n           role=\"img\"\n           xmlns=\"http://www.w3.org/2000/svg\"\n           class=\"avatar-img\"\n           style=\"position: absolute; width: 100%; height: 100%; inset: 0;\">\n        <rect fill=\"#868e96\" height=\"100%\" width=\"100%\"></rect>\n      </svg>\n    }\n  }\n</ng-content>\n@if (!!status()) {\n  <span [ngClass]=\"statusClass()\"></span>\n}\n\n", styles: [":host .avatar-img{object-fit:cover}\n"] }]
        }] });

class AvatarModule {
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: AvatarModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
    static ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "20.3.2", ngImport: i0, type: AvatarModule, imports: [AvatarComponent], exports: [AvatarComponent] });
    static ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: AvatarModule });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: AvatarModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        AvatarComponent
                    ],
                    exports: [
                        AvatarComponent
                    ]
                }]
        }] });

class BadgeComponent {
    /**
     * Sets the color context of the component to one of CoreUI’s themed colors.
     * @type Colors
     */
    color = input(...(ngDevMode ? [undefined, { debugName: "color" }] : []));
    /**
     * Position badge in one of the corners of a link or button.
     * @type BadgePositions
     */
    position = input(...(ngDevMode ? [undefined, { debugName: "position" }] : []));
    /**
     * Select the shape of the component.
     * @type Shapes
     */
    shape = input(...(ngDevMode ? [undefined, { debugName: "shape" }] : []));
    /**
     * Size the component small.
     */
    size = input(...(ngDevMode ? [undefined, { debugName: "size" }] : []));
    /**
     * Sets the text color of the component to one of CoreUI’s themed colors.
     * via TextColorDirective
     * @type TextColors
     */
    textColor = input(...(ngDevMode ? [undefined, { debugName: "textColor" }] : []));
    /**
     * Sets the component's color scheme to one of CoreUI's themed colors, ensuring the text color contrast adheres to the WCAG 4.5:1 contrast ratio standard for accessibility.
     * via TextBgColorDirective
     * @type Colors
     * @since 5.0.0
     */
    textBgColor = input(...(ngDevMode ? [undefined, { debugName: "textBgColor" }] : []));
    hostClasses = computed(() => {
        const position = this.position();
        const positionClasses = {
            'position-absolute': !!position,
            'translate-middle': !!position,
            'top-0': position?.includes('top'),
            'top-100': position?.includes('bottom'),
            'start-100': position?.includes('end'),
            'start-0': position?.includes('start')
        };
        return Object.assign({
            badge: true,
            [`bg-${this.color()}`]: !!this.color(),
            [`badge-${this.size()}`]: !!this.size(),
            [`${this.shape()}`]: !!this.shape()
        }, !!position ? positionClasses : {});
    }, ...(ngDevMode ? [{ debugName: "hostClasses" }] : []));
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: BadgeComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.1.0", version: "20.3.2", type: BadgeComponent, isStandalone: true, selector: "c-badge", inputs: { color: { classPropertyName: "color", publicName: "color", isSignal: true, isRequired: false, transformFunction: null }, position: { classPropertyName: "position", publicName: "position", isSignal: true, isRequired: false, transformFunction: null }, shape: { classPropertyName: "shape", publicName: "shape", isSignal: true, isRequired: false, transformFunction: null }, size: { classPropertyName: "size", publicName: "size", isSignal: true, isRequired: false, transformFunction: null }, textColor: { classPropertyName: "textColor", publicName: "textColor", isSignal: true, isRequired: false, transformFunction: null }, textBgColor: { classPropertyName: "textBgColor", publicName: "textBgColor", isSignal: true, isRequired: false, transformFunction: null } }, host: { properties: { "class": "hostClasses()" }, classAttribute: "badge" }, hostDirectives: [{ directive: TextColorDirective, inputs: ["cTextColor", "textColor"] }, { directive: TextBgColorDirective, inputs: ["cTextBgColor", "textBgColor"] }], ngImport: i0, template: '<ng-content />', isInline: true });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: BadgeComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'c-badge',
                    template: '<ng-content />',
                    hostDirectives: [
                        { directive: TextColorDirective, inputs: ['cTextColor: textColor'] },
                        { directive: TextBgColorDirective, inputs: ['cTextBgColor: textBgColor'] }
                    ],
                    host: {
                        class: 'badge',
                        '[class]': 'hostClasses()'
                    }
                }]
        }] });

class BadgeModule {
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: BadgeModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
    static ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "20.3.2", ngImport: i0, type: BadgeModule, imports: [BadgeComponent], exports: [BadgeComponent] });
    static ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: BadgeModule });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: BadgeModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        BadgeComponent
                    ],
                    exports: [
                        BadgeComponent
                    ]
                }]
        }] });

class BackdropService {
    #backdropClick = new Subject();
    backdropClick$ = this.#backdropClick.asObservable();
    #document = inject(DOCUMENT);
    #rendererFactory = inject(RendererFactory2);
    #renderer = this.#rendererFactory.createRenderer(null, null);
    #unListen;
    activeBackdrop;
    get #scrollbarWidth() {
        // https://developer.mozilla.org/en-US/docs/Web/API/Window/innerWidth#usage_notes
        const documentWidth = this.#document.documentElement.clientWidth;
        const scrollbarWidth = Math.abs((this.#document.defaultView?.innerWidth ?? documentWidth) - documentWidth);
        return `${scrollbarWidth}px`;
    }
    scrollbarWidth = this.#scrollbarWidth;
    setBackdrop(type = 'modal') {
        const backdropElement = this.#renderer.createElement('div');
        this.#renderer.addClass(backdropElement, `${type}-backdrop`);
        this.#renderer.addClass(backdropElement, 'fade');
        this.#renderer.appendChild(this.#document.body, backdropElement);
        this.#unListen = this.#renderer.listen(backdropElement, 'click', (e) => {
            this.onClickHandler();
        });
        this.scrollbarWidth = this.#scrollbarWidth;
        setTimeout(() => {
            this.#renderer.addClass(backdropElement, 'show');
            // this.hideScrollbar();
        });
        this.activeBackdrop = backdropElement;
        return backdropElement;
    }
    clearBackdrop(backdropElement) {
        if (backdropElement) {
            this.#unListen();
            this.#renderer.removeClass(backdropElement, 'show');
            setTimeout(() => {
                if (this.activeBackdrop === backdropElement) {
                    this.resetScrollbar();
                }
                this.#renderer.removeChild(this.#document.body, backdropElement);
                backdropElement = undefined;
            }, 300);
        }
        return undefined;
    }
    get #isRTL() {
        return [this.#document.documentElement.dir, this.#document.body.dir].includes('rtl');
    }
    #scrollBarVisible = true;
    hideScrollbar() {
        if (this.#scrollBarVisible) {
            this.#renderer.setStyle(this.#document.body, 'overflow', 'hidden');
            this.#renderer.setStyle(this.#document.body, `padding-${this.#isRTL ? 'left' : 'right'}`, this.scrollbarWidth);
            this.#scrollBarVisible = false;
        }
    }
    resetScrollbar() {
        this.#renderer.removeStyle(this.#document.body, 'overflow');
        this.#renderer.removeStyle(this.#document.body, `padding-${this.#isRTL ? 'left' : 'right'}`);
        this.#scrollBarVisible = true;
    }
    onClickHandler() {
        this.#backdropClick.next(true);
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: BackdropService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: BackdropService, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: BackdropService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root'
                }]
        }] });

class BreadcrumbItemComponent {
    /**
     * Toggle the active state for the component. [docs]
     * @return boolean
     */
    active = input(undefined, ...(ngDevMode ? [{ debugName: "active", transform: booleanAttribute }] : [{ transform: booleanAttribute }]));
    /**
     * The `url` prop for the inner `[routerLink]` directive. [docs]
     * @return string
     */
    url = input(...(ngDevMode ? [undefined, { debugName: "url" }] : []));
    /**
     * Additional html attributes for link. [docs]
     * @return INavAttributes
     */
    attribs = input(...(ngDevMode ? [undefined, { debugName: "attribs" }] : []));
    _attributes = input(undefined, ...(ngDevMode ? [{ debugName: "_attributes", alias: 'attributes' }] : [{ alias: 'attributes' }]));
    #attributesEffect = effect(() => {
        if (this._attributes()) {
            console.error('c-breadcrumb-item: [attributes] prop is removed, use [attribs] instead:', this._attributes());
        }
    }, ...(ngDevMode ? [{ debugName: "#attributesEffect" }] : []));
    /**
     * Some `NavigationExtras` props for the inner `[routerLink]` directive and `routerLinkActiveOptions`. [docs]
     * @return INavLinkProps
     */
    linkProps = input(...(ngDevMode ? [undefined, { debugName: "linkProps" }] : []));
    ariaCurrent = computed(() => {
        return this.active() ? 'page' : null;
    }, ...(ngDevMode ? [{ debugName: "ariaCurrent" }] : []));
    hostClasses = computed(() => {
        return {
            'breadcrumb-item': true,
            active: this.active()
        };
    }, ...(ngDevMode ? [{ debugName: "hostClasses" }] : []));
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: BreadcrumbItemComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "20.3.2", type: BreadcrumbItemComponent, isStandalone: true, selector: "c-breadcrumb-item", inputs: { active: { classPropertyName: "active", publicName: "active", isSignal: true, isRequired: false, transformFunction: null }, url: { classPropertyName: "url", publicName: "url", isSignal: true, isRequired: false, transformFunction: null }, attribs: { classPropertyName: "attribs", publicName: "attribs", isSignal: true, isRequired: false, transformFunction: null }, _attributes: { classPropertyName: "_attributes", publicName: "attributes", isSignal: true, isRequired: false, transformFunction: null }, linkProps: { classPropertyName: "linkProps", publicName: "linkProps", isSignal: true, isRequired: false, transformFunction: null } }, host: { properties: { "attr.aria-current": "ariaCurrent()", "class": "hostClasses()" } }, exportAs: ["breadcrumbItem"], ngImport: i0, template: "@if (!active()) {\n  <a [routerLink]=\"url()\"\n     [cHtmlAttr]=\"attribs() ?? {}\"\n     [target]=\"attribs()?.['target']\"\n     [queryParams]=\"linkProps()?.queryParams ?? null\"\n     [fragment]=\"linkProps()?.fragment\"\n     [queryParamsHandling]=\"linkProps()?.queryParamsHandling ?? null\"\n     [preserveFragment]=\"linkProps()?.preserveFragment ?? false\"\n     [skipLocationChange]=\"linkProps()?.skipLocationChange ?? false\"\n     [replaceUrl]=\"linkProps()?.replaceUrl ?? false\"\n     [state]=\"linkProps()?.state ?? {}\"\n  >\n    <ng-container *ngTemplateOutlet=\"defaultBreadcrumbItemContentTemplate\" />\n  </a>\n} @else {\n  <span [cHtmlAttr]=\"attribs() ?? {}\">\n      <ng-container *ngTemplateOutlet=\"defaultBreadcrumbItemContentTemplate\" />\n  </span>\n}\n\n<ng-template #defaultBreadcrumbItemContentTemplate>\n  <ng-content />\n</ng-template>\n", styles: [":host{display:list-item;text-align:-webkit-match-parent;text-align:match-parent}\n"], dependencies: [{ kind: "ngmodule", type: RouterModule }, { kind: "directive", type: i1.RouterLink, selector: "[routerLink]", inputs: ["target", "queryParams", "fragment", "queryParamsHandling", "state", "info", "relativeTo", "preserveFragment", "skipLocationChange", "replaceUrl", "routerLink"] }, { kind: "directive", type: NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }, { kind: "directive", type: HtmlAttributesDirective, selector: "[cHtmlAttr]", inputs: ["cHtmlAttr"], exportAs: ["cHtmlAttr"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: BreadcrumbItemComponent, decorators: [{
            type: Component,
            args: [{ selector: 'c-breadcrumb-item', imports: [RouterModule, NgTemplateOutlet, HtmlAttributesDirective], exportAs: 'breadcrumbItem', host: {
                        '[attr.aria-current]': 'ariaCurrent()',
                        '[class]': 'hostClasses()'
                    }, template: "@if (!active()) {\n  <a [routerLink]=\"url()\"\n     [cHtmlAttr]=\"attribs() ?? {}\"\n     [target]=\"attribs()?.['target']\"\n     [queryParams]=\"linkProps()?.queryParams ?? null\"\n     [fragment]=\"linkProps()?.fragment\"\n     [queryParamsHandling]=\"linkProps()?.queryParamsHandling ?? null\"\n     [preserveFragment]=\"linkProps()?.preserveFragment ?? false\"\n     [skipLocationChange]=\"linkProps()?.skipLocationChange ?? false\"\n     [replaceUrl]=\"linkProps()?.replaceUrl ?? false\"\n     [state]=\"linkProps()?.state ?? {}\"\n  >\n    <ng-container *ngTemplateOutlet=\"defaultBreadcrumbItemContentTemplate\" />\n  </a>\n} @else {\n  <span [cHtmlAttr]=\"attribs() ?? {}\">\n      <ng-container *ngTemplateOutlet=\"defaultBreadcrumbItemContentTemplate\" />\n  </span>\n}\n\n<ng-template #defaultBreadcrumbItemContentTemplate>\n  <ng-content />\n</ng-template>\n", styles: [":host{display:list-item;text-align:-webkit-match-parent;text-align:match-parent}\n"] }]
        }] });

class BreadcrumbComponent {
    /**
     * Default aria-label for breadcrumb. [docs]
     * @return string
     * @default 'breadcrumb'
     */
    ariaLabel = input('breadcrumb', ...(ngDevMode ? [{ debugName: "ariaLabel" }] : []));
    /**
     * Default role for breadcrumb. [docs]
     * @return string
     * @default 'navigation'
     */
    role = input('navigation', ...(ngDevMode ? [{ debugName: "role" }] : []));
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: BreadcrumbComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.1.0", version: "20.3.2", type: BreadcrumbComponent, isStandalone: true, selector: "c-breadcrumb", inputs: { ariaLabel: { classPropertyName: "ariaLabel", publicName: "ariaLabel", isSignal: true, isRequired: false, transformFunction: null }, role: { classPropertyName: "role", publicName: "role", isSignal: true, isRequired: false, transformFunction: null } }, host: { properties: { "attr.aria-label": "ariaLabel()", "attr.role": "role()" }, classAttribute: "breadcrumb" }, ngImport: i0, template: '<ng-content />', isInline: true });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: BreadcrumbComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'c-breadcrumb',
                    template: '<ng-content />',
                    host: {
                        class: 'breadcrumb',
                        '[attr.aria-label]': 'ariaLabel()',
                        '[attr.role]': 'role()'
                    }
                }]
        }] });

class BreadcrumbRouterService {
    #router = inject(Router);
    #activatedRoute = inject(ActivatedRoute);
    outlet = 'primary';
    #breadcrumbsBehaviorSubject = new BehaviorSubject(new Array());
    breadcrumbs$ = this.#breadcrumbsBehaviorSubject.asObservable();
    constructor() {
        this.#router.events
            .pipe(takeUntilDestroyed(), filter((event) => event instanceof NavigationEnd))
            .subscribe((event) => {
            const breadcrumbs = [];
            let currentRoute = this.#activatedRoute.root;
            let url = '';
            do {
                const childrenRoutes = currentRoute.children;
                currentRoute = null;
                childrenRoutes.forEach((childRoute) => {
                    // console.log('breadcrumb event', event, 'route', route);
                    if (childRoute.outlet === this.outlet) {
                        const routeSnapshot = childRoute.snapshot;
                        url += '/' + routeSnapshot.url.map((segment) => segment.path).join('/');
                        breadcrumbs.push({
                            label: routeSnapshot.data['title'] ?? routeSnapshot.title ?? '',
                            url,
                            queryParams: routeSnapshot.queryParams
                        });
                        currentRoute = childRoute;
                    }
                });
            } while (currentRoute);
            this.#breadcrumbsBehaviorSubject.next(Object.assign([], breadcrumbs));
            return breadcrumbs;
        });
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: BreadcrumbRouterService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: BreadcrumbRouterService, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: BreadcrumbRouterService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root'
                }]
        }], ctorParameters: () => [] });

class BreadcrumbRouterComponent {
    #breadcrumbRouterService = inject(BreadcrumbRouterService);
    /**
     * Optional array of IBreadcrumbItem to override default BreadcrumbRouter behavior. [docs]
     * @return IBreadcrumbItem[]
     */
    items = input(...(ngDevMode ? [undefined, { debugName: "items" }] : []));
    #breadcrumbs = toSignal(this.#breadcrumbRouterService.breadcrumbs$);
    breadcrumbs = computed(() => {
        return this.items() ?? this.#breadcrumbs() ?? [];
    }, ...(ngDevMode ? [{ debugName: "breadcrumbs" }] : []));
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: BreadcrumbRouterComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "20.3.2", type: BreadcrumbRouterComponent, isStandalone: true, selector: "c-breadcrumb-router, [cBreadcrumbRouter]", inputs: { items: { classPropertyName: "items", publicName: "items", isSignal: true, isRequired: false, transformFunction: null } }, ngImport: i0, template: "<c-breadcrumb class=\"m-0\">\n  @for (breadcrumb of breadcrumbs(); track breadcrumb; let last = $last) {\n    @if (breadcrumb?.label && (breadcrumb?.url?.slice(-1) === '/' || last)) {\n      <c-breadcrumb-item\n        [active]=\"last\"\n        [url]=\"breadcrumb?.url\"\n        [attribs]=\"breadcrumb?.attributes\"\n        [linkProps]=\"breadcrumb?.linkProps\"\n      >\n        {{ breadcrumb?.label }}\n      </c-breadcrumb-item>\n    }\n  }\n</c-breadcrumb>\n", dependencies: [{ kind: "component", type: BreadcrumbComponent, selector: "c-breadcrumb", inputs: ["ariaLabel", "role"] }, { kind: "component", type: BreadcrumbItemComponent, selector: "c-breadcrumb-item", inputs: ["active", "url", "attribs", "attributes", "linkProps"], exportAs: ["breadcrumbItem"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: BreadcrumbRouterComponent, decorators: [{
            type: Component,
            args: [{ selector: 'c-breadcrumb-router, [cBreadcrumbRouter]', imports: [BreadcrumbComponent, BreadcrumbItemComponent], template: "<c-breadcrumb class=\"m-0\">\n  @for (breadcrumb of breadcrumbs(); track breadcrumb; let last = $last) {\n    @if (breadcrumb?.label && (breadcrumb?.url?.slice(-1) === '/' || last)) {\n      <c-breadcrumb-item\n        [active]=\"last\"\n        [url]=\"breadcrumb?.url\"\n        [attribs]=\"breadcrumb?.attributes\"\n        [linkProps]=\"breadcrumb?.linkProps\"\n      >\n        {{ breadcrumb?.label }}\n      </c-breadcrumb-item>\n    }\n  }\n</c-breadcrumb>\n" }]
        }] });

class BreadcrumbModule {
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: BreadcrumbModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
    static ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "20.3.2", ngImport: i0, type: BreadcrumbModule, imports: [BreadcrumbComponent,
            BreadcrumbItemComponent,
            BreadcrumbRouterComponent], exports: [BreadcrumbComponent,
            BreadcrumbItemComponent,
            BreadcrumbRouterComponent] });
    static ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: BreadcrumbModule, providers: [BreadcrumbRouterService], imports: [BreadcrumbItemComponent,
            BreadcrumbRouterComponent] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: BreadcrumbModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        BreadcrumbComponent,
                        BreadcrumbItemComponent,
                        BreadcrumbRouterComponent
                    ],
                    exports: [
                        BreadcrumbComponent,
                        BreadcrumbItemComponent,
                        BreadcrumbRouterComponent
                    ],
                    providers: [BreadcrumbRouterService]
                }]
        }] });

class ButtonGroupComponent {
    /**
     * Size the component small or large.
     * @type { 'sm' | 'lg' }
     */
    size = input(...(ngDevMode ? [undefined, { debugName: "size" }] : []));
    /**
     * Create a set of buttons that appear vertically stacked rather than horizontally. Split button dropdowns are not supported here.
     * @type boolean
     */
    vertical = input(false, ...(ngDevMode ? [{ debugName: "vertical", transform: booleanAttribute }] : [{ transform: booleanAttribute }]));
    /**
     * Default role attr for ButtonGroup. [docs]
     * @type InputSignal<string>
     * @default 'group'
     */
    role = input('group', ...(ngDevMode ? [{ debugName: "role" }] : []));
    hostClasses = computed(() => {
        return {
            'btn-group': !this.vertical(),
            'btn-group-vertical': this.vertical(),
            [`btn-group-${this.size()}`]: !!this.size()
        };
    }, ...(ngDevMode ? [{ debugName: "hostClasses" }] : []));
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: ButtonGroupComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.1.0", version: "20.3.2", type: ButtonGroupComponent, isStandalone: true, selector: "c-button-group", inputs: { size: { classPropertyName: "size", publicName: "size", isSignal: true, isRequired: false, transformFunction: null }, vertical: { classPropertyName: "vertical", publicName: "vertical", isSignal: true, isRequired: false, transformFunction: null }, role: { classPropertyName: "role", publicName: "role", isSignal: true, isRequired: false, transformFunction: null } }, host: { properties: { "attr.role": "role()", "class": "hostClasses()" } }, ngImport: i0, template: '<ng-content />', isInline: true });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: ButtonGroupComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'c-button-group',
                    template: '<ng-content />',
                    host: { '[attr.role]': 'role()', '[class]': 'hostClasses()' }
                }]
        }] });

class ButtonToolbarComponent {
    /**
     * Default role attr for ButtonToolbar. [docs]
     * @type InputSignal<string>
     * @default 'toolbar'
     */
    role = input('toolbar', ...(ngDevMode ? [{ debugName: "role" }] : []));
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: ButtonToolbarComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.1.0", version: "20.3.2", type: ButtonToolbarComponent, isStandalone: true, selector: "c-button-toolbar", inputs: { role: { classPropertyName: "role", publicName: "role", isSignal: true, isRequired: false, transformFunction: null } }, host: { properties: { "attr.role": "role()" }, classAttribute: "btn-toolbar" }, ngImport: i0, template: '<ng-content />', isInline: true });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: ButtonToolbarComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'c-button-toolbar',
                    template: '<ng-content />',
                    host: { class: 'btn-toolbar', '[attr.role]': 'role()' }
                }]
        }] });

class ButtonGroupModule {
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: ButtonGroupModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
    static ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "20.3.2", ngImport: i0, type: ButtonGroupModule, imports: [ButtonGroupComponent, ButtonToolbarComponent], exports: [ButtonGroupComponent, ButtonToolbarComponent] });
    static ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: ButtonGroupModule });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: ButtonGroupModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [ButtonGroupComponent, ButtonToolbarComponent],
                    exports: [ButtonGroupComponent, ButtonToolbarComponent]
                }]
        }] });

class CalloutComponent {
    /**
     * Sets the color context of the component to one of CoreUI’s themed colors.
     * @type Colors
     */
    color = input(...(ngDevMode ? [undefined, { debugName: "color" }] : []));
    hostClasses = computed(() => {
        const color = this.color();
        return {
            callout: true,
            [`callout-${color}`]: !!color
        };
    }, ...(ngDevMode ? [{ debugName: "hostClasses" }] : []));
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: CalloutComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.1.0", version: "20.3.2", type: CalloutComponent, isStandalone: true, selector: "c-callout, [cCallout]", inputs: { color: { classPropertyName: "color", publicName: "color", isSignal: true, isRequired: false, transformFunction: null } }, host: { properties: { "class": "hostClasses()" }, classAttribute: "callout" }, ngImport: i0, template: '<ng-content />', isInline: true, styles: [":host{display:block}\n"] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: CalloutComponent, decorators: [{
            type: Component,
            args: [{ selector: 'c-callout, [cCallout]', template: '<ng-content />', host: { class: 'callout', '[class]': 'hostClasses()' }, styles: [":host{display:block}\n"] }]
        }] });

class CalloutModule {
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: CalloutModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
    static ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "20.3.2", ngImport: i0, type: CalloutModule, imports: [CalloutComponent], exports: [CalloutComponent] });
    static ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: CalloutModule });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: CalloutModule, decorators: [{
            type: NgModule,
            args: [{
                    exports: [CalloutComponent],
                    imports: [CalloutComponent]
                }]
        }] });

class CardComponent {
    /**
     * Sets the color context of the component to one of CoreUI’s themed colors.
     * @type Colors
     */
    color = input(...(ngDevMode ? [undefined, { debugName: "color" }] : []));
    /**
     * Sets the text color context of the component to one of CoreUI’s themed colors.
     * via TextColorDirective
     * @type TextColors
     */
    textColor = input(...(ngDevMode ? [undefined, { debugName: "textColor" }] : []));
    /**
     * Sets the component's color scheme to one of CoreUI themed colors, ensuring the text color contrast adheres to the WCAG 4.5:1 contrast ratio standard for accessibility.
     * via TextBgColorDirective
     * @type Colors
     * @since 5.0.0
     */
    textBgColor = input(...(ngDevMode ? [undefined, { debugName: "textBgColor" }] : []));
    hostClasses = computed(() => {
        const color = this.color();
        return {
            card: true,
            [`bg-${color}`]: !!color
        };
    }, ...(ngDevMode ? [{ debugName: "hostClasses" }] : []));
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: CardComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.1.0", version: "20.3.2", type: CardComponent, isStandalone: true, selector: "c-card, [c-card]", inputs: { color: { classPropertyName: "color", publicName: "color", isSignal: true, isRequired: false, transformFunction: null }, textColor: { classPropertyName: "textColor", publicName: "textColor", isSignal: true, isRequired: false, transformFunction: null }, textBgColor: { classPropertyName: "textBgColor", publicName: "textBgColor", isSignal: true, isRequired: false, transformFunction: null } }, host: { properties: { "class": "hostClasses()" }, classAttribute: "card" }, hostDirectives: [{ directive: TextColorDirective, inputs: ["cTextColor", "textColor"] }, { directive: TextBgColorDirective, inputs: ["cTextBgColor", "textBgColor"] }], ngImport: i0, template: '<ng-content />', isInline: true });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: CardComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'c-card, [c-card]',
                    template: '<ng-content />',
                    hostDirectives: [
                        { directive: TextColorDirective, inputs: ['cTextColor: textColor'] },
                        { directive: TextBgColorDirective, inputs: ['cTextBgColor: textBgColor'] }
                    ],
                    host: { class: 'card', '[class]': 'hostClasses()' }
                }]
        }] });

class CardBodyComponent {
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: CardBodyComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "20.3.2", type: CardBodyComponent, isStandalone: true, selector: "c-card-body, [c-card-body]", host: { classAttribute: "card-body" }, ngImport: i0, template: '<ng-content />', isInline: true });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: CardBodyComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'c-card-body, [c-card-body]',
                    template: '<ng-content />',
                    host: { class: 'card-body' }
                }]
        }] });

class CardFooterComponent {
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: CardFooterComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "20.3.2", type: CardFooterComponent, isStandalone: true, selector: "c-card-footer, [c-card-footer]", host: { classAttribute: "card-footer" }, ngImport: i0, template: '<ng-content />', isInline: true });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: CardFooterComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'c-card-footer, [c-card-footer]',
                    template: '<ng-content />',
                    host: { class: 'card-footer' }
                }]
        }] });

class CardGroupComponent {
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: CardGroupComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "20.3.2", type: CardGroupComponent, isStandalone: true, selector: "c-card-group, [c-card-group]", host: { classAttribute: "card-group" }, ngImport: i0, template: '<ng-content />', isInline: true });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: CardGroupComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'c-card-group, [c-card-group]',
                    template: '<ng-content />',
                    host: { class: 'card-group' }
                }]
        }] });

class CardHeaderComponent {
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: CardHeaderComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "20.3.2", type: CardHeaderComponent, isStandalone: true, selector: "c-card-header, [c-card-header]", host: { classAttribute: "card-header" }, ngImport: i0, template: '<ng-content />', isInline: true });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: CardHeaderComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'c-card-header, [c-card-header]',
                    template: '<ng-content />',
                    host: { class: 'card-header' }
                }]
        }] });

class CardHeaderActionsComponent {
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: CardHeaderActionsComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "20.3.2", type: CardHeaderActionsComponent, isStandalone: true, selector: "c-card-header-actions, [c-card-header-actions]", host: { classAttribute: "card-header-actions" }, ngImport: i0, template: '<ng-content />', isInline: true });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: CardHeaderActionsComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'c-card-header-actions, [c-card-header-actions]',
                    template: '<ng-content />',
                    host: { class: 'card-header-actions' }
                }]
        }] });

class CardImgDirective {
    /**
     * Optionally orientate the image to the top, bottom, or make it overlaid across the card.
     * @type {'top | 'bottom'}
     */
    orientation = input(undefined, ...(ngDevMode ? [{ debugName: "orientation", alias: 'cCardImg' }] : [{ alias: 'cCardImg' }]));
    hostClasses = computed(() => {
        const orientation = this.orientation();
        const suffix = !!orientation ? `-${orientation}` : '';
        const horizontal = ['start', 'end'].includes(orientation ?? '-') ? orientation : undefined;
        return {
            [`card-img${suffix}`]: !horizontal,
            'img-fluid': !!horizontal,
            [`rounded-${horizontal}`]: !!horizontal
        };
    }, ...(ngDevMode ? [{ debugName: "hostClasses" }] : []));
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: CardImgDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.1.0", version: "20.3.2", type: CardImgDirective, isStandalone: true, selector: "[cCardImg]", inputs: { orientation: { classPropertyName: "orientation", publicName: "cCardImg", isSignal: true, isRequired: false, transformFunction: null } }, host: { properties: { "class": "hostClasses()" } }, ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: CardImgDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[cCardImg]',
                    host: { '[class]': 'hostClasses()' }
                }]
        }] });

class CardImgOverlayComponent {
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: CardImgOverlayComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "20.3.2", type: CardImgOverlayComponent, isStandalone: true, selector: "c-card-img-overlay", host: { classAttribute: "card-img-overlay" }, ngImport: i0, template: '<ng-content />', isInline: true, styles: [":host{display:block}\n"] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: CardImgOverlayComponent, decorators: [{
            type: Component,
            args: [{ selector: 'c-card-img-overlay', template: '<ng-content />', host: { class: 'card-img-overlay' }, styles: [":host{display:block}\n"] }]
        }] });

class CardLinkDirective {
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: CardLinkDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "20.3.2", type: CardLinkDirective, isStandalone: true, selector: "[cCardLink]", host: { classAttribute: "card-link" }, ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: CardLinkDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[cCardLink]',
                    host: { class: 'card-link' }
                }]
        }] });

class CardSubtitleDirective {
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: CardSubtitleDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "20.3.2", type: CardSubtitleDirective, isStandalone: true, selector: "[cCardSubtitle]", host: { classAttribute: "card-subtitle" }, ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: CardSubtitleDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[cCardSubtitle]',
                    host: { class: 'card-subtitle' }
                }]
        }] });

class CardTextDirective {
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: CardTextDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "20.3.2", type: CardTextDirective, isStandalone: true, selector: "[cCardText]", host: { classAttribute: "card-text" }, ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: CardTextDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[cCardText]',
                    host: { class: 'card-text' }
                }]
        }] });

class CardTitleDirective {
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: CardTitleDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "20.3.2", type: CardTitleDirective, isStandalone: true, selector: "[cCardTitle]", host: { classAttribute: "card-title" }, ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: CardTitleDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[cCardTitle]',
                    host: { class: 'card-title' }
                }]
        }] });

class CardModule {
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: CardModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
    static ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "20.3.2", ngImport: i0, type: CardModule, imports: [CardComponent,
            CardBodyComponent,
            CardFooterComponent,
            CardGroupComponent,
            CardHeaderComponent,
            CardHeaderActionsComponent,
            CardImgDirective,
            CardImgOverlayComponent,
            CardLinkDirective,
            CardSubtitleDirective,
            CardTextDirective,
            CardTitleDirective], exports: [CardComponent,
            CardBodyComponent,
            CardFooterComponent,
            CardGroupComponent,
            CardHeaderComponent,
            CardHeaderActionsComponent,
            CardImgDirective,
            CardImgOverlayComponent,
            CardLinkDirective,
            CardSubtitleDirective,
            CardTextDirective,
            CardTitleDirective] });
    static ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: CardModule });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: CardModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        CardComponent,
                        CardBodyComponent,
                        CardFooterComponent,
                        CardGroupComponent,
                        CardHeaderComponent,
                        CardHeaderActionsComponent,
                        CardImgDirective,
                        CardImgOverlayComponent,
                        CardLinkDirective,
                        CardSubtitleDirective,
                        CardTextDirective,
                        CardTitleDirective
                    ],
                    exports: [
                        CardComponent,
                        CardBodyComponent,
                        CardFooterComponent,
                        CardGroupComponent,
                        CardHeaderComponent,
                        CardHeaderActionsComponent,
                        CardImgDirective,
                        CardImgOverlayComponent,
                        CardLinkDirective,
                        CardSubtitleDirective,
                        CardTextDirective,
                        CardTitleDirective
                    ]
                }]
        }] });

class IntersectionService {
    platformId = inject(PLATFORM_ID);
    #intersecting = new BehaviorSubject({ isIntersecting: false });
    intersecting$ = this.#intersecting.asObservable();
    defaultObserverOptions = {
        root: null,
        rootMargin: '0px',
        threshold: 0.2
    };
    hostElementRefs = new Map();
    createIntersectionObserver(hostElement, observerOptions = this.defaultObserverOptions) {
        if (isPlatformServer(this.platformId)) {
            this.#intersecting.next({ isIntersecting: true, hostElement });
            return;
        }
        const options = { ...this.defaultObserverOptions, ...observerOptions };
        const handleIntersect = (entries, observer) => {
            entries.forEach((entry) => {
                this.#intersecting.next({ isIntersecting: entry.isIntersecting, hostElement });
            });
        };
        this.hostElementRefs.set(hostElement, new IntersectionObserver(handleIntersect, options));
        this.hostElementRefs.get(hostElement)?.observe(hostElement.nativeElement);
    }
    unobserve(elementRef) {
        this.hostElementRefs.get(elementRef)?.unobserve(elementRef.nativeElement);
        this.hostElementRefs.set(elementRef, null);
        this.hostElementRefs.delete(elementRef);
    }
    ngOnDestroy() {
        this.hostElementRefs.forEach((observer, elementRef) => {
            observer?.unobserve(elementRef.nativeElement);
        });
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: IntersectionService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: IntersectionService, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: IntersectionService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root'
                }]
        }] });

class ListenersService {
    renderer = inject(Renderer2);
    listeners = new Map();
    setListeners({ hostElement, trigger, callbackOn, callbackOff, callbackToggle, }) {
        const host = hostElement.nativeElement;
        const triggers = Array.isArray(trigger) ? trigger : trigger?.split(' ') ?? [];
        if (triggers?.includes('click')) {
            typeof callbackToggle === 'function' &&
                this.listeners.set('click', this.renderer.listen(host, 'click', callbackToggle));
        }
        if (triggers?.includes('focus')) {
            typeof callbackOn === 'function' &&
                this.listeners.set('focus', this.renderer.listen(host, 'focus', callbackOn));
        }
        if (triggers?.includes('focusin')) {
            typeof callbackOff === 'function' &&
                this.listeners.set('focusout', this.renderer.listen(host, 'focusout', callbackOff));
            typeof callbackOn === 'function' &&
                this.listeners.set('focusin', this.renderer.listen(host, 'focusin', callbackOn));
        }
        if (triggers?.includes('click') || triggers?.includes('focus')) {
            typeof callbackOff === 'function' &&
                this.listeners.set('blur', this.renderer.listen(host, 'blur', callbackOff));
        }
        if (triggers?.includes('hover')) {
            typeof callbackOn === 'function' &&
                this.listeners.set('mouseenter', this.renderer.listen(host, 'mouseenter', callbackOn));
            typeof callbackOff === 'function' &&
                this.listeners.set('mouseleave', this.renderer.listen(host, 'mouseleave', callbackOff));
        }
    }
    clearListeners() {
        this.listeners.forEach((unListen, key) => {
            unListen();
        });
        this.listeners.forEach((unListen, key) => {
            // @ts-ignore
            this.listeners.set(key, null);
        });
        this.listeners.clear();
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: ListenersService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: ListenersService });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: ListenersService, decorators: [{
            type: Injectable
        }] });

class ClassToggleService {
    #document = inject(DOCUMENT);
    #rendererFactory = inject(RendererFactory2);
    #renderer;
    constructor() {
        this.#renderer = this.#rendererFactory.createRenderer(null, null);
    }
    toggle(selector, className) {
        const element = this.#document.querySelector(selector);
        if (element) {
            element.classList.contains(className)
                ? this.#renderer.removeClass(element, className)
                : this.#renderer.addClass(element, className);
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: ClassToggleService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: ClassToggleService, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: ClassToggleService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root'
                }]
        }], ctorParameters: () => [] });

class InMemoryStorageService {
    #storage = new Map();
    setItem(key, data) {
        this.#storage.set(key, JSON.stringify(data));
    }
    getItem(key) {
        return this.#storage.has(key) ? JSON.parse(this.#storage.get(key) ?? 'null') : undefined;
    }
    removeItem(key) {
        this.#storage.delete(key);
    }
    clear() {
        this.#storage.clear();
    }
    get length() {
        return this.#storage.size;
    }
    key(index) {
        return Array.from(this.#storage.keys())[index];
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: InMemoryStorageService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: InMemoryStorageService, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: InMemoryStorageService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root'
                }]
        }] });

class LocalStorageService {
    platformId = inject(PLATFORM_ID);
    document = inject(DOCUMENT);
    constructor() {
        this.#localStorage =
            isPlatformBrowser(this.platformId) && this.document.defaultView
                ? this.document.defaultView?.localStorage
                : new InMemoryStorageService();
    }
    #localStorage;
    #data$ = new BehaviorSubject(null);
    data$ = this.#data$.asObservable();
    setItem(key, data) {
        this.#localStorage.setItem(key, JSON.stringify(data));
        this.#data$.next({ key, data });
    }
    getItem(key) {
        const data = JSON.parse(this.#localStorage.getItem(key) || 'null');
        this.#data$.next({ key, data });
        return data;
    }
    removeItem(key) {
        this.#localStorage.removeItem(key);
        this.#data$.next({ key, data: null });
    }
    clear() {
        this.#localStorage.clear();
        this.#data$.next(null);
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: LocalStorageService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: LocalStorageService, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: LocalStorageService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root'
                }]
        }], ctorParameters: () => [] });

class ColorModeService {
    #destroyRef = inject(DestroyRef);
    #document = inject(DOCUMENT);
    #localStorage = inject(LocalStorageService);
    eventName = signal('ColorSchemeChange', ...(ngDevMode ? [{ debugName: "eventName" }] : []));
    localStorageItemName = signal(undefined, ...(ngDevMode ? [{ debugName: "localStorageItemName" }] : []));
    localStorageItemName$ = toObservable(this.localStorageItemName);
    colorMode = signal(undefined, ...(ngDevMode ? [{ debugName: "colorMode" }] : []));
    #colorModeEffect = effect(() => {
        const colorMode = this.colorMode();
        if (colorMode) {
            const localStorageItemName = this.localStorageItemName();
            localStorageItemName && this.setStoredTheme(localStorageItemName, colorMode);
            this.#setTheme(colorMode);
        }
    }, ...(ngDevMode ? [{ debugName: "#colorModeEffect" }] : []));
    constructor() {
        afterNextRender({
            read: () => {
                this.localStorageItemName$
                    .pipe(tap((params) => {
                    this.colorMode.set(this.getDefaultScheme(params));
                }), takeUntilDestroyed(this.#destroyRef))
                    .subscribe();
            }
        });
    }
    getStoredTheme(localStorageItemName) {
        return this.#localStorage.getItem(localStorageItemName);
    }
    setStoredTheme(localStorageItemName, colorMode) {
        return this.#localStorage.setItem(localStorageItemName, colorMode);
    }
    removeStoredTheme(localStorageItemName) {
        this.#localStorage.removeItem(localStorageItemName);
    }
    getDefaultScheme(localStorageItemName) {
        if (this.#document.defaultView === undefined) {
            return this.getDatasetTheme();
        }
        const storedTheme = localStorageItemName && this.getStoredTheme(localStorageItemName);
        return storedTheme ?? this.getDatasetTheme();
    }
    getPrefersColorScheme() {
        return this.#document.defaultView?.matchMedia('(prefers-color-scheme: dark)').matches
            ? 'dark'
            : this.#document.defaultView?.matchMedia('(prefers-color-scheme: light)').matches
                ? 'light'
                : undefined;
    }
    getDatasetTheme() {
        return this.#document.documentElement.dataset['coreuiTheme'];
    }
    #setTheme(colorMode) {
        this.#document.documentElement.dataset['coreuiTheme'] =
            colorMode === 'auto' ? this.getPrefersColorScheme() : colorMode;
        const event = new Event(this.eventName());
        this.#document.documentElement.dispatchEvent(event);
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: ColorModeService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: ColorModeService, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: ColorModeService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root'
                }]
        }], ctorParameters: () => [] });

class UIDService {
    #document = inject(DOCUMENT);
    getUID(prefix = 'random-id') {
        let uid = prefix;
        do {
            uid = `${prefix}-${Math.floor(Math.random() * 1000000).toString(10)}`;
        } while (this.#document.getElementById(uid));
        return uid;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: UIDService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: UIDService, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: UIDService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root'
                }]
        }] });

class RtlService {
    #document = inject(DOCUMENT);
    isRTL(element) {
        if (element) {
            return (element.closest('[dir="rtl"]') !== null ||
                this.#document.defaultView?.getComputedStyle(element).direction === 'rtl');
        }
        return [this.#document?.documentElement?.dir, this.#document?.body?.dir].includes('rtl');
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: RtlService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: RtlService, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: RtlService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root'
                }]
        }] });

class CarouselService {
    #carouselIndex = new BehaviorSubject({});
    carouselIndex$ = this.#carouselIndex.asObservable();
    setIndex(index) {
        this.#carouselIndex.next(index);
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: CarouselService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: CarouselService });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: CarouselService, decorators: [{
            type: Injectable
        }] });

class CarouselState {
    #carouselService = inject(CarouselService);
    #state = {
        activeItemIndex: -1,
        animate: true,
        items: [],
        direction: 'next',
        transition: 'slide',
        interval: 0
    };
    get state() {
        return this.#state;
    }
    set state(state) {
        const prevState = { ...this.#state };
        const nextState = { ...this.#state, ...state };
        this.#state = nextState;
        if (prevState.activeItemIndex !== nextState.activeItemIndex) {
            const activeItemIndex = this.state.activeItemIndex || 0;
            const itemInterval = (this.state.items && this.state.items[activeItemIndex]?.interval()) || -1;
            this.#carouselService.setIndex({
                active: nextState.activeItemIndex,
                interval: itemInterval,
                lastItemIndex: (nextState.items?.length ?? 0) - 1
            });
        }
    }
    setItems(newItems) {
        if (newItems.length) {
            const itemsArray = newItems;
            itemsArray.forEach((item, i) => {
                item.index = i;
            });
            this.state = {
                items: [...itemsArray]
            };
        }
        else {
            this.reset();
        }
    }
    setNextIndex(nextIndex) {
        this.#carouselService.setIndex(nextIndex);
    }
    direction(direction = 'next') {
        this.state = { direction };
        const { activeItemIndex = -1, items } = this.state;
        const itemsCount = items?.length ?? 0;
        if (itemsCount > 0) {
            return direction === 'next'
                ? activeItemIndex === itemsCount - 1
                    ? 0
                    : activeItemIndex + 1
                : activeItemIndex === 0
                    ? itemsCount - 1
                    : activeItemIndex - 1;
        }
        else {
            return 0;
        }
    }
    reset() {
        this.state = {
            activeItemIndex: -1,
            animate: true,
            items: [],
            direction: 'next',
            transition: 'slide',
            interval: 0
        };
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: CarouselState, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: CarouselState });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: CarouselState, decorators: [{
            type: Injectable
        }] });

class CarouselConfig {
    /* Animate transition of slides */
    activeIndex = 0;
    /* Animate transition of slides */
    animate = true;
    /* Default direction of auto changing of slides */
    direction = 'next';
    /* Default interval of auto changing of slides */
    interval;
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: CarouselConfig, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: CarouselConfig, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: CarouselConfig, decorators: [{
            type: Injectable,
            args: [{ providedIn: 'root' }]
        }] });

class CarouselComponent {
    config = inject(CarouselConfig);
    #hostElement = inject(ElementRef);
    #carouselService = inject(CarouselService);
    #carouselState = inject(CarouselState);
    #intersectionService = inject(IntersectionService);
    #listenersService = inject(ListenersService);
    constructor() {
        this.loadConfig();
    }
    loadConfig() {
        this.activeIndex.update((activeIndex) => this.config?.activeIndex ?? activeIndex);
        this.animate.update((animate) => this.config?.animate ?? animate);
        this.direction.update((direction) => this.config?.direction ?? direction);
        this.interval.update((interval) => this.config?.interval ?? interval);
    }
    /**
     * Index of the active item.
     * @return number
     */
    activeIndexInput = input(0, ...(ngDevMode ? [{ debugName: "activeIndexInput", alias: 'activeIndex', transform: numberAttribute }] : [{ alias: 'activeIndex', transform: numberAttribute }]));
    activeIndex = linkedSignal({
        source: this.activeIndexInput,
        computation: (value) => value
    });
    /**
     * Carousel automatically starts cycle items.
     * @return boolean
     */
    animateInput = input(true, ...(ngDevMode ? [{ debugName: "animateInput", alias: 'animate' }] : [{ alias: 'animate' }]));
    animate = linkedSignal({
        source: this.animateInput,
        computation: (value) => value
    });
    /**
     * Carousel direction. [docs]
     * @return {'next' | 'prev'}
     */
    directionInput = input('next', ...(ngDevMode ? [{ debugName: "directionInput", alias: 'direction' }] : [{ alias: 'direction' }]));
    direction = linkedSignal({
        source: this.directionInput,
        computation: (value) => value
    });
    /**
     * The amount of time to delay between automatically cycling an item. If false, carousel will not automatically cycle.
     * @return number
     * @default 0
     */
    intervalInput = input(-1, ...(ngDevMode ? [{ debugName: "intervalInput", alias: 'interval', transform: numberAttribute }] : [{ alias: 'interval', transform: numberAttribute }]));
    interval = linkedSignal({
        source: this.intervalInput,
        computation: (value) => value
    });
    #intervalEffect = effect(() => {
        const interval = this.interval();
        this.#carouselState.state = { interval: interval };
        interval ? this.setTimer() : this.resetTimer();
    }, ...(ngDevMode ? [{ debugName: "#intervalEffect" }] : []));
    /**
     * Sets which event handlers you’d like provided to your pause prop. You can specify one trigger or an array of them.
     * @return {'hover' | 'focus' | 'click'}
     */
    pause = input('hover', ...(ngDevMode ? [{ debugName: "pause" }] : []));
    /**
     * Support left/right swipe interactions on touchscreen devices.
     * @return boolean
     * @default true
     */
    touch = input(true, ...(ngDevMode ? [{ debugName: "touch" }] : []));
    /**
     * Set type of the transition.
     * @return {'slide' | 'crossfade'}
     * @default 'slide'
     */
    transition = input('slide', ...(ngDevMode ? [{ debugName: "transition" }] : []));
    /**
     * Set whether the carousel should cycle continuously or have hard stops.
     * @return boolean
     * @default true
     */
    wrap = input(true, ...(ngDevMode ? [{ debugName: "wrap" }] : []));
    /**
     * Event emitted on carousel item change. [docs]
     * @return number
     */
    itemChange = output();
    timerId;
    activeItemInterval = 0;
    swipeSubscription;
    #destroyRef = inject(DestroyRef);
    ngOnInit() {
        this.carouselStateSubscribe();
    }
    ngOnDestroy() {
        this.resetTimer();
        this.clearListeners();
        this.swipeSubscribe(false);
    }
    ngAfterContentInit() {
        this.intersectionServiceSubscribe();
        this.#carouselState.state = {
            activeItemIndex: this.activeIndex(),
            animate: this.animate(),
            interval: this.interval(),
            transition: this.transition()
        };
        this.setListeners();
        this.swipeSubscribe();
    }
    setListeners() {
        const config = {
            hostElement: this.#hostElement,
            trigger: this.pause() || [],
            callbackOff: () => {
                this.setTimer();
            },
            callbackOn: () => {
                this.resetTimer();
            }
        };
        this.#listenersService.setListeners(config);
    }
    clearListeners() {
        this.#listenersService.clearListeners();
    }
    set visible(value) {
        this.#visible = value;
    }
    get visible() {
        return this.#visible;
    }
    #visible = true;
    setTimer() {
        const interval = this.activeItemInterval || this.interval();
        const direction = this.direction();
        this.resetTimer();
        if (interval > 0) {
            this.timerId = setTimeout(() => {
                const nextIndex = this.#carouselState.direction(direction);
                this.#carouselState.state = { activeItemIndex: nextIndex };
            }, interval);
        }
    }
    resetTimer() {
        clearTimeout(this.timerId);
        this.timerId = undefined;
    }
    carouselStateSubscribe() {
        this.#carouselService.carouselIndex$.pipe(takeUntilDestroyed(this.#destroyRef)).subscribe((nextItem) => {
            if ('active' in nextItem && typeof nextItem.active === 'number') {
                this.itemChange?.emit(nextItem.active);
            }
            this.activeItemInterval =
                typeof nextItem.interval === 'number' && nextItem.interval > -1 ? nextItem.interval : this.interval();
            const direction = this.direction();
            const isLastItem = (nextItem.active === nextItem.lastItemIndex && direction === 'next') ||
                (nextItem.active === 0 && direction === 'prev');
            !this.wrap() && isLastItem ? this.resetTimer() : this.setTimer();
        });
    }
    intersectionServiceSubscribe() {
        this.#intersectionService.createIntersectionObserver(this.#hostElement);
        this.#intersectionService.intersecting$
            .pipe(filter((next) => next.hostElement === this.#hostElement), finalize(() => {
            this.#intersectionService.unobserve(this.#hostElement);
        }), takeUntilDestroyed(this.#destroyRef))
            .subscribe((next) => {
            this.visible = next.isIntersecting;
            next.isIntersecting ? this.setTimer() : this.resetTimer();
        });
    }
    swipeSubscribe(subscribe = true) {
        if (this.touch() && subscribe) {
            const carouselElement = this.#hostElement.nativeElement;
            const touchStart$ = fromEvent(carouselElement, 'touchstart');
            const touchEnd$ = fromEvent(carouselElement, 'touchend');
            const touchMove$ = fromEvent(carouselElement, 'touchmove');
            this.swipeSubscription = touchStart$
                .pipe(zipWith(touchEnd$.pipe(withLatestFrom(touchMove$))), takeUntilDestroyed(this.#destroyRef))
                .subscribe(([touchstart, [touchend, touchmove]]) => {
                touchstart.stopPropagation();
                touchmove.stopPropagation();
                const distanceX = touchstart.touches[0]?.clientX - touchmove.touches[0]?.clientX || 0;
                if (Math.abs(distanceX) > 0.3 * carouselElement.clientWidth && touchstart.timeStamp <= touchmove.timeStamp) {
                    const nextIndex = this.#carouselState.direction(distanceX > 0 ? 'next' : 'prev');
                    this.#carouselState.state = { activeItemIndex: nextIndex };
                }
            });
        }
        else {
            this.swipeSubscription?.unsubscribe();
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: CarouselComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.1.0", version: "20.3.2", type: CarouselComponent, isStandalone: true, selector: "c-carousel", inputs: { activeIndexInput: { classPropertyName: "activeIndexInput", publicName: "activeIndex", isSignal: true, isRequired: false, transformFunction: null }, animateInput: { classPropertyName: "animateInput", publicName: "animate", isSignal: true, isRequired: false, transformFunction: null }, directionInput: { classPropertyName: "directionInput", publicName: "direction", isSignal: true, isRequired: false, transformFunction: null }, intervalInput: { classPropertyName: "intervalInput", publicName: "interval", isSignal: true, isRequired: false, transformFunction: null }, pause: { classPropertyName: "pause", publicName: "pause", isSignal: true, isRequired: false, transformFunction: null }, touch: { classPropertyName: "touch", publicName: "touch", isSignal: true, isRequired: false, transformFunction: null }, transition: { classPropertyName: "transition", publicName: "transition", isSignal: true, isRequired: false, transformFunction: null }, wrap: { classPropertyName: "wrap", publicName: "wrap", isSignal: true, isRequired: false, transformFunction: null } }, outputs: { itemChange: "itemChange" }, host: { properties: { "class.carousel-fade": "transition() === \"crossfade\" && animate()" }, classAttribute: "carousel slide" }, providers: [CarouselService, CarouselState, ListenersService], exportAs: ["cCarousel"], hostDirectives: [{ directive: ThemeDirective, inputs: ["dark", "dark"] }], ngImport: i0, template: '<ng-content />', isInline: true, styles: [":host{display:block}\n"] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: CarouselComponent, decorators: [{
            type: Component,
            args: [{ selector: 'c-carousel', template: '<ng-content />', providers: [CarouselService, CarouselState, ListenersService], hostDirectives: [{ directive: ThemeDirective, inputs: ['dark'] }], exportAs: 'cCarousel', host: {
                        class: 'carousel slide',
                        '[class.carousel-fade]': 'transition() === "crossfade" && animate()'
                    }, styles: [":host{display:block}\n"] }]
        }], ctorParameters: () => [] });

class CarouselCaptionComponent {
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: CarouselCaptionComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "20.3.2", type: CarouselCaptionComponent, isStandalone: true, selector: "c-carousel-caption", host: { properties: { "class.carousel-caption": "true" } }, ngImport: i0, template: '<ng-content />', isInline: true, styles: [":host{display:block}\n"] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: CarouselCaptionComponent, decorators: [{
            type: Component,
            args: [{ selector: 'c-carousel-caption', template: '<ng-content />', host: {
                        '[class.carousel-caption]': 'true'
                    }, styles: [":host{display:block}\n"] }]
        }] });

class CarouselControlComponent {
    #carouselState = inject(CarouselState);
    /**
     * Carousel control caption. [docs]
     * @return string
     */
    captionInput = input(undefined, ...(ngDevMode ? [{ debugName: "captionInput", alias: 'caption' }] : [{ alias: 'caption' }]));
    caption = linkedSignal({
        source: this.captionInput,
        computation: (value) => {
            return !!value ? value : this.direction() === 'prev' ? 'Previous' : 'Next';
        }
    });
    /**
     * Carousel control direction.
     * @return {'next' | 'prev'}
     */
    direction = input('next', ...(ngDevMode ? [{ debugName: "direction" }] : []));
    /**
     * Carousel control role.
     * @return string
     */
    role = input('button', ...(ngDevMode ? [{ debugName: "role" }] : []));
    hostClasses = computed(() => {
        return `carousel-control-${this.direction()}`;
    }, ...(ngDevMode ? [{ debugName: "hostClasses" }] : []));
    carouselControlIconClass = computed(() => {
        return `carousel-control-${this.direction()}-icon`;
    }, ...(ngDevMode ? [{ debugName: "carouselControlIconClass" }] : []));
    onKeyUp($event) {
        if ($event.key === 'Enter') {
            this.#play();
        }
        if ($event.key === 'ArrowLeft') {
            this.#play('prev');
        }
        if ($event.key === 'ArrowRight') {
            this.#play('next');
        }
    }
    onClick($event) {
        this.#play();
    }
    #play(direction = this.direction()) {
        const nextIndex = this.#carouselState.direction(direction);
        this.#carouselState.state = { activeItemIndex: nextIndex };
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: CarouselControlComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.1.0", version: "20.3.2", type: CarouselControlComponent, isStandalone: true, selector: "c-carousel-control", inputs: { captionInput: { classPropertyName: "captionInput", publicName: "caption", isSignal: true, isRequired: false, transformFunction: null }, direction: { classPropertyName: "direction", publicName: "direction", isSignal: true, isRequired: false, transformFunction: null }, role: { classPropertyName: "role", publicName: "role", isSignal: true, isRequired: false, transformFunction: null } }, host: { listeners: { "keyup": "onKeyUp($event)", "click": "onClick($event)" }, properties: { "attr.role": "role()", "class": "hostClasses()" } }, exportAs: ["cCarouselControl"], ngImport: i0, template: "<ng-content>\n  <span [attr.aria-hidden]=\"true\" [class]=\"carouselControlIconClass()\"></span>\n  <span class=\"visually-hidden\">{{ caption() }}</span>\n</ng-content>\n" });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: CarouselControlComponent, decorators: [{
            type: Component,
            args: [{ selector: 'c-carousel-control', exportAs: 'cCarouselControl', host: {
                        '[attr.role]': 'role()',
                        '[class]': 'hostClasses()',
                        '(keyup)': 'onKeyUp($event)',
                        '(click)': 'onClick($event)'
                    }, template: "<ng-content>\n  <span [attr.aria-hidden]=\"true\" [class]=\"carouselControlIconClass()\"></span>\n  <span class=\"visually-hidden\">{{ caption() }}</span>\n</ng-content>\n" }]
        }] });

class CarouselIndicatorsComponent {
    #destroyRef = inject(DestroyRef);
    #carouselService = inject(CarouselService);
    #carouselState = inject(CarouselState);
    items = [];
    active = 0;
    contentTemplates = contentChildren(TemplateIdDirective, ...(ngDevMode ? [{ debugName: "contentTemplates", descendants: true }] : [{ descendants: true }]));
    templates = computed(() => {
        return this.contentTemplates().reduce((acc, child) => {
            acc[child.id] = child.templateRef;
            return acc;
        }, {});
    }, ...(ngDevMode ? [{ debugName: "templates" }] : []));
    ngOnInit() {
        this.#carouselService.carouselIndex$.pipe(takeUntilDestroyed(this.#destroyRef)).subscribe((nextIndex) => {
            this.items = this.#carouselState?.state?.items?.map((item) => item.index) ?? [];
            if ('active' in nextIndex) {
                this.active = nextIndex.active ?? 0;
            }
        });
    }
    onClick(index) {
        if (index !== this.active) {
            const direction = index < this.active ? 'prev' : 'next';
            this.#carouselState.state = { direction, activeItemIndex: index };
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: CarouselIndicatorsComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "20.3.2", type: CarouselIndicatorsComponent, isStandalone: true, selector: "c-carousel-indicators", host: { classAttribute: "carousel-indicators" }, queries: [{ propertyName: "contentTemplates", predicate: TemplateIdDirective, descendants: true, isSignal: true }], exportAs: ["cCarouselIndicators"], ngImport: i0, template: "@let tmpl = templates();\n<ng-container *ngTemplateOutlet=\"tmpl['carouselIndicatorsTemplate'] || defaultCarouselIndicatorsTemplate; context: {$implicit: items, active: active}\" />\n\n<ng-template #defaultCarouselIndicatorsTemplate>\n  @for (item of items; track item; let i = $index) {\n    <button\n      [attr.data-coreui-target]=\"i\"\n      type=\"button\"\n      (click)=\"onClick(i)\"\n      [class]=\"{ active: active === i }\"\n      [attr.aria-current]=\"active === i\">\n    </button>\n  }\n</ng-template>\n", dependencies: [{ kind: "directive", type: NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: CarouselIndicatorsComponent, decorators: [{
            type: Component,
            args: [{ selector: 'c-carousel-indicators', exportAs: 'cCarouselIndicators', imports: [NgTemplateOutlet], host: { class: 'carousel-indicators' }, template: "@let tmpl = templates();\n<ng-container *ngTemplateOutlet=\"tmpl['carouselIndicatorsTemplate'] || defaultCarouselIndicatorsTemplate; context: {$implicit: items, active: active}\" />\n\n<ng-template #defaultCarouselIndicatorsTemplate>\n  @for (item of items; track item; let i = $index) {\n    <button\n      [attr.data-coreui-target]=\"i\"\n      type=\"button\"\n      (click)=\"onClick(i)\"\n      [class]=\"{ active: active === i }\"\n      [attr.aria-current]=\"active === i\">\n    </button>\n  }\n</ng-template>\n" }]
        }] });

class CarouselItemComponent {
    #destroyRef = inject(DestroyRef);
    #carouselService = inject(CarouselService);
    index;
    /**
     * @ignore
     */
    activeInput = input(false, ...(ngDevMode ? [{ debugName: "activeInput", transform: booleanAttribute, alias: 'active' }] : [{ transform: booleanAttribute, alias: 'active' }]));
    active = linkedSignal({
        source: this.activeInput,
        computation: (value) => {
            return value;
        }
    });
    /**
     * Time delay before cycling to next item. If -1, uses carousel interval value.
     * @return number
     * @default -1
     */
    interval = input(-1, ...(ngDevMode ? [{ debugName: "interval" }] : []));
    /**
     * Carousel item role.
     * @return string
     * @default 'group'
     */
    role = input('group', ...(ngDevMode ? [{ debugName: "role" }] : []));
    constructor() {
        this.#carouselService.carouselIndex$.pipe(takeUntilDestroyed(this.#destroyRef)).subscribe((nextIndex) => {
            if ('active' in nextIndex) {
                this.active.set(nextIndex.active === this.index);
            }
        });
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: CarouselItemComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "20.3.2", type: CarouselItemComponent, isStandalone: true, selector: "c-carousel-item", inputs: { activeInput: { classPropertyName: "activeInput", publicName: "active", isSignal: true, isRequired: false, transformFunction: null }, interval: { classPropertyName: "interval", publicName: "interval", isSignal: true, isRequired: false, transformFunction: null }, role: { classPropertyName: "role", publicName: "role", isSignal: true, isRequired: false, transformFunction: null } }, host: { properties: { "class.active": "active()", "attr.role": "role()" }, classAttribute: "carousel-item" }, exportAs: ["cCarouselItem"], ngImport: i0, template: "@if (active()) {\n  <ng-content />\n}\n", styles: [":host{display:block}\n"] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: CarouselItemComponent, decorators: [{
            type: Component,
            args: [{ selector: 'c-carousel-item', exportAs: 'cCarouselItem', host: {
                        class: 'carousel-item',
                        '[class.active]': 'active()',
                        '[attr.role]': 'role()'
                    }, template: "@if (active()) {\n  <ng-content />\n}\n", styles: [":host{display:block}\n"] }]
        }], ctorParameters: () => [] });

function toSlideLeft(fromState, toState) {
    return toState.left === true && toState.type === 'slide';
}
function toSlideRight(fromState, toState) {
    return toState.left === false && toState.type === 'slide';
}
function toFadeLeft(fromState, toState) {
    return toState.left === true && toState.type !== 'slide';
}
function toFadeRight(fromState, toState) {
    return toState.left === false && toState.type !== 'slide';
}
const slideAnimationLeft = animation(group([
    query(':leave', [
        animate('0.6s ease-in-out', style({
            transform: 'translateX(-100%)'
        }))
    ], { optional: true }),
    query(':enter', [
        style({
            transform: 'translateX(100%)'
        }),
        animate('0.6s ease-in-out', style('*'))
    ], { optional: true })
]));
const slideAnimationRight = animation(group([
    query(':enter', [
        style({
            transform: 'translateX(-100%)'
        }),
        animate('0.6s ease-in-out', style('*'))
    ], { optional: true }),
    query(':leave', [
        animate('0.6s ease-in-out', style({
            transform: 'translateX(100%)'
        }))
    ], { optional: true })
]));
const fadeAnimationLeft = animation(group([
    query(':leave', [
        animate('0.9s ease-in-out', style({
            zIndex: 0,
            opacity: 0
        }))
    ], { optional: true }),
    query(':enter', [
        style({
            zIndex: 1,
            opacity: 1
        }),
        animate('0.6s ease-in-out', style('*'))
    ], { optional: true })
]));
const fadeAnimationRight = animation(group([
    query(':enter', [
        style({
            zIndex: 1,
            opacity: 1
        }),
        animate('0.6s ease-in-out', style('*'))
    ], { optional: true }),
    query(':leave', [
        animate('0.9s ease-in-out', style({
            zIndex: 0,
            opacity: 0
        }))
    ], { optional: true })
]));
const carouselPlay = trigger('carouselPlay', [
    state('*', style({ transform: 'translateX(0)', display: 'block', opacity: 1 })),
    transition(toFadeLeft, useAnimation(fadeAnimationLeft)),
    transition(toFadeRight, useAnimation(fadeAnimationRight)),
    transition(toSlideLeft, useAnimation(slideAnimationLeft)),
    transition(toSlideRight, useAnimation(slideAnimationRight))
]);

class CarouselInnerComponent {
    #carouselState = inject(CarouselState);
    activeIndex = signal(undefined, ...(ngDevMode ? [{ debugName: "activeIndex" }] : []));
    animate = signal(true, ...(ngDevMode ? [{ debugName: "animate" }] : []));
    interval = signal(0, ...(ngDevMode ? [{ debugName: "interval" }] : []));
    slide = signal({ left: true }, ...(ngDevMode ? [{ debugName: "slide" }] : []));
    transition = signal('crossfade', ...(ngDevMode ? [{ debugName: "transition" }] : []));
    slideType = computed(() => {
        return { left: this.slide().left, type: this.transition() };
    }, ...(ngDevMode ? [{ debugName: "slideType" }] : []));
    ariaLive = computed(() => {
        return this.interval() ? 'off' : 'polite';
    }, ...(ngDevMode ? [{ debugName: "ariaLive" }] : []));
    contentItems = contentChildren(CarouselItemComponent, ...(ngDevMode ? [{ debugName: "contentItems" }] : []));
    #prevContentItems = signal([], ...(ngDevMode ? [{ debugName: "#prevContentItems" }] : []));
    ngAfterContentInit() {
        this.setItems();
    }
    ngAfterContentChecked() {
        this.setItems();
        const state = this.#carouselState?.state;
        const nextIndex = state?.activeItemIndex;
        const nextDirection = state?.direction;
        if (this.activeIndex() !== nextIndex) {
            this.animate.set(state?.animate ?? false);
            this.activeIndex.set(state?.activeItemIndex);
            this.interval.set(state?.interval ?? 0);
            this.slide.set({ left: nextDirection === 'next' });
            this.transition.set(state?.transition ?? 'slide');
        }
    }
    setItems() {
        const contentItems = this.contentItems();
        if (this.#prevContentItems() !== contentItems) {
            this.#prevContentItems.set([...contentItems]);
            this.#carouselState.setItems(contentItems);
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: CarouselInnerComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.2.0", version: "20.3.2", type: CarouselInnerComponent, isStandalone: true, selector: "c-carousel-inner", host: { properties: { "@carouselPlay": "slideType()", "@.disabled": "!animate()", "attr.aria-live": "ariaLive()" }, classAttribute: "carousel-inner" }, queries: [{ propertyName: "contentItems", predicate: CarouselItemComponent, isSignal: true }], ngImport: i0, template: '<ng-content />', isInline: true, styles: [":host{display:block}\n"], animations: [carouselPlay] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: CarouselInnerComponent, decorators: [{
            type: Component,
            args: [{ selector: 'c-carousel-inner', animations: [carouselPlay], template: '<ng-content />', host: {
                        class: 'carousel-inner',
                        '[@carouselPlay]': 'slideType()',
                        '[@.disabled]': '!animate()',
                        '[attr.aria-live]': 'ariaLive()'
                    }, styles: [":host{display:block}\n"] }]
        }] });

class CarouselModule {
    static forRoot() {
        return { ngModule: CarouselModule, providers: [] };
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: CarouselModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
    static ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "20.3.2", ngImport: i0, type: CarouselModule, imports: [CarouselComponent,
            CarouselCaptionComponent,
            CarouselControlComponent,
            CarouselIndicatorsComponent,
            CarouselInnerComponent,
            CarouselItemComponent], exports: [CarouselComponent,
            CarouselCaptionComponent,
            CarouselControlComponent,
            CarouselIndicatorsComponent,
            CarouselInnerComponent,
            CarouselItemComponent] });
    static ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: CarouselModule, providers: [CarouselService, CarouselState, CarouselConfig] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: CarouselModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        CarouselComponent,
                        CarouselCaptionComponent,
                        CarouselControlComponent,
                        CarouselIndicatorsComponent,
                        CarouselInnerComponent,
                        CarouselItemComponent
                    ],
                    providers: [CarouselService, CarouselState, CarouselConfig],
                    exports: [
                        CarouselComponent,
                        CarouselCaptionComponent,
                        CarouselControlComponent,
                        CarouselIndicatorsComponent,
                        CarouselInnerComponent,
                        CarouselItemComponent
                    ]
                }]
        }] });

class DropdownDividerDirective {
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: DropdownDividerDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "20.3.2", type: DropdownDividerDirective, isStandalone: true, selector: "[cDropdownDivider]", host: { classAttribute: "dropdown-divider" }, ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: DropdownDividerDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[cDropdownDivider]',
                    host: { class: 'dropdown-divider' }
                }]
        }] });

class DropdownHeaderDirective {
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: DropdownHeaderDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "20.3.2", type: DropdownHeaderDirective, isStandalone: true, selector: "[cDropdownHeader]", host: { classAttribute: "dropdown-header" }, ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: DropdownHeaderDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[cDropdownHeader]',
                    host: { class: 'dropdown-header' }
                }]
        }] });

class DropdownService {
    dropdownState = new BehaviorSubject({});
    dropdownState$ = this.dropdownState.asObservable();
    toggle(state) {
        this.dropdownState.next(state);
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: DropdownService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: DropdownService });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: DropdownService, decorators: [{
            type: Injectable
        }] });

class DropdownMenuDirective {
    #destroyRef = inject(DestroyRef);
    elementRef = inject(ElementRef);
    #dropdownService = inject(DropdownService);
    #focusKeyManager;
    /**
     * Set alignment of dropdown menu.
     * @return 'start' | 'end'
     */
    alignment = input(...(ngDevMode ? [undefined, { debugName: "alignment" }] : []));
    /**
     * Toggle the visibility of dropdown menu component.
     * @return boolean
     */
    visibleInput = input(false, ...(ngDevMode ? [{ debugName: "visibleInput", transform: booleanAttribute, alias: 'visible' }] : [{ transform: booleanAttribute, alias: 'visible' }]));
    visible = linkedSignal({
        source: this.visibleInput,
        computation: (value) => value
    });
    hostClasses = computed(() => {
        const alignment = this.alignment();
        const visible = this.visible();
        return {
            'dropdown-menu': true,
            [`dropdown-menu-${alignment}`]: !!alignment,
            show: visible
        };
    }, ...(ngDevMode ? [{ debugName: "hostClasses" }] : []));
    hostStyles = computed(() => {
        // workaround for popper position calculate (see also: dropdown.component)
        const visible = this.visible();
        return {
            visibility: visible ? null : '',
            display: visible ? null : ''
        };
    }, ...(ngDevMode ? [{ debugName: "hostStyles" }] : []));
    onKeyDown($event) {
        if (!this.visible()) {
            return;
        }
        if (['Space', 'ArrowDown'].includes($event.code)) {
            $event.preventDefault();
        }
        this.#focusKeyManager.onKeydown($event);
    }
    onKeyUp($event) {
        if (!this.visible()) {
            return;
        }
        if (['Tab'].includes($event.key)) {
            if (this.#focusKeyManager.activeItem) {
                $event.shiftKey ? this.#focusKeyManager.setPreviousItemActive() : this.#focusKeyManager.setNextItemActive();
            }
            else {
                this.#focusKeyManager.setFirstItemActive();
            }
        }
    }
    dropdownItemsContent = contentChildren(forwardRef(() => DropdownItemDirective), ...(ngDevMode ? [{ debugName: "dropdownItemsContent", descendants: true }] : [{ descendants: true }]));
    items$ = toObservable(this.dropdownItemsContent);
    ngAfterContentInit() {
        this.focusKeyManagerInit();
        this.items$
            .pipe(tap((change) => {
            this.focusKeyManagerInit();
        }), takeUntilDestroyed(this.#destroyRef))
            .subscribe();
    }
    ngOnInit() {
        this.#dropdownService.dropdownState$
            .pipe(tap((state) => {
            if ('visible' in state) {
                this.visible.update((visible) => (state.visible === 'toggle' ? !visible : state.visible));
                if (!this.visible()) {
                    this.#focusKeyManager?.setActiveItem(-1);
                }
            }
        }), takeUntilDestroyed(this.#destroyRef))
            .subscribe();
    }
    focusKeyManagerInit() {
        this.#focusKeyManager = new FocusKeyManager(this.dropdownItemsContent())
            .withHomeAndEnd()
            .withPageUpDown()
            .withWrap()
            .skipPredicate((dropdownItem) => dropdownItem.disabled === true);
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: DropdownMenuDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.2.0", version: "20.3.2", type: DropdownMenuDirective, isStandalone: true, selector: "[cDropdownMenu]", inputs: { alignment: { classPropertyName: "alignment", publicName: "alignment", isSignal: true, isRequired: false, transformFunction: null }, visibleInput: { classPropertyName: "visibleInput", publicName: "visible", isSignal: true, isRequired: false, transformFunction: null } }, host: { listeners: { "keydown": "onKeyDown($event)", "keyup": "onKeyUp($event)" }, properties: { "class": "hostClasses()", "style": "hostStyles()" }, classAttribute: "dropdown-menu" }, queries: [{ propertyName: "dropdownItemsContent", predicate: i0.forwardRef(() => DropdownItemDirective), descendants: true, isSignal: true }], exportAs: ["cDropdownMenu"], hostDirectives: [{ directive: ThemeDirective, inputs: ["dark", "dark"] }], ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: DropdownMenuDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[cDropdownMenu]',
                    exportAs: 'cDropdownMenu',
                    hostDirectives: [{ directive: ThemeDirective, inputs: ['dark'] }],
                    host: {
                        class: 'dropdown-menu',
                        '[class]': 'hostClasses()',
                        '[style]': 'hostStyles()',
                        '(keydown)': 'onKeyDown($event)',
                        '(keyup)': 'onKeyUp($event)'
                    }
                }]
        }] });

// lightweight injection token
class DropdownToken {
}
class DropdownToggleDirective {
    // injections
    #destroyRef = inject(DestroyRef);
    elementRef = inject(ElementRef);
    #dropdownService = inject(DropdownService);
    dropdown = inject(DropdownToken, { optional: true });
    /**
     * Reference to dropdown component.
     * @return DropdownComponent | undefined
     * @default undefined
     */
    dropdownComponent = input(...(ngDevMode ? [undefined, { debugName: "dropdownComponent" }] : []));
    /**
     * Disables the toggler.
     * @return boolean
     * @default false
     */
    disabled = input(false, ...(ngDevMode ? [{ debugName: "disabled", transform: booleanAttribute }] : [{ transform: booleanAttribute }]));
    /**
     * Enables pseudo element caret on toggler.
     * @return boolean
     */
    caret = input(true, ...(ngDevMode ? [{ debugName: "caret" }] : []));
    /**
     * Create split button dropdowns with virtually the same markup as single button dropdowns,
     * but with the addition of `.dropdown-toggle-split` class for proper spacing around the dropdown caret.
     * @return boolean
     * @default false
     */
    split = input(false, ...(ngDevMode ? [{ debugName: "split", transform: booleanAttribute }] : [{ transform: booleanAttribute }]));
    hostClasses = computed(() => {
        return {
            'dropdown-toggle': this.caret(),
            'dropdown-toggle-split': this.split(),
            disabled: this.disabled()
        };
    }, ...(ngDevMode ? [{ debugName: "hostClasses" }] : []));
    #ariaExpanded = signal(false, ...(ngDevMode ? [{ debugName: "#ariaExpanded" }] : []));
    get ariaExpanded() {
        return this.#ariaExpanded();
    }
    onClick($event) {
        $event.preventDefault();
        !this.disabled() && this.#dropdownService.toggle({ visible: 'toggle', dropdown: this.dropdown });
    }
    ngAfterViewInit() {
        const dropdownComponent = this.dropdownComponent();
        if (dropdownComponent) {
            this.dropdown = dropdownComponent;
            this.#dropdownService = dropdownComponent?.dropdownService;
        }
        if (this.dropdown) {
            const dropdown = this.dropdown;
            dropdown?.visibleChange?.subscribe((visible) => {
                this.#ariaExpanded.set(visible);
            });
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: DropdownToggleDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.1.0", version: "20.3.2", type: DropdownToggleDirective, isStandalone: true, selector: "[cDropdownToggle]", inputs: { dropdownComponent: { classPropertyName: "dropdownComponent", publicName: "dropdownComponent", isSignal: true, isRequired: false, transformFunction: null }, disabled: { classPropertyName: "disabled", publicName: "disabled", isSignal: true, isRequired: false, transformFunction: null }, caret: { classPropertyName: "caret", publicName: "caret", isSignal: true, isRequired: false, transformFunction: null }, split: { classPropertyName: "split", publicName: "split", isSignal: true, isRequired: false, transformFunction: null } }, host: { listeners: { "click": "onClick($event)" }, properties: { "class": "hostClasses()", "attr.aria-expanded": "ariaExpanded" } }, providers: [{ provide: DropdownToken, useExisting: forwardRef(() => DropdownComponent) }], exportAs: ["cDropdownToggle"], ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: DropdownToggleDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[cDropdownToggle]',
                    providers: [{ provide: DropdownToken, useExisting: forwardRef(() => DropdownComponent) }],
                    exportAs: 'cDropdownToggle',
                    host: {
                        '[class]': 'hostClasses()',
                        '[attr.aria-expanded]': 'ariaExpanded',
                        '(click)': 'onClick($event)'
                    }
                }]
        }] });
class DropdownComponent {
    #destroyRef = inject(DestroyRef);
    #document = inject(DOCUMENT);
    #elementRef = inject(ElementRef);
    #renderer = inject(Renderer2);
    #ngZone = inject(NgZone);
    #changeDetectorRef = inject(ChangeDetectorRef);
    dropdownService = inject(DropdownService);
    constructor() {
        this.dropdownStateSubscribe();
    }
    /**
     * Set alignment of dropdown menu.
     * @return {'start' | 'end' | { xs: 'start' | 'end' } | { sm: 'start' | 'end' } | { md: 'start' | 'end' } | { lg: 'start' | 'end' } | { xl: 'start' | 'end'} | { xxl: 'start' | 'end'}}
     */
    alignment = input(...(ngDevMode ? [undefined, { debugName: "alignment" }] : []));
    /**
     * Automatically close dropdown when clicking outside the dropdown menu.
     */
    autoClose = input(true, ...(ngDevMode ? [{ debugName: "autoClose" }] : []));
    /**
     * Sets a specified  direction and location of the dropdown menu.
     * @return 'dropup' | 'dropend' | 'dropstart'
     */
    direction = input(...(ngDevMode ? [undefined, { debugName: "direction" }] : []));
    /**
     * Describes the placement of your component after Popper.js has applied all the modifiers
     * that may have flipped or altered the originally provided placement property.
     * @return Placement
     */
    placement = input('bottom-start', ...(ngDevMode ? [{ debugName: "placement" }] : []));
    /**
     * If you want to disable dynamic positioning set this property to `false`.
     * @return boolean
     * @default true
     */
    popper = input(true, ...(ngDevMode ? [{ debugName: "popper", transform: booleanAttribute }] : [{ transform: booleanAttribute }]));
    /**
     * Optional popper Options object, placement prop takes precedence over
     * @return Partial<Options>
     */
    popperOptionsInput = input({}, ...(ngDevMode ? [{ debugName: "popperOptionsInput", alias: 'popperOptions' }] : [{ alias: 'popperOptions' }]));
    #popperOptionsEffect = effect(() => {
        this.popperOptions = { ...untracked(this.#popperOptions), ...this.popperOptionsInput() };
    }, ...(ngDevMode ? [{ debugName: "#popperOptionsEffect" }] : []));
    set popperOptions(value) {
        this.#popperOptions.update((popperOptions) => ({ ...popperOptions, ...value }));
    }
    get popperOptions() {
        let placement = this.placement();
        switch (this.direction()) {
            case 'dropup': {
                placement = 'top-start';
                break;
            }
            case 'dropend': {
                placement = 'right-start';
                break;
            }
            case 'dropstart': {
                placement = 'left-start';
                break;
            }
            case 'center': {
                placement = 'bottom';
                break;
            }
            case 'dropup-center': {
                placement = 'top';
                break;
            }
        }
        if (this.alignment() === 'end') {
            placement = 'bottom-end';
        }
        this.#popperOptions.update((value) => ({ ...value, placement: placement }));
        return this.#popperOptions();
    }
    #popperOptions = signal({
        placement: this.placement(),
        modifiers: [],
        strategy: 'absolute'
    }, ...(ngDevMode ? [{ debugName: "#popperOptions" }] : []));
    /**
     * Set the dropdown variant to a btn-group, dropdown, input-group, and nav-item.
     */
    variant = input('dropdown', ...(ngDevMode ? [{ debugName: "variant" }] : []));
    /**
     * Toggle the visibility of dropdown menu component.
     * @return boolean
     * @default false
     */
    visibleInput = input(false, ...(ngDevMode ? [{ debugName: "visibleInput", transform: booleanAttribute, alias: 'visible' }] : [{ transform: booleanAttribute, alias: 'visible' }]));
    visible = linkedSignal({
        source: this.visibleInput,
        computation: (value) => value
    });
    #visibleEffect = effect(() => {
        const visible = this.visible();
        this.activeTrap = visible;
        visible ? this.createPopperInstance() : this.destroyPopperInstance();
        this.setVisibleState(visible);
        this.visibleChange?.emit(visible);
    }, ...(ngDevMode ? [{ debugName: "#visibleEffect" }] : []));
    visibleChange = output();
    dropdownContext = { $implicit: this.visible() };
    _toggler = contentChild(DropdownToggleDirective, ...(ngDevMode ? [{ debugName: "_toggler" }] : []));
    _menu = contentChild(DropdownMenuDirective, ...(ngDevMode ? [{ debugName: "_menu" }] : []));
    _menuElementRef = contentChild(DropdownMenuDirective, ...(ngDevMode ? [{ debugName: "_menuElementRef", read: ElementRef }] : [{ read: ElementRef }]));
    activeTrap = false;
    popperInstance;
    listeners = [];
    hostClasses = computed(() => {
        const direction = this.direction();
        const variant = this.variant();
        return {
            dropdown: (variant === 'dropdown' || variant === 'nav-item') && !direction,
            [`${direction}`]: !!direction,
            [`${variant}`]: !!variant,
            dropup: direction === 'dropup' || direction === 'dropup-center',
            show: this.visible()
        };
    }, ...(ngDevMode ? [{ debugName: "hostClasses" }] : []));
    // todo: find better solution
    hostStyle = computed(() => {
        return this.variant() === 'input-group' ? { display: 'contents' } : {};
    }, ...(ngDevMode ? [{ debugName: "hostStyle" }] : []));
    clickedTarget;
    onHostClick($event) {
        this.clickedTarget = $event.target;
    }
    dropdownStateSubscribe() {
        this.dropdownService.dropdownState$
            .pipe(filter((state) => {
            return this === state.dropdown;
        }), takeUntilDestroyed(this.#destroyRef))
            .subscribe((state) => {
            if ('visible' in state) {
                state?.visible === 'toggle' ? this.toggleDropdown() : this.visible.set(state.visible);
            }
        });
    }
    toggleDropdown() {
        this.visible.update((visible) => !visible);
    }
    onClick(event) {
        if (!this._toggler()?.elementRef.nativeElement.contains(event.target?.closest('[cDropdownToggle]'))) {
            this.toggleDropdown();
        }
    }
    #togglerEffect = effect(() => {
        const variant = this.variant();
        const _toggler = this._toggler();
        if (variant === 'nav-item' && _toggler) {
            this.#renderer.addClass(_toggler.elementRef.nativeElement, 'nav-link');
        }
    }, ...(ngDevMode ? [{ debugName: "#togglerEffect" }] : []));
    ngOnInit() {
        this.setVisibleState(this.visible());
    }
    ngOnDestroy() {
        this.clearListeners();
        this.destroyPopperInstance();
    }
    setVisibleState(value) {
        this.dropdownService.toggle({ visible: value, dropdown: this });
    }
    // todo: turn off popper in navbar-nav
    createPopperInstance() {
        const _toggler = this._toggler();
        const _menu = this._menu();
        if (_toggler && _menu) {
            this.#ngZone.runOutsideAngular(() => {
                // workaround for popper position calculate (see also: dropdown-menu.component)
                _menu.elementRef.nativeElement.style.visibility = 'hidden';
                _menu.elementRef.nativeElement.style.display = 'block';
                if (this.popper()) {
                    this.popperInstance = createPopper(_toggler.elementRef.nativeElement, _menu.elementRef.nativeElement, {
                        ...this.popperOptions
                    });
                }
                this.#ngZone.run(() => {
                    this.setListeners();
                    this.#changeDetectorRef.markForCheck();
                    this.#changeDetectorRef.detectChanges();
                });
            });
        }
    }
    destroyPopperInstance() {
        this.clearListeners();
        this.popperInstance?.destroy();
        this.popperInstance = undefined;
        this.#changeDetectorRef.markForCheck();
    }
    setListeners() {
        this.listeners.push(this.#renderer.listen(this.#document, 'click', (event) => {
            const target = event.target;
            if (this._menuElementRef()?.nativeElement.contains(event.target)) {
                this.clickedTarget = target;
            }
            if (this._toggler()?.elementRef.nativeElement.contains(event.target)) {
                return;
            }
            const autoClose = this.autoClose();
            if (autoClose === true) {
                this.setVisibleState(false);
                return;
            }
            if (this.clickedTarget === target && autoClose === 'inside') {
                this.setVisibleState(false);
                return;
            }
            if (this.clickedTarget !== target && autoClose === 'outside') {
                this.setVisibleState(false);
                return;
            }
        }));
        this.listeners.push(this.#renderer.listen(this.#elementRef.nativeElement, 'keyup', (event) => {
            if (event.key === 'Escape' && this.autoClose() !== false) {
                event.stopPropagation();
                this.setVisibleState(false);
                return;
            }
        }));
        this.listeners.push(this.#renderer.listen(this.#document, 'keyup', (event) => {
            if (event.key === 'Tab' &&
                this.autoClose() !== false &&
                !this.#elementRef.nativeElement.contains(event.target)) {
                this.setVisibleState(false);
                return;
            }
        }));
    }
    clearListeners() {
        this.listeners.forEach((unListen) => {
            unListen();
        });
        // @ts-ignore
        this.listeners.fill(undefined);
        this.listeners = [];
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: DropdownComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.2.0", version: "20.3.2", type: DropdownComponent, isStandalone: true, selector: "c-dropdown", inputs: { alignment: { classPropertyName: "alignment", publicName: "alignment", isSignal: true, isRequired: false, transformFunction: null }, autoClose: { classPropertyName: "autoClose", publicName: "autoClose", isSignal: true, isRequired: false, transformFunction: null }, direction: { classPropertyName: "direction", publicName: "direction", isSignal: true, isRequired: false, transformFunction: null }, placement: { classPropertyName: "placement", publicName: "placement", isSignal: true, isRequired: false, transformFunction: null }, popper: { classPropertyName: "popper", publicName: "popper", isSignal: true, isRequired: false, transformFunction: null }, popperOptionsInput: { classPropertyName: "popperOptionsInput", publicName: "popperOptions", isSignal: true, isRequired: false, transformFunction: null }, variant: { classPropertyName: "variant", publicName: "variant", isSignal: true, isRequired: false, transformFunction: null }, visibleInput: { classPropertyName: "visibleInput", publicName: "visible", isSignal: true, isRequired: false, transformFunction: null } }, outputs: { visibleChange: "visibleChange" }, host: { listeners: { "click": "onHostClick($event)" }, properties: { "class": "hostClasses()", "style": "hostStyle()" } }, providers: [DropdownService], queries: [{ propertyName: "_toggler", first: true, predicate: DropdownToggleDirective, descendants: true, isSignal: true }, { propertyName: "_menu", first: true, predicate: DropdownMenuDirective, descendants: true, isSignal: true }, { propertyName: "_menuElementRef", first: true, predicate: DropdownMenuDirective, descendants: true, read: ElementRef, isSignal: true }], exportAs: ["cDropdown"], hostDirectives: [{ directive: ThemeDirective, inputs: ["dark", "dark"] }], ngImport: i0, template: '<ng-content />', isInline: true, styles: [":host-context(.dropdown,.dropup):not(.btn-group){display:block}:host-context(.dropstart,.dropend):not(.btn-group){display:inline-flex}:host-context(html:not([dir=rtl])) :host-context(.input-group) :host:first-child::ng-deep :first-child{border-top-right-radius:0;border-bottom-right-radius:0}:host-context(html:not([dir=rtl])) :host-context(.input-group) :host:first-child::ng-deep :not(:first-child):not(.dropdown-menu){margin-left:-1px;border-top-left-radius:0;border-bottom-left-radius:0}:host-context(html:not([dir=rtl])) :host-context(.input-group) :host:first-child::ng-deep :not(:first-child):not(.dropdown-menu):not(:only-of-type){border-top-right-radius:0;border-bottom-right-radius:0}:host-context(html:not([dir=rtl])) :host-context(.input-group) :host:last-child::ng-deep :first-child{border-top-left-radius:0;border-bottom-left-radius:0}:host-context(html:not([dir=rtl])) :host-context(.input-group) :host:last-child::ng-deep :first-child:not(:only-of-type){border-top-right-radius:0;border-bottom-right-radius:0}:host-context(html:not([dir=rtl])) :host-context(.input-group) :host:last-child::ng-deep :not(:first-child):not(.dropdown-menu){margin-left:-1px;border-top-left-radius:0;border-bottom-left-radius:0}:host-context([dir=rtl] .input-group) :host{direction:rtl}:host-context([dir=rtl] .input-group) :host:first-child::ng-deep :first-child{border-top-left-radius:0;border-bottom-left-radius:0}:host-context([dir=rtl] .input-group) :host:first-child::ng-deep :not(:first-child):not(.dropdown-menu){margin-right:-1px;border-top-right-radius:0;border-bottom-right-radius:0}:host-context([dir=rtl] .input-group) :host:first-child::ng-deep :not(:first-child):not(.dropdown-menu):not(:only-of-type){border-top-left-radius:0;border-bottom-left-radius:0}:host-context([dir=rtl] .input-group) :host:last-child::ng-deep :first-child{border-top-right-radius:0;border-bottom-right-radius:0}:host-context([dir=rtl] .input-group) :host:last-child::ng-deep :first-child:not(:only-of-type){border-top-left-radius:0;border-bottom-left-radius:0}:host-context([dir=rtl] .input-group) :host:last-child::ng-deep :not(:first-child):not(.dropdown-menu){margin-right:-1px;border-top-right-radius:0;border-bottom-right-radius:0}\n"] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: DropdownComponent, decorators: [{
            type: Component,
            args: [{ selector: 'c-dropdown', template: '<ng-content />', exportAs: 'cDropdown', providers: [DropdownService], hostDirectives: [{ directive: ThemeDirective, inputs: ['dark'] }], host: {
                        '[class]': 'hostClasses()',
                        '[style]': 'hostStyle()',
                        '(click)': 'onHostClick($event)'
                    }, styles: [":host-context(.dropdown,.dropup):not(.btn-group){display:block}:host-context(.dropstart,.dropend):not(.btn-group){display:inline-flex}:host-context(html:not([dir=rtl])) :host-context(.input-group) :host:first-child::ng-deep :first-child{border-top-right-radius:0;border-bottom-right-radius:0}:host-context(html:not([dir=rtl])) :host-context(.input-group) :host:first-child::ng-deep :not(:first-child):not(.dropdown-menu){margin-left:-1px;border-top-left-radius:0;border-bottom-left-radius:0}:host-context(html:not([dir=rtl])) :host-context(.input-group) :host:first-child::ng-deep :not(:first-child):not(.dropdown-menu):not(:only-of-type){border-top-right-radius:0;border-bottom-right-radius:0}:host-context(html:not([dir=rtl])) :host-context(.input-group) :host:last-child::ng-deep :first-child{border-top-left-radius:0;border-bottom-left-radius:0}:host-context(html:not([dir=rtl])) :host-context(.input-group) :host:last-child::ng-deep :first-child:not(:only-of-type){border-top-right-radius:0;border-bottom-right-radius:0}:host-context(html:not([dir=rtl])) :host-context(.input-group) :host:last-child::ng-deep :not(:first-child):not(.dropdown-menu){margin-left:-1px;border-top-left-radius:0;border-bottom-left-radius:0}:host-context([dir=rtl] .input-group) :host{direction:rtl}:host-context([dir=rtl] .input-group) :host:first-child::ng-deep :first-child{border-top-left-radius:0;border-bottom-left-radius:0}:host-context([dir=rtl] .input-group) :host:first-child::ng-deep :not(:first-child):not(.dropdown-menu){margin-right:-1px;border-top-right-radius:0;border-bottom-right-radius:0}:host-context([dir=rtl] .input-group) :host:first-child::ng-deep :not(:first-child):not(.dropdown-menu):not(:only-of-type){border-top-left-radius:0;border-bottom-left-radius:0}:host-context([dir=rtl] .input-group) :host:last-child::ng-deep :first-child{border-top-right-radius:0;border-bottom-right-radius:0}:host-context([dir=rtl] .input-group) :host:last-child::ng-deep :first-child:not(:only-of-type){border-top-left-radius:0;border-bottom-left-radius:0}:host-context([dir=rtl] .input-group) :host:last-child::ng-deep :not(:first-child):not(.dropdown-menu){margin-right:-1px;border-top-right-radius:0;border-bottom-right-radius:0}\n"] }]
        }], ctorParameters: () => [] });

class DropdownItemDirective {
    #elementRef = inject(ElementRef);
    #dropdownService = inject(DropdownService);
    dropdown = inject(DropdownComponent, { optional: true });
    /**
     * Set active state to a dropdown-item.
     * @return boolean
     * @default undefined
     */
    active = input(...(ngDevMode ? [undefined, { debugName: "active" }] : []));
    /**
     * Configure dropdown-item close dropdown behavior.
     * @return boolean
     * @default true
     */
    autoClose = input(true, ...(ngDevMode ? [{ debugName: "autoClose" }] : []));
    /**
     * Disables a dropdown-item.
     * @return boolean
     * @default undefined
     */
    disabledInput = input(false, ...(ngDevMode ? [{ debugName: "disabledInput", transform: booleanAttribute, alias: 'disabled' }] : [{ transform: booleanAttribute, alias: 'disabled' }]));
    #disabled = linkedSignal({
        source: this.disabledInput,
        computation: (value) => value
    });
    set disabled(value) {
        this.#disabled.set(value);
    }
    get disabled() {
        return this.#disabled();
    }
    role = input('list-item', ...(ngDevMode ? [{ debugName: "role" }] : []));
    tabIndexInput = input('0', ...(ngDevMode ? [{ debugName: "tabIndexInput", alias: 'tabIndex' }] : [{ alias: 'tabIndex' }]));
    tabIndex = linkedSignal({
        source: this.tabIndexInput,
        computation: (value) => (this.disabled ? '-1' : value)
    });
    focus(origin) {
        this.#elementRef?.nativeElement?.focus();
    }
    getLabel() {
        return this.#elementRef?.nativeElement?.textContent.trim();
    }
    ariaCurrent = computed(() => {
        return this.active() ? 'true' : null;
    }, ...(ngDevMode ? [{ debugName: "ariaCurrent" }] : []));
    hostClasses = computed(() => {
        return {
            'dropdown-item': true,
            active: this.active(),
            disabled: this.disabled
        };
    }, ...(ngDevMode ? [{ debugName: "hostClasses" }] : []));
    onClick($event) {
        this.handleInteraction();
    }
    onKeyUp($event) {
        if ($event.key === 'Enter') {
            this.handleInteraction();
        }
    }
    handleInteraction() {
        if (this.autoClose()) {
            this.#dropdownService.toggle({ visible: 'toggle', dropdown: this.dropdown });
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: DropdownItemDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.1.0", version: "20.3.2", type: DropdownItemDirective, isStandalone: true, selector: "[cDropdownItem]", inputs: { active: { classPropertyName: "active", publicName: "active", isSignal: true, isRequired: false, transformFunction: null }, autoClose: { classPropertyName: "autoClose", publicName: "autoClose", isSignal: true, isRequired: false, transformFunction: null }, disabledInput: { classPropertyName: "disabledInput", publicName: "disabled", isSignal: true, isRequired: false, transformFunction: null }, role: { classPropertyName: "role", publicName: "role", isSignal: true, isRequired: false, transformFunction: null }, tabIndexInput: { classPropertyName: "tabIndexInput", publicName: "tabIndex", isSignal: true, isRequired: false, transformFunction: null } }, host: { listeners: { "click": "onClick($event)", "keyup": "onKeyUp($event)" }, properties: { "class": "hostClasses()", "attr.tabindex": "tabIndex()", "attr.aria-current": "ariaCurrent()", "attr.aria-disabled": "disabled || null", "attr.role": "role()" }, classAttribute: "dropdown-item" }, exportAs: ["cDropdownItem"], ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: DropdownItemDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[cDropdownItem]',
                    exportAs: 'cDropdownItem',
                    host: {
                        class: 'dropdown-item',
                        '[class]': 'hostClasses()',
                        '[attr.tabindex]': 'tabIndex()',
                        '[attr.aria-current]': 'ariaCurrent()',
                        '[attr.aria-disabled]': 'disabled || null',
                        '[attr.role]': 'role()',
                        '(click)': 'onClick($event)',
                        '(keyup)': 'onKeyUp($event)'
                    }
                }]
        }] });

class DropdownItemPlainDirective {
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: DropdownItemPlainDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "20.3.2", type: DropdownItemPlainDirective, isStandalone: true, selector: "[cDropdownItemPlain]", host: { classAttribute: "dropdown-item-text" }, ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: DropdownItemPlainDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[cDropdownItemPlain]',
                    host: { class: 'dropdown-item-text' }
                }]
        }] });

class DropdownCloseDirective {
    #dropdownService = inject(DropdownService);
    dropdown = inject(DropdownComponent, { optional: true });
    /**
     * Disables a dropdown-close directive.
     * @return boolean
     * @default false
     */
    disabledInput = input(false, ...(ngDevMode ? [{ debugName: "disabledInput", transform: booleanAttribute, alias: 'disabled' }] : [{ transform: booleanAttribute, alias: 'disabled' }]));
    disabled = linkedSignal({
        source: this.disabledInput,
        computation: (value) => value || null
    });
    dropdownComponent = input(...(ngDevMode ? [undefined, { debugName: "dropdownComponent" }] : []));
    ngAfterViewInit() {
        const dropdownComponent = this.dropdownComponent();
        if (dropdownComponent) {
            this.dropdown = dropdownComponent;
            this.#dropdownService = dropdownComponent?.dropdownService;
        }
    }
    tabIndexInput = input(null, ...(ngDevMode ? [{ debugName: "tabIndexInput", alias: 'tabIndex' }] : [{ alias: 'tabIndex' }]));
    tabIndex = linkedSignal({
        source: this.tabIndexInput,
        computation: (value) => (this.disabled() ? '-1' : value)
    });
    onClick($event) {
        this.handleToggle();
    }
    onKeyUp($event) {
        if ($event.key === 'Enter') {
            this.handleToggle();
        }
    }
    handleToggle() {
        if (!this.disabled()) {
            this.#dropdownService.toggle({ visible: false, dropdown: this.dropdown });
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: DropdownCloseDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.1.0", version: "20.3.2", type: DropdownCloseDirective, isStandalone: true, selector: "[cDropdownClose]", inputs: { disabledInput: { classPropertyName: "disabledInput", publicName: "disabled", isSignal: true, isRequired: false, transformFunction: null }, dropdownComponent: { classPropertyName: "dropdownComponent", publicName: "dropdownComponent", isSignal: true, isRequired: false, transformFunction: null }, tabIndexInput: { classPropertyName: "tabIndexInput", publicName: "tabIndex", isSignal: true, isRequired: false, transformFunction: null } }, host: { listeners: { "click": "onClick($event)", "keyup": "onKeyUp($event)" }, properties: { "class.disabled": "disabled()", "attr.aria-disabled": "disabled() || null", "attr.tabindex": "tabIndex()" } }, exportAs: ["cDropdownClose"], ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: DropdownCloseDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[cDropdownClose]',
                    exportAs: 'cDropdownClose',
                    host: {
                        '[class.disabled]': 'disabled()',
                        '[attr.aria-disabled]': 'disabled() || null',
                        '[attr.tabindex]': 'tabIndex()',
                        '(click)': 'onClick($event)',
                        '(keyup)': 'onKeyUp($event)'
                    }
                }]
        }] });

class DropdownModule {
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: DropdownModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
    static ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "20.3.2", ngImport: i0, type: DropdownModule, imports: [DropdownComponent,
            DropdownCloseDirective,
            DropdownDividerDirective,
            DropdownHeaderDirective,
            DropdownItemDirective,
            DropdownItemPlainDirective,
            DropdownMenuDirective,
            DropdownToggleDirective], exports: [DropdownComponent,
            DropdownCloseDirective,
            DropdownDividerDirective,
            DropdownHeaderDirective,
            DropdownItemDirective,
            DropdownItemPlainDirective,
            DropdownMenuDirective,
            DropdownToggleDirective] });
    static ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: DropdownModule, providers: [DropdownService] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: DropdownModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        DropdownComponent,
                        DropdownCloseDirective,
                        DropdownDividerDirective,
                        DropdownHeaderDirective,
                        DropdownItemDirective,
                        DropdownItemPlainDirective,
                        DropdownMenuDirective,
                        DropdownToggleDirective
                    ],
                    exports: [
                        DropdownComponent,
                        DropdownCloseDirective,
                        DropdownDividerDirective,
                        DropdownHeaderDirective,
                        DropdownItemDirective,
                        DropdownItemPlainDirective,
                        DropdownMenuDirective,
                        DropdownToggleDirective
                    ],
                    providers: [DropdownService]
                }]
        }] });

class FooterComponent {
    /**
     * Place footer in non-static positions. [docs]
     * @type Positions
     */
    position = input(...(ngDevMode ? [undefined, { debugName: "position" }] : []));
    /**
     * Default role for footer. [docs]
     * @type string
     * @default 'contentinfo'
     */
    role = input('contentinfo', ...(ngDevMode ? [{ debugName: "role" }] : []));
    hostClasses = computed(() => {
        return {
            footer: true,
            [`footer-${this.position()}`]: !!this.position()
        };
    }, ...(ngDevMode ? [{ debugName: "hostClasses" }] : []));
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: FooterComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.1.0", version: "20.3.2", type: FooterComponent, isStandalone: true, selector: "c-footer, [cFooter]", inputs: { position: { classPropertyName: "position", publicName: "position", isSignal: true, isRequired: false, transformFunction: null }, role: { classPropertyName: "role", publicName: "role", isSignal: true, isRequired: false, transformFunction: null } }, host: { properties: { "class": "hostClasses()", "attr.role": "role()" }, classAttribute: "footer" }, ngImport: i0, template: '<ng-content />', isInline: true });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: FooterComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'c-footer, [cFooter]',
                    template: '<ng-content />',
                    host: {
                        class: 'footer',
                        '[class]': 'hostClasses()',
                        '[attr.role]': 'role()'
                    }
                }]
        }] });

class FooterModule {
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: FooterModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
    static ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "20.3.2", ngImport: i0, type: FooterModule, imports: [FooterComponent], exports: [FooterComponent] });
    static ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: FooterModule });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: FooterModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [FooterComponent],
                    exports: [FooterComponent]
                }]
        }] });

class FormDirective {
    /**
     * Mark a form as validated. If you set it `true`, all validation styles will be applied to the form. [docs]
     * @return boolean
     * @default false
     */
    validated = input(false, ...(ngDevMode ? [{ debugName: "validated", transform: booleanAttribute }] : [{ transform: booleanAttribute }]));
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: FormDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.1.0", version: "20.3.2", type: FormDirective, isStandalone: true, selector: "form[cForm]", inputs: { validated: { classPropertyName: "validated", publicName: "validated", isSignal: true, isRequired: false, transformFunction: null } }, host: { properties: { "class.was-validated": "validated()" } }, ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: FormDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: 'form[cForm]',
                    host: { '[class.was-validated]': 'validated()' }
                }]
        }] });

class FormCheckLabelDirective {
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: FormCheckLabelDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "20.3.2", type: FormCheckLabelDirective, isStandalone: true, selector: "label[cFormCheckLabel]", host: { classAttribute: "form-check-label" }, ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: FormCheckLabelDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: 'label[cFormCheckLabel]',
                    host: { class: 'form-check-label' }
                }]
        }] });

class FormCheckComponent {
    static ngAcceptInputType_inline;
    static ngAcceptInputType_reverse;
    static ngAcceptInputType_switch;
    /**
     * Group checkboxes or radios on the same horizontal row.
     * @default false
     */
    inline = input(false, ...(ngDevMode ? [{ debugName: "inline", transform: booleanAttribute }] : [{ transform: booleanAttribute }]));
    /**
     * Put checkboxes or radios on the opposite side.
     * @default false
     * @since 4.4.7
     */
    reverse = input(false, ...(ngDevMode ? [{ debugName: "reverse", transform: booleanAttribute }] : [{ transform: booleanAttribute }]));
    /**
     * Size the component large or extra large. Works only with `[switch]="true"` [docs]
     * @default undefined
     */
    sizing = input(...(ngDevMode ? [undefined, { debugName: "sizing" }] : []));
    /**
     * Render a toggle switch on for checkbox.
     * @returns boolean
     * @default false
     */
    switch = input(false, ...(ngDevMode ? [{ debugName: "switch", transform: booleanAttribute }] : [{ transform: booleanAttribute }]));
    formCheckLabel = contentChild(FormCheckLabelDirective, ...(ngDevMode ? [{ debugName: "formCheckLabel" }] : []));
    hostClasses = computed(() => {
        const sizing = this.sizing();
        const isSwitch = this.switch();
        return {
            'form-check': !!this.formCheckLabel(),
            'form-switch': isSwitch,
            [`form-switch-${sizing}`]: isSwitch && !!sizing,
            'form-check-inline': this.inline(),
            'form-check-reverse': this.reverse()
        };
    }, ...(ngDevMode ? [{ debugName: "hostClasses" }] : []));
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: FormCheckComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.2.0", version: "20.3.2", type: FormCheckComponent, isStandalone: true, selector: "c-form-check", inputs: { inline: { classPropertyName: "inline", publicName: "inline", isSignal: true, isRequired: false, transformFunction: null }, reverse: { classPropertyName: "reverse", publicName: "reverse", isSignal: true, isRequired: false, transformFunction: null }, sizing: { classPropertyName: "sizing", publicName: "sizing", isSignal: true, isRequired: false, transformFunction: null }, switch: { classPropertyName: "switch", publicName: "switch", isSignal: true, isRequired: false, transformFunction: null } }, host: { properties: { "class": "hostClasses()" } }, queries: [{ propertyName: "formCheckLabel", first: true, predicate: FormCheckLabelDirective, descendants: true, isSignal: true }], exportAs: ["cFormCheck"], ngImport: i0, template: '<ng-content />', isInline: true });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: FormCheckComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'c-form-check',
                    template: '<ng-content />',
                    exportAs: 'cFormCheck',
                    host: { '[class]': 'hostClasses()' }
                }]
        }] });

class FormControlDirective {
    #hostElement = inject(ElementRef);
    /**
     * Size the component small or large.
     * @default undefined
     */
    sizing = input(...(ngDevMode ? [undefined, { debugName: "sizing" }] : []));
    /**
     * Set component validation state to valid.
     * @default undefined
     */
    valid = input(...(ngDevMode ? [undefined, { debugName: "valid" }] : []));
    /**
     * Specifies the type of input element.
     */
    type = input('text', ...(ngDevMode ? [{ debugName: "type" }] : []));
    /**
     * Render the component styled as plain text. Removes the default form field styling and preserve the correct margin and padding. Recommend to use alongside `readonly`
     * @default false
     */
    plaintext = input(false, ...(ngDevMode ? [{ debugName: "plaintext", transform: booleanAttribute }] : [{ transform: booleanAttribute }]));
    hostClasses = computed(() => {
        const type = this.type();
        const isRange = type === 'range';
        const plaintext = this.plaintext();
        const sizing = this.sizing();
        const valid = this.valid();
        return {
            'form-control': !isRange && !plaintext,
            'form-control-plaintext': !isRange && plaintext,
            'form-control-color': type === 'color',
            'form-range': isRange,
            [`form-control-${sizing}`]: !!sizing && !isRange,
            'is-valid': valid === true,
            'is-invalid': valid === false
        };
    }, ...(ngDevMode ? [{ debugName: "hostClasses" }] : []));
    get hostTag() {
        return this.#hostElement.nativeElement.tagName;
    }
    ngOnInit() {
        const hostTag = this.hostTag.toLowerCase();
        if (hostTag !== 'input' && hostTag !== 'textarea') {
            console.warn(`CoreUI [cFormControl] works with '<input>' and '<textarea>' - not with '<${hostTag}>'`);
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: FormControlDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.1.0", version: "20.3.2", type: FormControlDirective, isStandalone: true, selector: "input[cFormControl], textarea[cFormControl]", inputs: { sizing: { classPropertyName: "sizing", publicName: "sizing", isSignal: true, isRequired: false, transformFunction: null }, valid: { classPropertyName: "valid", publicName: "valid", isSignal: true, isRequired: false, transformFunction: null }, type: { classPropertyName: "type", publicName: "type", isSignal: true, isRequired: false, transformFunction: null }, plaintext: { classPropertyName: "plaintext", publicName: "plaintext", isSignal: true, isRequired: false, transformFunction: null } }, host: { properties: { "class": "hostClasses()", "attr.type": "type()" } }, ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: FormControlDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: 'input[cFormControl], textarea[cFormControl]',
                    host: {
                        '[class]': 'hostClasses()',
                        '[attr.type]': 'type()'
                    }
                }]
        }] });

class FormCheckInputDirective {
    static ngAcceptInputType_indeterminate;
    #renderer = inject(Renderer2);
    #hostElement = inject(ElementRef);
    /**
     * Specifies the type of component.
     * @default 'checkbox'
     */
    type = input('checkbox', ...(ngDevMode ? [{ debugName: "type" }] : []));
    /**
     * Set component indeterminate state.
     * @default false
     */
    indeterminateInput = input(false, ...(ngDevMode ? [{ debugName: "indeterminateInput", transform: booleanAttribute, alias: 'indeterminate' }] : [{ transform: booleanAttribute, alias: 'indeterminate' }]));
    #indeterminate = linkedSignal(this.indeterminateInput);
    #indeterminateEffect = effect(() => {
        if (this.type() === 'checkbox') {
            const indeterminate = this.#indeterminate();
            const htmlInputElement = this.#hostElement.nativeElement;
            if (indeterminate) {
                this.#renderer.setProperty(htmlInputElement, 'checked', false);
            }
            this.#renderer.setProperty(htmlInputElement, 'indeterminate', indeterminate);
        }
    }, ...(ngDevMode ? [{ debugName: "#indeterminateEffect" }] : []));
    get indeterminate() {
        return this.#indeterminate();
    }
    /**
     * Set component validation state to valid.
     * @default undefined
     */
    valid = input(...(ngDevMode ? [undefined, { debugName: "valid" }] : []));
    hostClasses = computed(() => {
        const valid = this.valid();
        return {
            'form-check-input': true,
            'is-valid': valid === true,
            'is-invalid': valid === false
        };
    }, ...(ngDevMode ? [{ debugName: "hostClasses" }] : []));
    get checked() {
        return this.#hostElement?.nativeElement?.checked;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: FormCheckInputDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.1.0", version: "20.3.2", type: FormCheckInputDirective, isStandalone: true, selector: "input[cFormCheckInput]", inputs: { type: { classPropertyName: "type", publicName: "type", isSignal: true, isRequired: false, transformFunction: null }, indeterminateInput: { classPropertyName: "indeterminateInput", publicName: "indeterminate", isSignal: true, isRequired: false, transformFunction: null }, valid: { classPropertyName: "valid", publicName: "valid", isSignal: true, isRequired: false, transformFunction: null } }, host: { properties: { "class": "hostClasses()", "attr.type": "type()" }, classAttribute: "form-check-input" }, ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: FormCheckInputDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: 'input[cFormCheckInput]',
                    host: {
                        class: 'form-check-input',
                        '[class]': 'hostClasses()',
                        '[attr.type]': 'type()'
                    }
                }]
        }] });

class FormFeedbackComponent {
    /**
     * If your form layout allows it, you can display validation feedback in a styled tooltip.
     * @default false
     */
    tooltip = input(false, ...(ngDevMode ? [{ debugName: "tooltip", transform: booleanAttribute }] : [{ transform: booleanAttribute }]));
    /**
     * Set component validation state to valid.
     * @default undefined
     */
    valid = input(...(ngDevMode ? [undefined, { debugName: "valid" }] : []));
    hostClasses = computed(() => {
        const status = this.valid() === true ? 'valid' : 'invalid';
        const type = this.tooltip() ? 'tooltip' : 'feedback';
        return {
            [`${status}-${type}`]: true
            // 'valid-feedback': valid === true && !tooltip,
            // 'valid-tooltip': valid === true && tooltip,
            // 'invalid-feedback': valid !== true && !tooltip,
            // 'invalid-tooltip': valid !== true && tooltip
        };
    }, ...(ngDevMode ? [{ debugName: "hostClasses" }] : []));
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: FormFeedbackComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.1.0", version: "20.3.2", type: FormFeedbackComponent, isStandalone: true, selector: "c-form-feedback", inputs: { tooltip: { classPropertyName: "tooltip", publicName: "tooltip", isSignal: true, isRequired: false, transformFunction: null }, valid: { classPropertyName: "valid", publicName: "valid", isSignal: true, isRequired: false, transformFunction: null } }, host: { properties: { "class": "hostClasses()" } }, ngImport: i0, template: '<ng-content />', isInline: true });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: FormFeedbackComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'c-form-feedback',
                    template: '<ng-content />',
                    host: { '[class]': 'hostClasses()' }
                }]
        }] });

class FormFloatingDirective {
    /**
     * Enable floating labels
     * @dafault boolean
     */
    floating = input(true, ...(ngDevMode ? [{ debugName: "floating", transform: booleanAttribute, alias: 'cFormFloating' }] : [{ transform: booleanAttribute, alias: 'cFormFloating' }]));
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: FormFloatingDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.1.0", version: "20.3.2", type: FormFloatingDirective, isStandalone: true, selector: "[cFormFloating]", inputs: { floating: { classPropertyName: "floating", publicName: "cFormFloating", isSignal: true, isRequired: false, transformFunction: null } }, host: { properties: { "class.form-floating": "floating()" } }, ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: FormFloatingDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[cFormFloating]',
                    host: { '[class.form-floating]': 'floating()' }
                }]
        }] });

class FormLabelDirective {
    /**
     * For horizontal forms set labels to 'col' and make them vertically centered with their associated form controls.
     * @default ''
     */
    col = input('', ...(ngDevMode ? [{ debugName: "col", alias: 'cLabel' }] : [{ alias: 'cLabel' }]));
    /**
     * Size the label small or large.
     * @default ''
     */
    sizing = input(...(ngDevMode ? [undefined, { debugName: "sizing" }] : []));
    hostClasses = computed(() => {
        const col = this.col();
        const sizing = this.sizing();
        return {
            'form-label': true,
            'col-form-label': col === 'col',
            [`col-form-label-${sizing}`]: !!sizing && col === 'col'
        };
    }, ...(ngDevMode ? [{ debugName: "hostClasses" }] : []));
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: FormLabelDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.1.0", version: "20.3.2", type: FormLabelDirective, isStandalone: true, selector: "[cLabel]", inputs: { col: { classPropertyName: "col", publicName: "cLabel", isSignal: true, isRequired: false, transformFunction: null }, sizing: { classPropertyName: "sizing", publicName: "sizing", isSignal: true, isRequired: false, transformFunction: null } }, host: { properties: { "class": "hostClasses()" }, classAttribute: "form-label" }, ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: FormLabelDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[cLabel]',
                    host: { class: 'form-label', '[class]': 'hostClasses()' }
                }]
        }] });

class FormSelectDirective {
    /**
     * Size the component small or large.
     * @default undefined
     */
    sizing = input(...(ngDevMode ? [undefined, { debugName: "sizing" }] : []));
    /**
     * Set component validation state to valid.
     * @default undefined
     */
    valid = input(...(ngDevMode ? [undefined, { debugName: "valid" }] : []));
    hostClasses = computed(() => {
        const sizing = this.sizing();
        const valid = this.valid();
        return {
            'form-select': true,
            [`form-select-${sizing}`]: !!sizing,
            'is-valid': valid === true,
            'is-invalid': valid === false
        };
    }, ...(ngDevMode ? [{ debugName: "hostClasses" }] : []));
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: FormSelectDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.1.0", version: "20.3.2", type: FormSelectDirective, isStandalone: true, selector: "select[cSelect]", inputs: { sizing: { classPropertyName: "sizing", publicName: "sizing", isSignal: true, isRequired: false, transformFunction: null }, valid: { classPropertyName: "valid", publicName: "valid", isSignal: true, isRequired: false, transformFunction: null } }, host: { properties: { "class": "hostClasses()" }, classAttribute: "form-select" }, ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: FormSelectDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: 'select[cSelect]',
                    host: { class: 'form-select', '[class]': 'hostClasses()' }
                }]
        }] });

class FormTextDirective {
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: FormTextDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "20.3.2", type: FormTextDirective, isStandalone: true, selector: "[cFormText]", host: { classAttribute: "form-text" }, ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: FormTextDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[cFormText]',
                    host: { class: 'form-text' }
                }]
        }] });

class InputGroupComponent {
    /**
     * Size the component small or large.
     */
    sizing = input(...(ngDevMode ? [undefined, { debugName: "sizing" }] : []));
    hostClasses = computed(() => {
        const sizing = this.sizing();
        return {
            'input-group': true,
            [`input-group-${sizing}`]: !!sizing
        };
    }, ...(ngDevMode ? [{ debugName: "hostClasses" }] : []));
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: InputGroupComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.1.0", version: "20.3.2", type: InputGroupComponent, isStandalone: true, selector: "c-input-group", inputs: { sizing: { classPropertyName: "sizing", publicName: "sizing", isSignal: true, isRequired: false, transformFunction: null } }, host: { properties: { "class": "hostClasses()" }, classAttribute: "input-group" }, ngImport: i0, template: '<ng-content />', isInline: true });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: InputGroupComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'c-input-group',
                    template: '<ng-content />',
                    host: { class: 'input-group', '[class]': 'hostClasses()' }
                }]
        }] });

class InputGroupTextDirective {
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: InputGroupTextDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "20.3.2", type: InputGroupTextDirective, isStandalone: true, selector: "[cInputGroupText]", host: { classAttribute: "input-group-text" }, ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: InputGroupTextDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[cInputGroupText]',
                    host: { class: 'input-group-text' }
                }]
        }] });

class FormModule {
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: FormModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
    static ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "20.3.2", ngImport: i0, type: FormModule, imports: [FormDirective,
            FormCheckComponent,
            FormCheckLabelDirective,
            FormCheckInputDirective,
            FormControlDirective,
            FormFeedbackComponent,
            FormFloatingDirective,
            FormLabelDirective,
            FormSelectDirective,
            FormTextDirective,
            InputGroupComponent,
            InputGroupTextDirective], exports: [FormDirective,
            FormCheckComponent,
            FormCheckLabelDirective,
            FormCheckInputDirective,
            FormControlDirective,
            FormFeedbackComponent,
            FormFloatingDirective,
            FormLabelDirective,
            FormSelectDirective,
            FormTextDirective,
            InputGroupComponent,
            InputGroupTextDirective] });
    static ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: FormModule });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: FormModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        FormDirective,
                        FormCheckComponent,
                        FormCheckLabelDirective,
                        FormCheckInputDirective,
                        FormControlDirective,
                        FormFeedbackComponent,
                        FormFloatingDirective,
                        FormLabelDirective,
                        FormSelectDirective,
                        FormTextDirective,
                        InputGroupComponent,
                        InputGroupTextDirective
                    ],
                    exports: [
                        FormDirective,
                        FormCheckComponent,
                        FormCheckLabelDirective,
                        FormCheckInputDirective,
                        FormControlDirective,
                        FormFeedbackComponent,
                        FormFloatingDirective,
                        FormLabelDirective,
                        FormSelectDirective,
                        FormTextDirective,
                        InputGroupComponent,
                        InputGroupTextDirective
                    ]
                }]
        }] });

class ContainerComponent {
    /**
     * Set container 100% wide until a breakpoint.
     */
    breakpoint = input('', ...(ngDevMode ? [{ debugName: "breakpoint" }] : []));
    /**
     * Set container 100% wide, spanning the entire width of the viewport.
     * @return boolean
     */
    fluid = input(false, ...(ngDevMode ? [{ debugName: "fluid", transform: booleanAttribute }] : [{ transform: booleanAttribute }]));
    hostClasses = computed(() => {
        const breakpoint = this.breakpoint();
        const fluid = this.fluid();
        return {
            container: !fluid && !breakpoint,
            'container-fluid': !!fluid,
            [`container-${breakpoint}`]: !!breakpoint
        };
    }, ...(ngDevMode ? [{ debugName: "hostClasses" }] : []));
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: ContainerComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.1.0", version: "20.3.2", type: ContainerComponent, isStandalone: true, selector: "c-container, [cContainer]", inputs: { breakpoint: { classPropertyName: "breakpoint", publicName: "breakpoint", isSignal: true, isRequired: false, transformFunction: null }, fluid: { classPropertyName: "fluid", publicName: "fluid", isSignal: true, isRequired: false, transformFunction: null } }, host: { properties: { "class": "hostClasses()" } }, ngImport: i0, template: '<ng-content />', isInline: true, styles: [":host{display:block}\n"] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: ContainerComponent, decorators: [{
            type: Component,
            args: [{ selector: 'c-container, [cContainer]', template: '<ng-content />', host: { '[class]': 'hostClasses()' }, styles: [":host{display:block}\n"] }]
        }] });

class ColDirective {
    static ngAcceptInputType_cCol;
    static ngAcceptInputType_xs;
    static ngAcceptInputType_sm;
    static ngAcceptInputType_md;
    static ngAcceptInputType_lg;
    static ngAcceptInputType_xl;
    static ngAcceptInputType_xxl;
    /**
     * The number of columns/offset/order on extra small devices (<576px).
     * @return { 'auto' | number |  boolean }
     */
    cCol = input(false, ...(ngDevMode ? [{ debugName: "cCol", transform: this.coerceInput }] : [{ transform: this.coerceInput }]));
    xs = input(false, ...(ngDevMode ? [{ debugName: "xs", transform: this.coerceInput }] : [{ transform: this.coerceInput }]));
    /**
     * The number of columns/offset/order on small devices (<768px).
     * @return { 'auto' | number |  boolean }
     */
    sm = input(false, ...(ngDevMode ? [{ debugName: "sm", transform: this.coerceInput }] : [{ transform: this.coerceInput }]));
    /**
     * The number of columns/offset/order on medium devices (<992px).
     * @return { 'auto' | number |  boolean }
     */
    md = input(false, ...(ngDevMode ? [{ debugName: "md", transform: this.coerceInput }] : [{ transform: this.coerceInput }]));
    /**
     * The number of columns/offset/order on large devices (<1200px).
     * @return { 'auto' | number |  boolean }
     */
    lg = input(false, ...(ngDevMode ? [{ debugName: "lg", transform: this.coerceInput }] : [{ transform: this.coerceInput }]));
    /**
     * The number of columns/offset/order on X-Large devices (<1400px).
     * @return { 'auto' | number |  boolean }
     */
    xl = input(false, ...(ngDevMode ? [{ debugName: "xl", transform: this.coerceInput }] : [{ transform: this.coerceInput }]));
    /**
     * The number of columns/offset/order on XX-Large devices (≥1400px).
     * @return { 'auto' | number |  boolean }
     */
    xxl = input(false, ...(ngDevMode ? [{ debugName: "xxl", transform: this.coerceInput }] : [{ transform: this.coerceInput }]));
    breakpoints = computed(() => {
        return {
            xs: this.xs() || this.cCol(),
            sm: this.sm(),
            md: this.md(),
            lg: this.lg(),
            xl: this.xl(),
            xxl: this.xxl()
        };
    }, ...(ngDevMode ? [{ debugName: "breakpoints" }] : []));
    offset = input(...(ngDevMode ? [undefined, { debugName: "offset" }] : []));
    order = input(...(ngDevMode ? [undefined, { debugName: "order" }] : []));
    hostClasses = computed(() => {
        const classes = {
            col: true
        };
        const breakpoints = this.breakpoints();
        const offsetInput = this.offset();
        const orderInput = this.order();
        Object.keys(BreakpointInfix).forEach((breakpoint) => {
            const value = breakpoints[breakpoint];
            const infix = breakpoint === 'xs' ? '' : `-${breakpoint}`;
            classes[`col${infix}`] = value === true;
            classes[`col${infix}-${value}`] = typeof value === 'number' || typeof value === 'string';
        });
        if (typeof offsetInput === 'object') {
            const offset = { ...offsetInput };
            Object.entries(offset).forEach((entry) => {
                const [breakpoint, value] = [...entry];
                const infix = breakpoint === 'xs' ? '' : `-${breakpoint}`;
                classes[`offset${infix}-${value}`] = value >= 0 && value <= 11;
            });
        }
        else {
            const offset = numberAttribute(offsetInput);
            classes[`offset-${offset}`] = typeof offset === 'number' && offset > 0 && offset <= 11;
        }
        if (typeof orderInput === 'object') {
            const order = { ...orderInput };
            Object.entries(order).forEach((entry) => {
                const [breakpoint, value] = [...entry];
                const infix = breakpoint === 'xs' ? '' : `-${breakpoint}`;
                classes[`order${infix}-${value}`] = !!value;
            });
        }
        else {
            const order = orderInput;
            classes[`order-${order}`] = !!order;
        }
        // if there is no 'col' class, add one
        classes['col'] =
            !Object.entries(classes).filter((i) => i[0].startsWith('col-') && i[1]).length || breakpoints['xs'] === true;
        return classes;
    }, ...(ngDevMode ? [{ debugName: "hostClasses" }] : []));
    coerceInput(value) {
        if (value === 'auto') {
            return value;
        }
        if (value === '' || value === undefined || value === null) {
            return booleanAttribute(value);
        }
        if (typeof value === 'boolean') {
            return value;
        }
        return numberAttribute(value);
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: ColDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.1.0", version: "20.3.2", type: ColDirective, isStandalone: true, selector: "[cCol]", inputs: { cCol: { classPropertyName: "cCol", publicName: "cCol", isSignal: true, isRequired: false, transformFunction: null }, xs: { classPropertyName: "xs", publicName: "xs", isSignal: true, isRequired: false, transformFunction: null }, sm: { classPropertyName: "sm", publicName: "sm", isSignal: true, isRequired: false, transformFunction: null }, md: { classPropertyName: "md", publicName: "md", isSignal: true, isRequired: false, transformFunction: null }, lg: { classPropertyName: "lg", publicName: "lg", isSignal: true, isRequired: false, transformFunction: null }, xl: { classPropertyName: "xl", publicName: "xl", isSignal: true, isRequired: false, transformFunction: null }, xxl: { classPropertyName: "xxl", publicName: "xxl", isSignal: true, isRequired: false, transformFunction: null }, offset: { classPropertyName: "offset", publicName: "offset", isSignal: true, isRequired: false, transformFunction: null }, order: { classPropertyName: "order", publicName: "order", isSignal: true, isRequired: false, transformFunction: null } }, host: { properties: { "class": "hostClasses()" } }, ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: ColDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[cCol]',
                    host: {
                        '[class]': 'hostClasses()'
                    }
                }]
        }] });

class ColComponent extends ColDirective {
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: ColComponent, deps: null, target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "20.3.2", type: ColComponent, isStandalone: true, selector: "c-col", usesInheritance: true, ngImport: i0, template: '<ng-content />', isInline: true, styles: [":host{display:block}\n"] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: ColComponent, decorators: [{
            type: Component,
            args: [{ selector: 'c-col', template: '<ng-content />', styles: [":host{display:block}\n"] }]
        }] });

class RowDirective {
    /**
     * The number of columns/offset/order on extra small devices (<576px).
     * @return { cols: 'auto' | number }
     */
    xs = input(...(ngDevMode ? [undefined, { debugName: "xs" }] : []));
    /**
     * The number of columns/offset/order on small devices (<768px).
     * @return { cols: 'auto' | number }
     */
    sm = input(...(ngDevMode ? [undefined, { debugName: "sm" }] : []));
    /**
     * The number of columns/offset/order on medium devices (<992px).
     * @return { cols: 'auto' | number }
     */
    md = input(...(ngDevMode ? [undefined, { debugName: "md" }] : []));
    /**
     * The number of columns/offset/order on large devices (<1200px).
     * @return { cols: 'auto' | number }
     */
    lg = input(...(ngDevMode ? [undefined, { debugName: "lg" }] : []));
    /**
     * The number of columns/offset/order on X-Large devices (<1400px).
     * @return { cols: 'auto' | number }
     */
    xl = input(...(ngDevMode ? [undefined, { debugName: "xl" }] : []));
    /**
     * The number of columns/offset/order on XX-Large devices (≥1400px).
     * @return { cols: 'auto' | number }
     */
    xxl = input(...(ngDevMode ? [undefined, { debugName: "xxl" }] : []));
    hostClasses = computed(() => {
        const cols = this.xs();
        const classes = {
            row: true,
            [`row-cols-${cols}`]: !!cols
        };
        Object.keys(BreakpointInfix).forEach((breakpoint) => {
            // @ts-ignore
            const value = this[breakpoint]();
            if (typeof value === 'number' || typeof value === 'string') {
                const infix = breakpoint === 'xs' ? '' : `-${breakpoint}`;
                classes[`row-cols${infix}-${value}`] = !!value;
            }
        });
        return classes;
    }, ...(ngDevMode ? [{ debugName: "hostClasses" }] : []));
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: RowDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.1.0", version: "20.3.2", type: RowDirective, isStandalone: true, selector: "[cRow]", inputs: { xs: { classPropertyName: "xs", publicName: "xs", isSignal: true, isRequired: false, transformFunction: null }, sm: { classPropertyName: "sm", publicName: "sm", isSignal: true, isRequired: false, transformFunction: null }, md: { classPropertyName: "md", publicName: "md", isSignal: true, isRequired: false, transformFunction: null }, lg: { classPropertyName: "lg", publicName: "lg", isSignal: true, isRequired: false, transformFunction: null }, xl: { classPropertyName: "xl", publicName: "xl", isSignal: true, isRequired: false, transformFunction: null }, xxl: { classPropertyName: "xxl", publicName: "xxl", isSignal: true, isRequired: false, transformFunction: null } }, host: { properties: { "class": "hostClasses()" }, classAttribute: "row" }, ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: RowDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[cRow]',
                    host: {
                        class: 'row',
                        '[class]': 'hostClasses()'
                    }
                }]
        }] });

class RowComponent extends RowDirective {
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: RowComponent, deps: null, target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "20.3.2", type: RowComponent, isStandalone: true, selector: "c-row", usesInheritance: true, ngImport: i0, template: '<ng-content />', isInline: true });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: RowComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'c-row',
                    template: '<ng-content />'
                }]
        }] });

class GutterDirective {
    /**
     * Define padding between columns to space and align content responsively in the Bootstrap grid system.
     */
    gutter = input({}, ...(ngDevMode ? [{ debugName: "gutter" }] : []));
    hostClasses = computed(() => {
        let gutterClass;
        const gutterInput = this.gutter();
        if (typeof gutterInput === 'number') {
            gutterClass = GutterDirective.getGutterClasses({ g: gutterInput });
            return gutterClass;
        }
        {
            const { g, gx, gy } = { ...gutterInput };
            gutterClass = GutterDirective.getGutterClasses({ g, gx, gy });
        }
        Object.keys(BreakpointInfix).forEach((key) => {
            // @ts-ignore
            const gutter = gutterInput[key] ? { ...gutterInput[key] } : undefined;
            if (gutter) {
                const classes = GutterDirective.getGutterClasses(gutter, key);
                gutterClass = { ...gutterClass, ...classes };
            }
        });
        return gutterClass;
    }, ...(ngDevMode ? [{ debugName: "hostClasses" }] : []));
    static getGutterClasses(gutter, breakpoint) {
        const { g, gx, gy } = { ...gutter };
        const infix = breakpoint ? `-${breakpoint}` : '';
        return {
            [`g${infix}-${g}`]: typeof g === 'number',
            [`gx${infix}-${gx}`]: typeof gx === 'number',
            [`gy${infix}-${gy}`]: typeof gy === 'number'
        };
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: GutterDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.1.0", version: "20.3.2", type: GutterDirective, isStandalone: true, selector: "[gutter]", inputs: { gutter: { classPropertyName: "gutter", publicName: "gutter", isSignal: true, isRequired: false, transformFunction: null } }, host: { properties: { "class": "hostClasses()" } }, exportAs: ["gutter"], ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: GutterDirective, decorators: [{
            type: Directive,
            args: [{
                    // eslint-disable-next-line @angular-eslint/directive-selector
                    selector: '[gutter]',
                    exportAs: 'gutter',
                    host: {
                        '[class]': 'hostClasses()'
                    }
                }]
        }] });

class GridModule {
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: GridModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
    static ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "20.3.2", ngImport: i0, type: GridModule, imports: [ColComponent,
            ColDirective,
            ContainerComponent,
            GutterDirective,
            RowComponent,
            RowDirective], exports: [ColComponent,
            ColDirective,
            ContainerComponent,
            GutterDirective,
            RowComponent,
            RowDirective] });
    static ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: GridModule });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: GridModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        ColComponent,
                        ColDirective,
                        ContainerComponent,
                        GutterDirective,
                        RowComponent,
                        RowDirective
                    ],
                    exports: [
                        ColComponent,
                        ColDirective,
                        ContainerComponent,
                        GutterDirective,
                        RowComponent,
                        RowDirective
                    ]
                }]
        }] });

class HeaderComponent {
    /**
     * Defines optional container wrapping children elements.
     */
    container = input(...(ngDevMode ? [undefined, { debugName: "container" }] : []));
    /**
     * Place header in non-static positions.
     */
    position = input(...(ngDevMode ? [undefined, { debugName: "position" }] : []));
    /**
     * Default role for header. [docs]
     * @type string
     * @default 'banner'
     */
    role = input('banner', ...(ngDevMode ? [{ debugName: "role" }] : []));
    hostClasses = computed(() => {
        return !!this.container() ? this.containerClasses() : this.headerClasses();
    }, ...(ngDevMode ? [{ debugName: "hostClasses" }] : []));
    headerClasses = computed(() => {
        const position = this.position();
        return {
            header: true,
            [`header-${position}`]: !!position
        };
    }, ...(ngDevMode ? [{ debugName: "headerClasses" }] : []));
    containerClasses = computed(() => {
        const container = this.container();
        return {
            container: container === true,
            [`container-${container}`]: typeof container === 'string'
        };
    }, ...(ngDevMode ? [{ debugName: "containerClasses" }] : []));
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: HeaderComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "20.3.2", type: HeaderComponent, isStandalone: true, selector: "c-header, [c-header]", inputs: { container: { classPropertyName: "container", publicName: "container", isSignal: true, isRequired: false, transformFunction: null }, position: { classPropertyName: "position", publicName: "position", isSignal: true, isRequired: false, transformFunction: null }, role: { classPropertyName: "role", publicName: "role", isSignal: true, isRequired: false, transformFunction: null } }, host: { properties: { "attr.role": "role()", "class": "hostClasses()" } }, exportAs: ["cHeader"], ngImport: i0, template: "@if (!!container()) {\n  <div [ngClass]=\"headerClasses()\">\n    <ng-content />\n  </div>\n} @else {\n  <ng-content />\n}\n", dependencies: [{ kind: "directive", type: NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: HeaderComponent, decorators: [{
            type: Component,
            args: [{ selector: 'c-header, [c-header]', imports: [NgClass], exportAs: 'cHeader', host: { '[attr.role]': 'role()', '[class]': 'hostClasses()' }, template: "@if (!!container()) {\n  <div [ngClass]=\"headerClasses()\">\n    <ng-content />\n  </div>\n} @else {\n  <ng-content />\n}\n" }]
        }] });

class HeaderBrandComponent {
    /**
     * Default role for header-brand. [docs]
     * @return string
     * @default 'button'
     */
    role = input('button', ...(ngDevMode ? [{ debugName: "role" }] : []));
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: HeaderBrandComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.1.0", version: "20.3.2", type: HeaderBrandComponent, isStandalone: true, selector: "c-header-brand", inputs: { role: { classPropertyName: "role", publicName: "role", isSignal: true, isRequired: false, transformFunction: null } }, host: { properties: { "attr.role": "role()" }, classAttribute: "header-brand" }, exportAs: ["cHeaderBrand"], ngImport: i0, template: '<ng-content />', isInline: true });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: HeaderBrandComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'c-header-brand',
                    template: '<ng-content />',
                    exportAs: 'cHeaderBrand',
                    host: {
                        '[attr.role]': 'role()',
                        class: 'header-brand'
                    }
                }]
        }] });

class HeaderDividerComponent {
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: HeaderDividerComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "20.3.2", type: HeaderDividerComponent, isStandalone: true, selector: "c-header-divider, [cHeaderDivider]", host: { classAttribute: "header-divider" }, ngImport: i0, template: ``, isInline: true });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: HeaderDividerComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'c-header-divider, [cHeaderDivider]',
                    template: ``,
                    host: {
                        class: 'header-divider'
                    }
                }]
        }] });

class HeaderNavComponent {
    /**
     * Default role for header-nav. [docs]
     * @return string
     * @default 'navigation'
     */
    role = input('navigation', ...(ngDevMode ? [{ debugName: "role" }] : []));
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: HeaderNavComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.1.0", version: "20.3.2", type: HeaderNavComponent, isStandalone: true, selector: "c-header-nav", inputs: { role: { classPropertyName: "role", publicName: "role", isSignal: true, isRequired: false, transformFunction: null } }, host: { properties: { "attr.role": "role()" }, classAttribute: "header-nav" }, exportAs: ["cHeaderNav"], ngImport: i0, template: '<ng-content />', isInline: true, styles: [""] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: HeaderNavComponent, decorators: [{
            type: Component,
            args: [{ selector: 'c-header-nav', template: '<ng-content />', exportAs: 'cHeaderNav', host: {
                        '[attr.role]': 'role()',
                        class: 'header-nav'
                    } }]
        }] });

class HeaderTextComponent {
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: HeaderTextComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "20.3.2", type: HeaderTextComponent, isStandalone: true, selector: "c-header-text, [cHeaderText]", host: { classAttribute: "header-text" }, ngImport: i0, template: '<ng-content />', isInline: true });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: HeaderTextComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'c-header-text, [cHeaderText]',
                    template: '<ng-content />',
                    host: {
                        class: 'header-text'
                    }
                }]
        }] });

class HeaderTogglerDirective {
    #renderer = inject(Renderer2);
    #hostElement = inject(ElementRef);
    /**
     * Default type for header-toggler button. [docs]
     * @return string
     * @default 'button'
     */
    type = input('button', ...(ngDevMode ? [{ debugName: "type" }] : []));
    /**
     * Default aria-label attr for header-toggler. [docs]
     * @type string
     * @default 'Toggle navigation'
     */
    ariaLabel = input('Toggle navigation', ...(ngDevMode ? [{ debugName: "ariaLabel" }] : []));
    addDefaultIcon() {
        const span = this.#renderer.createElement('span');
        this.#renderer.addClass(span, 'header-toggler-icon');
        this.#renderer.appendChild(this.#hostElement.nativeElement, span);
    }
    ngAfterContentInit() {
        const hasContent = this.#hostElement.nativeElement.childNodes.length > 0;
        if (!hasContent) {
            this.addDefaultIcon();
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: HeaderTogglerDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.1.0", version: "20.3.2", type: HeaderTogglerDirective, isStandalone: true, selector: "[cHeaderToggler]", inputs: { type: { classPropertyName: "type", publicName: "type", isSignal: true, isRequired: false, transformFunction: null }, ariaLabel: { classPropertyName: "ariaLabel", publicName: "ariaLabel", isSignal: true, isRequired: false, transformFunction: null } }, host: { properties: { "attr.type": "type()", "attr.aria-label": "ariaLabel()" }, classAttribute: "header-toggler" }, exportAs: ["cHeaderToggler"], ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: HeaderTogglerDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[cHeaderToggler]',
                    exportAs: 'cHeaderToggler',
                    host: {
                        '[attr.type]': 'type()',
                        '[attr.aria-label]': 'ariaLabel()',
                        class: 'header-toggler'
                    }
                }]
        }] });

class HeaderModule {
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: HeaderModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
    static ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "20.3.2", ngImport: i0, type: HeaderModule, imports: [HeaderComponent,
            HeaderBrandComponent,
            HeaderDividerComponent,
            HeaderNavComponent,
            HeaderTextComponent,
            HeaderTogglerDirective], exports: [HeaderComponent,
            HeaderBrandComponent,
            HeaderDividerComponent,
            HeaderNavComponent,
            HeaderTextComponent,
            HeaderTogglerDirective] });
    static ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: HeaderModule });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: HeaderModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        HeaderComponent,
                        HeaderBrandComponent,
                        HeaderDividerComponent,
                        HeaderNavComponent,
                        HeaderTextComponent,
                        HeaderTogglerDirective
                    ],
                    exports: [
                        HeaderComponent,
                        HeaderBrandComponent,
                        HeaderDividerComponent,
                        HeaderNavComponent,
                        HeaderTextComponent,
                        HeaderTogglerDirective
                    ]
                }]
        }] });

class ImgDirective {
    /**
     * Set the horizontal aligment.
     * @type {'' | 'start' | 'end' | 'center'}
     */
    align = input('', ...(ngDevMode ? [{ debugName: "align" }] : []));
    /**
     * Make image responsive.
     * @type boolean
     */
    fluid = input(false, ...(ngDevMode ? [{ debugName: "fluid", transform: booleanAttribute }] : [{ transform: booleanAttribute }]));
    /**
     * Make image rounded.
     * @type boolean
     */
    rounded = input(false, ...(ngDevMode ? [{ debugName: "rounded", transform: booleanAttribute }] : [{ transform: booleanAttribute }]));
    /**
     * Give an image a rounded 1px border appearance.
     * @type boolean
     */
    thumbnail = input(false, ...(ngDevMode ? [{ debugName: "thumbnail", transform: booleanAttribute }] : [{ transform: booleanAttribute }]));
    /**
     * Color for image placeholder.
     */
    placeholderColor = input('transparent', ...(ngDevMode ? [{ debugName: "placeholderColor" }] : []));
    hostStyles = computed(() => {
        return { backgroundColor: this.placeholderColor() };
    }, ...(ngDevMode ? [{ debugName: "hostStyles" }] : []));
    hostClasses = computed(() => {
        const align = this.align();
        return {
            [`float-${align}`]: align === 'start' || align === 'end',
            'd-block': align === 'center',
            'mx-auto': align === 'center',
            'img-fluid': this.fluid(),
            rounded: this.rounded(),
            'img-thumbnail': this.thumbnail()
        };
    }, ...(ngDevMode ? [{ debugName: "hostClasses" }] : []));
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: ImgDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.1.0", version: "20.3.2", type: ImgDirective, isStandalone: true, selector: "[cImg]", inputs: { align: { classPropertyName: "align", publicName: "align", isSignal: true, isRequired: false, transformFunction: null }, fluid: { classPropertyName: "fluid", publicName: "fluid", isSignal: true, isRequired: false, transformFunction: null }, rounded: { classPropertyName: "rounded", publicName: "rounded", isSignal: true, isRequired: false, transformFunction: null }, thumbnail: { classPropertyName: "thumbnail", publicName: "thumbnail", isSignal: true, isRequired: false, transformFunction: null }, placeholderColor: { classPropertyName: "placeholderColor", publicName: "placeholderColor", isSignal: true, isRequired: false, transformFunction: null } }, host: { properties: { "class": "hostClasses()", "style": "hostStyles()" } }, ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: ImgDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[cImg]',
                    host: {
                        '[class]': 'hostClasses()',
                        '[style]': 'hostStyles()'
                    }
                }]
        }] });

class ImgModule {
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: ImgModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
    static ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "20.3.2", ngImport: i0, type: ImgModule, imports: [ImgDirective], exports: [ImgDirective] });
    static ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: ImgModule });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: ImgModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [ImgDirective],
                    exports: [ImgDirective]
                }]
        }] });

class ListGroupDirective {
    static ngAcceptInputType_flush;
    /**
     * Remove some borders and rounded corners to render list group items edge-to-edge in a parent component (e.g., `<CCard>`).
     * @type boolean
     */
    flush = input(false, ...(ngDevMode ? [{ debugName: "flush", transform: booleanAttribute }] : [{ transform: booleanAttribute }]));
    /**
     * Specify horizontal layout type.
     */
    horizontal = input(...(ngDevMode ? [undefined, { debugName: "horizontal" }] : []));
    hostClasses = computed(() => {
        const horizontal = this.horizontal();
        return {
            'list-group': true,
            'list-group-horizontal': horizontal === true || horizontal === '',
            [`list-group-horizontal-${horizontal}`]: !!horizontal && typeof horizontal !== 'boolean',
            'list-group-flush': this.flush()
        };
    }, ...(ngDevMode ? [{ debugName: "hostClasses" }] : []));
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: ListGroupDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.1.0", version: "20.3.2", type: ListGroupDirective, isStandalone: true, selector: "[cListGroup]", inputs: { flush: { classPropertyName: "flush", publicName: "flush", isSignal: true, isRequired: false, transformFunction: null }, horizontal: { classPropertyName: "horizontal", publicName: "horizontal", isSignal: true, isRequired: false, transformFunction: null } }, host: { properties: { "class": "hostClasses()" }, classAttribute: "list-group" }, ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: ListGroupDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[cListGroup]',
                    host: {
                        class: 'list-group',
                        '[class]': 'hostClasses()'
                    }
                }]
        }] });

class ListGroupItemDirective {
    static ngAcceptInputType_active;
    static ngAcceptInputType_disabled;
    hostElement = inject(ElementRef);
    /**
     * Toggle the active state for the component.
     * @type InputSignalWithTransform<boolean, unknown>
     */
    active = input(false, ...(ngDevMode ? [{ debugName: "active", transform: booleanAttribute }] : [{ transform: booleanAttribute }]));
    /**
     * Sets the color context of the component to one of CoreUI’s themed colors.
     * @type InputSignal<boolean | undefined>
     */
    color = input(...(ngDevMode ? [undefined, { debugName: "color" }] : []));
    /**
     * Set disabled attr for the host element. [docs]
     * @type boolean
     */
    disabled = input(false, ...(ngDevMode ? [{ debugName: "disabled", transform: booleanAttribute }] : [{ transform: booleanAttribute }]));
    /**
     * The tabindex attribute specifies the tab order of an element (when the "tab" button is used for navigating).
     */
    tabindex = input(undefined, ...(ngDevMode ? [{ debugName: "tabindex", transform: numberAttribute }] : [{ transform: numberAttribute }]));
    hostClasses = computed(() => {
        const host = this.hostElement.nativeElement;
        return {
            'list-group-item': true,
            'list-group-item-action': host.nodeName === 'A' || host.nodeName === 'BUTTON',
            active: this.active(),
            disabled: this._disabled(),
            [`list-group-item-${this.color()}`]: !!this.color()
        };
    }, ...(ngDevMode ? [{ debugName: "hostClasses" }] : []));
    _disabled = computed(() => this.disabled(), ...(ngDevMode ? [{ debugName: "_disabled" }] : []));
    ariaDisabled = computed(() => {
        return this._disabled() ? true : null;
    }, ...(ngDevMode ? [{ debugName: "ariaDisabled" }] : []));
    attrDisabled = computed(() => {
        return this._disabled() ? '' : null;
    }, ...(ngDevMode ? [{ debugName: "attrDisabled" }] : []));
    tabIndex = computed(() => {
        return this._disabled() ? '-1' : (this.tabindex() ?? null);
    }, ...(ngDevMode ? [{ debugName: "tabIndex" }] : []));
    ariaCurrent = computed(() => {
        return this.active() || null;
    }, ...(ngDevMode ? [{ debugName: "ariaCurrent" }] : []));
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: ListGroupItemDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.1.0", version: "20.3.2", type: ListGroupItemDirective, isStandalone: true, selector: "[cListGroupItem], c-list-group-item", inputs: { active: { classPropertyName: "active", publicName: "active", isSignal: true, isRequired: false, transformFunction: null }, color: { classPropertyName: "color", publicName: "color", isSignal: true, isRequired: false, transformFunction: null }, disabled: { classPropertyName: "disabled", publicName: "disabled", isSignal: true, isRequired: false, transformFunction: null }, tabindex: { classPropertyName: "tabindex", publicName: "tabindex", isSignal: true, isRequired: false, transformFunction: null } }, host: { properties: { "class": "hostClasses()", "attr.aria-disabled": "ariaDisabled()", "attr.aria-current": "ariaCurrent()", "attr.disabled": "attrDisabled()", "attr.tabindex": "tabIndex()" } }, exportAs: ["cListGroupItem"], ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: ListGroupItemDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[cListGroupItem], c-list-group-item',
                    exportAs: 'cListGroupItem',
                    host: {
                        '[class]': 'hostClasses()',
                        '[attr.aria-disabled]': 'ariaDisabled()',
                        '[attr.aria-current]': 'ariaCurrent()',
                        '[attr.disabled]': 'attrDisabled()',
                        '[attr.tabindex]': 'tabIndex()'
                    }
                }]
        }] });

class ListGroupModule {
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: ListGroupModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
    static ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "20.3.2", ngImport: i0, type: ListGroupModule, imports: [ListGroupDirective, ListGroupItemDirective], exports: [ListGroupDirective, ListGroupItemDirective] });
    static ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: ListGroupModule });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: ListGroupModule, decorators: [{
            type: NgModule,
            args: [{
                    exports: [ListGroupDirective, ListGroupItemDirective],
                    imports: [ListGroupDirective, ListGroupItemDirective]
                }]
        }] });

class NavLinkDirective {
    static ngAcceptInputType_disabled;
    /**
     * Sets .nav-link class to the host. [docs]
     * @default true
     */
    cNavLink = input(true, ...(ngDevMode ? [{ debugName: "cNavLink", transform: booleanAttribute }] : [{ transform: booleanAttribute }]));
    /**
     * Toggle the active state for the component. [docs]
     * @default undefined
     */
    active = input(...(ngDevMode ? [undefined, { debugName: "active" }] : []));
    /**
     * Set disabled attr for the host element. [docs]
     * @default false
     */
    disabled = input(false, ...(ngDevMode ? [{ debugName: "disabled", transform: booleanAttribute }] : [{ transform: booleanAttribute }]));
    /**
     * The tabindex attribute specifies the tab order of an element (when the "tab" button is used for navigating).
     */
    tabindex = input(undefined, ...(ngDevMode ? [{ debugName: "tabindex", transform: numberAttribute }] : [{ transform: numberAttribute }]));
    ariaCurrent = computed(() => {
        return this.active() ? 'page' : null;
    }, ...(ngDevMode ? [{ debugName: "ariaCurrent" }] : []));
    ariaDisabled = null;
    attrDisabled = null;
    attrTabindex = null;
    styleCursor = null;
    #disabledEffect = effect(() => {
        const disabled = this.disabled();
        this.ariaDisabled = disabled || null;
        this.attrDisabled = disabled ? '' : null;
        this.attrTabindex = disabled ? -1 : (this.tabindex() ?? null);
        this.styleCursor = disabled ? null : 'pointer';
    }, ...(ngDevMode ? [{ debugName: "#disabledEffect" }] : []));
    hostClasses = computed(() => {
        return {
            'nav-link': this.cNavLink(),
            disabled: this.disabled(),
            active: this.active()
        };
    }, ...(ngDevMode ? [{ debugName: "hostClasses" }] : []));
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: NavLinkDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.1.0", version: "20.3.2", type: NavLinkDirective, isStandalone: true, selector: "[cNavLink]", inputs: { cNavLink: { classPropertyName: "cNavLink", publicName: "cNavLink", isSignal: true, isRequired: false, transformFunction: null }, active: { classPropertyName: "active", publicName: "active", isSignal: true, isRequired: false, transformFunction: null }, disabled: { classPropertyName: "disabled", publicName: "disabled", isSignal: true, isRequired: false, transformFunction: null }, tabindex: { classPropertyName: "tabindex", publicName: "tabindex", isSignal: true, isRequired: false, transformFunction: null } }, host: { properties: { "class": "hostClasses()", "attr.aria-current": "ariaCurrent()", "attr.aria-disabled": "ariaDisabled", "attr.disabled": "attrDisabled", "attr.tabindex": "attrTabindex", "style.cursor": "styleCursor" } }, ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: NavLinkDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[cNavLink]',
                    host: {
                        '[class]': 'hostClasses()',
                        '[attr.aria-current]': 'ariaCurrent()',
                        '[attr.aria-disabled]': 'ariaDisabled',
                        '[attr.disabled]': 'attrDisabled',
                        '[attr.tabindex]': 'attrTabindex',
                        '[style.cursor]': 'styleCursor'
                    }
                }]
        }] });

class NavItemComponent {
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: NavItemComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "20.3.2", type: NavItemComponent, isStandalone: true, selector: "c-nav-item", host: { classAttribute: "nav-item" }, ngImport: i0, template: '<ng-content />', isInline: true, styles: [":host{display:list-item;text-align:match-parent;text-align:-webkit-match-parent}\n"] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: NavItemComponent, decorators: [{
            type: Component,
            args: [{ selector: 'c-nav-item', template: '<ng-content />', host: { class: 'nav-item' }, styles: [":host{display:list-item;text-align:match-parent;text-align:-webkit-match-parent}\n"] }]
        }] });

class NavComponent {
    /**
     * Specify a layout type for component.
     * @default undefined
     */
    layout = input(...(ngDevMode ? [undefined, { debugName: "layout" }] : []));
    /**
     * Set the nav variant to tabs or pills.
     * @default undefined
     */
    variant = input(...(ngDevMode ? [undefined, { debugName: "variant" }] : []));
    hostClasses = computed(() => {
        const layout = this.layout();
        const variant = this.variant();
        return {
            nav: true,
            [`nav-${layout}`]: !!layout,
            [`nav-${variant}`]: !!variant
        };
    }, ...(ngDevMode ? [{ debugName: "hostClasses" }] : []));
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: NavComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.1.0", version: "20.3.2", type: NavComponent, isStandalone: true, selector: "c-nav", inputs: { layout: { classPropertyName: "layout", publicName: "layout", isSignal: true, isRequired: false, transformFunction: null }, variant: { classPropertyName: "variant", publicName: "variant", isSignal: true, isRequired: false, transformFunction: null } }, host: { properties: { "class": "hostClasses()" }, classAttribute: "nav" }, ngImport: i0, template: '<ng-content />', isInline: true, styles: [":host .nav-link:focus{outline:0}:host.nav-underline-border{column-gap:0}\n"] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: NavComponent, decorators: [{
            type: Component,
            args: [{ selector: 'c-nav', template: '<ng-content />', host: { class: 'nav', '[class]': 'hostClasses()' }, styles: [":host .nav-link:focus{outline:0}:host.nav-underline-border{column-gap:0}\n"] }]
        }] });

class NavModule {
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: NavModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
    static ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "20.3.2", ngImport: i0, type: NavModule, imports: [NavComponent,
            NavItemComponent,
            NavLinkDirective], exports: [NavComponent,
            NavItemComponent,
            NavLinkDirective] });
    static ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: NavModule });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: NavModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        NavComponent,
                        NavItemComponent,
                        NavLinkDirective
                    ],
                    exports: [
                        NavComponent,
                        NavItemComponent,
                        NavLinkDirective
                    ]
                }]
        }] });

// todo: fix container prop issue not rendering children
// todo: workaround -  use <c-container> component directly in template
class NavbarComponent {
    #breakpointObserver = inject(BreakpointObserver);
    #document = inject(DOCUMENT);
    #hostElement = inject(ElementRef);
    /**
     * Sets the color context of the component to one of CoreUI’s themed colors.
     * @type Colors
     */
    color = input(...(ngDevMode ? [undefined, { debugName: "color" }] : []));
    /**
     * Defines optional container wrapping children elements.
     */
    container = input(...(ngDevMode ? [undefined, { debugName: "container" }] : []));
    /**
     * Defines the responsive breakpoint to determine when content collapses.
     */
    expand = input(...(ngDevMode ? [undefined, { debugName: "expand" }] : []));
    /**
     * Place component in non-static positions.
     */
    placement = input(...(ngDevMode ? [undefined, { debugName: "placement" }] : []));
    role = input('navigation', ...(ngDevMode ? [{ debugName: "role" }] : []));
    collapse = contentChild(CollapseDirective, ...(ngDevMode ? [{ debugName: "collapse" }] : []));
    hostClasses = computed(() => {
        const color = this.color();
        const expand = this.expand();
        const expandClassSuffix = expand === true ? '' : `-${expand}`;
        const placement = this.placement();
        return {
            navbar: true,
            [`navbar-expand${expandClassSuffix}`]: !!expand,
            [`bg-${color}`]: !!color,
            [`${placement}`]: !!placement
        };
    }, ...(ngDevMode ? [{ debugName: "hostClasses" }] : []));
    containerClass = computed(() => {
        const container = this.container();
        return `container${container !== true ? '-' + container : ''}`;
    }, ...(ngDevMode ? [{ debugName: "containerClass" }] : []));
    computedStyle = signal('', ...(ngDevMode ? [{ debugName: "computedStyle" }] : []));
    #afterEveryRenderFn = afterEveryRender({
        read: () => {
            const expand = this.expand();
            if (typeof expand === 'string') {
                const computedStyle = this.#document.defaultView
                    ?.getComputedStyle(this.#hostElement.nativeElement)
                    ?.getPropertyValue(`--cui-breakpoint-${expand}`) ?? false;
                computedStyle && this.computedStyle.set(computedStyle);
            }
        }
    });
    breakpoint = computed(() => {
        const expand = this.expand();
        if (typeof expand === 'string') {
            return this.computedStyle();
        }
        return false;
    }, ...(ngDevMode ? [{ debugName: "breakpoint" }] : []));
    #observer;
    ngAfterContentInit() {
        const breakpoint = this.breakpoint();
        if (breakpoint) {
            const onBreakpoint = `(min-width: ${breakpoint})`;
            this.#observer = this.#breakpointObserver
                .observe([onBreakpoint])
                .pipe()
                .subscribe((result) => {
                const collapse = this.collapse();
                if (collapse) {
                    const animate = collapse.animate();
                    collapse.animate.set(false);
                    collapse.toggle(false);
                    setTimeout(() => {
                        collapse.toggle(result.matches);
                        setTimeout(() => {
                            collapse.animate.set(animate);
                        });
                    });
                }
            });
        }
    }
    ngOnDestroy() {
        this.#observer?.unsubscribe();
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: NavbarComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.2.0", version: "20.3.2", type: NavbarComponent, isStandalone: true, selector: "c-navbar", inputs: { color: { classPropertyName: "color", publicName: "color", isSignal: true, isRequired: false, transformFunction: null }, container: { classPropertyName: "container", publicName: "container", isSignal: true, isRequired: false, transformFunction: null }, expand: { classPropertyName: "expand", publicName: "expand", isSignal: true, isRequired: false, transformFunction: null }, placement: { classPropertyName: "placement", publicName: "placement", isSignal: true, isRequired: false, transformFunction: null }, role: { classPropertyName: "role", publicName: "role", isSignal: true, isRequired: false, transformFunction: null } }, host: { properties: { "class": "hostClasses()", "attr.role": "role()" } }, queries: [{ propertyName: "collapse", first: true, predicate: CollapseDirective, descendants: true, isSignal: true }], hostDirectives: [{ directive: ThemeDirective, inputs: ["colorScheme", "colorScheme"] }], ngImport: i0, template: "<ng-container *ngTemplateOutlet=\"container() ? withContainerTemplate : noContainerTemplate\" />\n\n<ng-template #withContainerTemplate>\n  <div [ngClass]=\"containerClass()\">\n    <ng-content />\n  </div>\n</ng-template>\n\n<ng-template #noContainerTemplate>\n  <ng-content />\n</ng-template>\n", dependencies: [{ kind: "directive", type: NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "directive", type: NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: NavbarComponent, decorators: [{
            type: Component,
            args: [{ selector: 'c-navbar', imports: [NgClass, NgTemplateOutlet], hostDirectives: [{ directive: ThemeDirective, inputs: ['colorScheme'] }], host: { '[class]': 'hostClasses()', '[attr.role]': 'role()' }, template: "<ng-container *ngTemplateOutlet=\"container() ? withContainerTemplate : noContainerTemplate\" />\n\n<ng-template #withContainerTemplate>\n  <div [ngClass]=\"containerClass()\">\n    <ng-content />\n  </div>\n</ng-template>\n\n<ng-template #noContainerTemplate>\n  <ng-content />\n</ng-template>\n" }]
        }] });

class NavbarBrandDirective {
    role = input('button', ...(ngDevMode ? [{ debugName: "role" }] : []));
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: NavbarBrandDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.1.0", version: "20.3.2", type: NavbarBrandDirective, isStandalone: true, selector: "[cNavbarBrand]", inputs: { role: { classPropertyName: "role", publicName: "role", isSignal: true, isRequired: false, transformFunction: null } }, host: { properties: { "attr.role": "role()" }, classAttribute: "navbar-brand" }, ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: NavbarBrandDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[cNavbarBrand]',
                    host: { class: 'navbar-brand', '[attr.role]': 'role()' }
                }]
        }] });

class NavbarNavComponent {
    /**
     * Enable vertical scrolling of a collapsed navbar toggleable contents.
     * @type boolean
     */
    scroll = input(false, ...(ngDevMode ? [{ debugName: "scroll", transform: booleanAttribute }] : [{ transform: booleanAttribute }]));
    hostClasses = computed(() => {
        return {
            'navbar-nav': true,
            'navbar-nav-scroll': this.scroll()
        };
    }, ...(ngDevMode ? [{ debugName: "hostClasses" }] : []));
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: NavbarNavComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.1.0", version: "20.3.2", type: NavbarNavComponent, isStandalone: true, selector: "c-navbar-nav", inputs: { scroll: { classPropertyName: "scroll", publicName: "scroll", isSignal: true, isRequired: false, transformFunction: null } }, host: { properties: { "class": "hostClasses()" } }, ngImport: i0, template: '<ng-content />', isInline: true });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: NavbarNavComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'c-navbar-nav',
                    template: '<ng-content />',
                    host: { '[class]': 'hostClasses()' }
                }]
        }] });

class NavbarTextComponent {
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: NavbarTextComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "20.3.2", type: NavbarTextComponent, isStandalone: true, selector: "c-navbar-text", host: { classAttribute: "navbar-text" }, ngImport: i0, template: '<ng-content />', isInline: true });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: NavbarTextComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'c-navbar-text',
                    template: '<ng-content />',
                    host: { class: 'navbar-text' }
                }]
        }] });

class NavbarTogglerDirective {
    #renderer = inject(Renderer2);
    #hostElement = inject(ElementRef);
    constructor() {
        afterNextRender({
            read: () => {
                const hasContent = this.#hostElement.nativeElement.childNodes.length;
                if (!hasContent) {
                    this.addDefaultIcon();
                }
            }
        });
    }
    /**
     * Reference to navbar collapse element (via # template variable) . [docs]
     * @type string
     * @default 'button'
     */
    collapseRef = input(undefined, ...(ngDevMode ? [{ debugName: "collapseRef", alias: 'cNavbarToggler' }] : [{ alias: 'cNavbarToggler' }]));
    /**
     * Default type for navbar-toggler. [docs]
     * @type string
     * @default 'button'
     */
    type = input('button', ...(ngDevMode ? [{ debugName: "type" }] : []));
    /**
     * Default aria-label attr for navbar-toggler. [docs]
     * @type string
     * @default 'Toggle navigation'
     */
    ariaLabel = input('Toggle navigation', ...(ngDevMode ? [{ debugName: "ariaLabel" }] : []));
    handleClick($event) {
        const collapseRef = this.collapseRef();
        collapseRef?.toggle(!collapseRef?.visible());
    }
    addDefaultIcon() {
        const span = this.#renderer.createElement('span');
        this.#renderer.addClass(span, 'navbar-toggler-icon');
        this.#renderer.appendChild(this.#hostElement.nativeElement, span);
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: NavbarTogglerDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.1.0", version: "20.3.2", type: NavbarTogglerDirective, isStandalone: true, selector: "[cNavbarToggler]", inputs: { collapseRef: { classPropertyName: "collapseRef", publicName: "cNavbarToggler", isSignal: true, isRequired: false, transformFunction: null }, type: { classPropertyName: "type", publicName: "type", isSignal: true, isRequired: false, transformFunction: null }, ariaLabel: { classPropertyName: "ariaLabel", publicName: "ariaLabel", isSignal: true, isRequired: false, transformFunction: null } }, host: { listeners: { "click": "handleClick($event)" }, properties: { "attr.aria-label": "ariaLabel()", "attr.type": "type()" }, classAttribute: "navbar-toggler" }, ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: NavbarTogglerDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[cNavbarToggler]',
                    host: {
                        '[attr.aria-label]': 'ariaLabel()',
                        '[attr.type]': 'type()',
                        class: 'navbar-toggler',
                        '(click)': 'handleClick($event)'
                    }
                }]
        }], ctorParameters: () => [] });

class NavbarModule {
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: NavbarModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
    static ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "20.3.2", ngImport: i0, type: NavbarModule, imports: [NavbarBrandDirective,
            NavbarComponent,
            NavbarNavComponent,
            NavbarTextComponent,
            NavbarTogglerDirective], exports: [NavbarBrandDirective,
            NavbarComponent,
            NavbarNavComponent,
            NavbarTextComponent,
            NavbarTogglerDirective] });
    static ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: NavbarModule });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: NavbarModule, decorators: [{
            type: NgModule,
            args: [{
                    exports: [
                        NavbarBrandDirective,
                        NavbarComponent,
                        NavbarNavComponent,
                        NavbarTextComponent,
                        NavbarTogglerDirective
                    ],
                    imports: [
                        NavbarBrandDirective,
                        NavbarComponent,
                        NavbarNavComponent,
                        NavbarTextComponent,
                        NavbarTogglerDirective
                    ]
                }]
        }] });

class ModalBodyComponent {
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: ModalBodyComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "20.3.2", type: ModalBodyComponent, isStandalone: true, selector: "c-modal-body", host: { classAttribute: "modal-body" }, ngImport: i0, template: '<ng-content />', isInline: true, styles: [":host{display:block}\n"] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: ModalBodyComponent, decorators: [{
            type: Component,
            args: [{ selector: 'c-modal-body', template: '<ng-content />', host: { class: 'modal-body' }, styles: [":host{display:block}\n"] }]
        }] });

class ModalContentComponent {
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: ModalContentComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "20.3.2", type: ModalContentComponent, isStandalone: true, selector: "c-modal-content", host: { classAttribute: "modal-content" }, ngImport: i0, template: '<ng-content />', isInline: true });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: ModalContentComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'c-modal-content',
                    template: '<ng-content />',
                    host: { class: 'modal-content' }
                }]
        }] });

class ModalDialogComponent {
    /**
     * Align the modal in the center or top of the screen.
     * @default undefined
     */
    alignment = input(...(ngDevMode ? [undefined, { debugName: "alignment" }] : []));
    /**
     * Set modal to covers the entire user viewport.
     * @return {boolean | 'sm' | 'md' | 'lg' | 'xl' | 'xxl'}
     */
    fullscreen = input(...(ngDevMode ? [undefined, { debugName: "fullscreen" }] : []));
    /**
     * Does the modal dialog itself scroll, or does the whole dialog scroll within the window.
     * @default false
     * @return {boolean}
     */
    scrollable = input(false, ...(ngDevMode ? [{ debugName: "scrollable", transform: booleanAttribute }] : [{ transform: booleanAttribute }]));
    /**
     * Size the component small, large, or extra large.
     * @default undefined
     * @return {'sm' | 'lg' | 'xl'}
     */
    size = input(...(ngDevMode ? [undefined, { debugName: "size" }] : []));
    hostClasses = computed(() => {
        const fullscreen = this.fullscreen();
        const size = this.size();
        return {
            'modal-dialog': true,
            'modal-dialog-centered': this.alignment() === 'center',
            'modal-fullscreen': fullscreen === true,
            [`modal-fullscreen-${fullscreen}-down`]: typeof fullscreen === 'string',
            'modal-dialog-scrollable': this.scrollable(),
            [`modal-${size}`]: !!size
        };
    }, ...(ngDevMode ? [{ debugName: "hostClasses" }] : []));
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: ModalDialogComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.1.0", version: "20.3.2", type: ModalDialogComponent, isStandalone: true, selector: "c-modal-dialog", inputs: { alignment: { classPropertyName: "alignment", publicName: "alignment", isSignal: true, isRequired: false, transformFunction: null }, fullscreen: { classPropertyName: "fullscreen", publicName: "fullscreen", isSignal: true, isRequired: false, transformFunction: null }, scrollable: { classPropertyName: "scrollable", publicName: "scrollable", isSignal: true, isRequired: false, transformFunction: null }, size: { classPropertyName: "size", publicName: "size", isSignal: true, isRequired: false, transformFunction: null } }, host: { properties: { "class": "hostClasses()" }, classAttribute: "modal-dialog" }, ngImport: i0, template: '<ng-content />', isInline: true, styles: [":host{display:block}:host.modal-dialog-centered{display:flex}\n"] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: ModalDialogComponent, decorators: [{
            type: Component,
            args: [{ selector: 'c-modal-dialog', template: '<ng-content />', host: { class: 'modal-dialog', '[class]': 'hostClasses()' }, styles: [":host{display:block}:host.modal-dialog-centered{display:flex}\n"] }]
        }] });

class ModalService {
    #modalState = new Subject();
    modalState$ = this.#modalState.asObservable();
    toggle(action) {
        this.#modalState.next(action);
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: ModalService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: ModalService, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: ModalService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root'
                }]
        }] });

class ModalToggleDirective {
    #modalService = inject(ModalService);
    /**
     * Html id attr of modal to dismiss.
     * @default undefined
     */
    toggle = input(undefined, ...(ngDevMode ? [{ debugName: "toggle", alias: 'cModalToggle' }] : [{ alias: 'cModalToggle' }]));
    dismiss($event) {
        $event.preventDefault();
        this.#modalService.toggle({ show: 'toggle', id: this.toggle() });
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: ModalToggleDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.1.0", version: "20.3.2", type: ModalToggleDirective, isStandalone: true, selector: "[cModalToggle]", inputs: { toggle: { classPropertyName: "toggle", publicName: "cModalToggle", isSignal: true, isRequired: false, transformFunction: null } }, host: { listeners: { "click": "dismiss($event)" } }, ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: ModalToggleDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[cModalToggle]',
                    host: {
                        '(click)': 'dismiss($event)'
                    }
                }]
        }] });

class ModalFooterComponent {
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: ModalFooterComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "20.3.2", type: ModalFooterComponent, isStandalone: true, selector: "c-modal-footer", host: { classAttribute: "modal-footer" }, ngImport: i0, template: '<ng-content />', isInline: true });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: ModalFooterComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'c-modal-footer',
                    template: '<ng-content />',
                    host: { class: 'modal-footer' }
                }]
        }] });

class ModalHeaderComponent {
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: ModalHeaderComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "20.3.2", type: ModalHeaderComponent, isStandalone: true, selector: "c-modal-header", host: { classAttribute: "modal-header" }, ngImport: i0, template: '<ng-content />', isInline: true });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: ModalHeaderComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'c-modal-header',
                    template: '<ng-content />',
                    host: { class: 'modal-header' }
                }]
        }] });

class ModalTitleDirective {
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: ModalTitleDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "20.3.2", type: ModalTitleDirective, isStandalone: true, selector: "[cModalTitle]", host: { classAttribute: "modal-title" }, ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: ModalTitleDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[cModalTitle]',
                    host: { class: 'modal-title' }
                }]
        }] });

class ModalComponent {
    #document = inject(DOCUMENT);
    #renderer = inject(Renderer2);
    #hostElement = inject(ElementRef);
    #modalService = inject(ModalService);
    #backdropService = inject(BackdropService);
    #destroyRef = inject(DestroyRef);
    #focusMonitor = inject(FocusMonitor);
    /**
     * Align the modal in the center or top of the screen.
     * @return {'top' | 'center'}
     * @default 'top'
     */
    alignment = input('top', ...(ngDevMode ? [{ debugName: "alignment" }] : []));
    /**
     * Apply a backdrop on body while modal is open.
     * @return boolean | 'static'
     * @default true
     */
    backdrop = input(true, ...(ngDevMode ? [{ debugName: "backdrop" }] : []));
    /**
     * Set modal to cover the entire user viewport.
     * @return {boolean | 'sm' | 'md' | 'lg' | 'xl' | 'xxl'}
     * @default undefined
     */
    fullscreen = input(...(ngDevMode ? [undefined, { debugName: "fullscreen" }] : []));
    /**
     * Closes the modal when escape key is pressed.
     * @return boolean
     * @default true
     */
    keyboard = input(true, ...(ngDevMode ? [{ debugName: "keyboard", transform: booleanAttribute }] : [{ transform: booleanAttribute }]));
    attrId = input(undefined, ...(ngDevMode ? [{ debugName: "attrId", alias: 'id' }] : [{ alias: 'id' }]));
    get id() {
        return this.attrId();
    }
    /**
     * Size the component small, large, or extra large.
     * @return {'sm' | 'lg' | 'xl'}
     * @default undefined
     */
    size = input(...(ngDevMode ? [undefined, { debugName: "size" }] : []));
    /**
     * Remove animation to create modal that simply appear rather than fade in to view.
     */
    transition = input(true, ...(ngDevMode ? [{ debugName: "transition", transform: booleanAttribute }] : [{ transform: booleanAttribute }]));
    /**
     * Default role for modal
     * @return string
     * @default 'dialog'
     */
    role = input('dialog', ...(ngDevMode ? [{ debugName: "role" }] : []));
    /**
     * Set aria-modal html attr for modal
     * @type boolean
     * @default null
     */
    ariaModalInput = input(false, ...(ngDevMode ? [{ debugName: "ariaModalInput", transform: booleanAttribute, alias: 'ariaModal' }] : [{ transform: booleanAttribute, alias: 'ariaModal' }]));
    ariaModal = computed(() => {
        return this.visible || this.ariaModalInput() ? true : null;
    }, ...(ngDevMode ? [{ debugName: "ariaModal" }] : []));
    /**
     * Create a scrollable modal that allows scrolling the modal body.
     * @return boolean
     * @default false
     */
    scrollable = input(false, ...(ngDevMode ? [{ debugName: "scrollable", transform: booleanAttribute }] : [{ transform: booleanAttribute }]));
    /**
     * Toggle the visibility of modal component.
     * @return boolean
     * @default false
     */
    visibleInput = input(false, ...(ngDevMode ? [{ debugName: "visibleInput", transform: booleanAttribute, alias: 'visible' }] : [{ transform: booleanAttribute, alias: 'visible' }]));
    #visibleInputEffect = effect(() => {
        const visible = this.visibleInput();
        untracked(() => {
            this.visible = visible;
        });
    }, ...(ngDevMode ? [{ debugName: "#visibleInputEffect" }] : []));
    set visible(value) {
        if (this.#visible() !== value) {
            this.#visible.set(value);
            this.setBodyStyles(value);
            this.setBackdrop(this.backdrop() !== false && value);
            this.visibleChange?.emit(value);
        }
    }
    get visible() {
        return this.#visible();
    }
    #visible = signal(false, ...(ngDevMode ? [{ debugName: "#visible" }] : []));
    #activeElement = signal(null, ...(ngDevMode ? [{ debugName: "#activeElement" }] : []));
    #visibleEffect = effect(() => {
        const visible = this.#visible();
        const afterViewInit = this.#afterViewInit();
        untracked(() => {
            if (visible && afterViewInit) {
                this.#activeElement.set(this.#document.activeElement);
                // this.#activeElement()?.blur();
                setTimeout(() => {
                    const focusable = this.modalContentRef()?.nativeElement.querySelectorAll('[tabindex]:not([tabindex="-1"]), button:not([disabled]), [href], input:not([disabled]), select:not([disabled]), textarea:not([disabled])');
                    if (focusable?.length) {
                        this.#focusMonitor.focusVia(focusable[0], 'keyboard');
                    }
                });
            }
            else {
                const activeElement = this.#activeElement();
                if (activeElement && this.#document.contains(activeElement)) {
                    this.#focusMonitor.focusVia(activeElement, 'keyboard');
                    setTimeout(() => {
                        // this.#activeElement()?.focus();
                        this.#activeElement.set(null);
                    });
                }
            }
        });
    }, ...(ngDevMode ? [{ debugName: "#visibleEffect" }] : []));
    /**
     * Event triggered on modal dismiss.
     * @return boolean
     */
    visibleChange = output();
    // @ViewChild(ModalContentComponent, { read: ElementRef }) modalContent!: ElementRef;
    // @ViewChild('modalContentRef', { read: ElementRef }) modalContentRef!: ElementRef;
    // readonly modalContentRef = viewChild(ModalContentComponent, { read: ElementRef });
    modalContentRef = viewChild('modalContentRef', ...(ngDevMode ? [{ debugName: "modalContentRef", read: ElementRef }] : [{ read: ElementRef }]));
    #activeBackdrop;
    // private inBoundingClientRect!: boolean;
    hostClasses = computed(() => {
        return {
            modal: true,
            fade: this.transition(),
            show: this.show
        };
    }, ...(ngDevMode ? [{ debugName: "hostClasses" }] : []));
    get ariaHidden() {
        return this.visible ? null : true;
    }
    animateTrigger = computed(() => {
        return this.visible ? 'visible' : 'hidden';
    }, ...(ngDevMode ? [{ debugName: "animateTrigger" }] : []));
    get show() {
        return this.visible && this.#show();
    }
    set show(value) {
        this.#show.set(value);
    }
    #show = signal(true, ...(ngDevMode ? [{ debugName: "#show" }] : []));
    animateStart(event) {
        if (event.toState === 'visible') {
            this.#backdropService.hideScrollbar();
            this.#renderer.setStyle(this.#hostElement.nativeElement, 'display', 'block');
        }
        else {
            if (!this.transition()) {
                this.#renderer.setStyle(this.#hostElement.nativeElement, 'display', 'none');
            }
        }
    }
    animateDone(event) {
        setTimeout(() => {
            if (event.toState === 'hidden') {
                this.#renderer.setStyle(this.#hostElement.nativeElement, 'display', 'none');
                this.#backdropService.resetScrollbar();
            }
        });
        this.show = this.visible;
    }
    onKeyUpHandler(event) {
        if (event.key === 'Escape' && this.keyboard() && this.visible) {
            if (this.backdrop() === 'static') {
                this.setStaticBackdrop();
            }
            else {
                this.#modalService.toggle({ show: false, modal: this });
            }
        }
    }
    mouseDownTarget = null;
    onMouseDownHandler($event) {
        this.mouseDownTarget = $event.target;
    }
    onClickHandler($event) {
        if (this.mouseDownTarget !== $event.target) {
            this.mouseDownTarget = null;
            return;
        }
        const targetElement = $event.target;
        if (targetElement === this.#hostElement.nativeElement) {
            if (this.backdrop() === 'static') {
                this.setStaticBackdrop();
                return;
            }
            this.#modalService.toggle({ show: false, modal: this });
        }
    }
    ngOnInit() {
        this.stateToggleSubscribe();
    }
    #afterViewInit = signal(false, ...(ngDevMode ? [{ debugName: "#afterViewInit" }] : []));
    ngAfterViewInit() {
        this.#afterViewInit.set(true);
    }
    ngOnDestroy() {
        this.#modalService.toggle({ show: false, modal: this });
        this.#afterViewInit.set(false);
    }
    stateToggleSubscribe() {
        this.#modalService.modalState$.pipe(takeUntilDestroyed(this.#destroyRef)).subscribe((action) => {
            if (this === action.modal || this.id === action.id) {
                if ('show' in action) {
                    this.visible = action?.show === 'toggle' ? !this.visible : action.show;
                }
            }
            else {
                if (this.visible) {
                    this.visible = false;
                }
            }
        });
    }
    setBackdrop(setBackdrop) {
        this.#activeBackdrop = setBackdrop
            ? this.#backdropService.setBackdrop('modal')
            : this.#backdropService.clearBackdrop(this.#activeBackdrop);
    }
    setBodyStyles(open) {
        if (open) {
            if (this.backdrop() === true) {
                this.#renderer.addClass(this.#document.body, 'modal-open');
            }
        }
        else {
            this.#renderer.removeClass(this.#document.body, 'modal-open');
        }
    }
    setStaticBackdrop() {
        if (this.transition()) {
            this.#renderer.addClass(this.#hostElement.nativeElement, 'modal-static');
            this.#renderer.setStyle(this.#hostElement.nativeElement, 'overflow-y', 'hidden');
            setTimeout(() => {
                this.#renderer.removeClass(this.#hostElement.nativeElement, 'modal-static');
                this.#renderer.removeStyle(this.#hostElement.nativeElement, 'overflow-y');
            }, 300);
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: ModalComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.2.0", version: "20.3.2", type: ModalComponent, isStandalone: true, selector: "c-modal", inputs: { alignment: { classPropertyName: "alignment", publicName: "alignment", isSignal: true, isRequired: false, transformFunction: null }, backdrop: { classPropertyName: "backdrop", publicName: "backdrop", isSignal: true, isRequired: false, transformFunction: null }, fullscreen: { classPropertyName: "fullscreen", publicName: "fullscreen", isSignal: true, isRequired: false, transformFunction: null }, keyboard: { classPropertyName: "keyboard", publicName: "keyboard", isSignal: true, isRequired: false, transformFunction: null }, attrId: { classPropertyName: "attrId", publicName: "id", isSignal: true, isRequired: false, transformFunction: null }, size: { classPropertyName: "size", publicName: "size", isSignal: true, isRequired: false, transformFunction: null }, transition: { classPropertyName: "transition", publicName: "transition", isSignal: true, isRequired: false, transformFunction: null }, role: { classPropertyName: "role", publicName: "role", isSignal: true, isRequired: false, transformFunction: null }, ariaModalInput: { classPropertyName: "ariaModalInput", publicName: "ariaModal", isSignal: true, isRequired: false, transformFunction: null }, scrollable: { classPropertyName: "scrollable", publicName: "scrollable", isSignal: true, isRequired: false, transformFunction: null }, visibleInput: { classPropertyName: "visibleInput", publicName: "visible", isSignal: true, isRequired: false, transformFunction: null } }, outputs: { visibleChange: "visibleChange" }, host: { listeners: { "@showHide.start": "animateStart($event)", "@showHide.done": "animateDone($event)", "mousedown": "onMouseDownHandler($event)", "click": "onClickHandler($event)", "document:keyup": "onKeyUpHandler($event)" }, properties: { "class": "hostClasses()", "attr.role": "role()", "attr.inert": "ariaHidden", "attr.id": "id", "attr.aria-modal": "ariaModal()", "attr.tabindex": "-1", "@showHide": "animateTrigger()" }, classAttribute: "modal" }, viewQueries: [{ propertyName: "modalContentRef", first: true, predicate: ["modalContentRef"], descendants: true, read: ElementRef, isSignal: true }], exportAs: ["cModal"], ngImport: i0, template: "<c-modal-dialog\n  [alignment]=\"alignment()\"\n  [fullscreen]=\"fullscreen()\"\n  [scrollable]=\"scrollable()\"\n  [size]=\"size()\">\n  <c-modal-content>\n    <div [cdkTrapFocus]=\"visible\" [cdkTrapFocusAutoCapture]=\"visible\" style=\"display: contents;\" #modalContentRef>\n      <ng-content />\n    </div>\n  </c-modal-content>\n</c-modal-dialog>\n", dependencies: [{ kind: "component", type: ModalDialogComponent, selector: "c-modal-dialog", inputs: ["alignment", "fullscreen", "scrollable", "size"] }, { kind: "component", type: ModalContentComponent, selector: "c-modal-content" }, { kind: "ngmodule", type: A11yModule }, { kind: "directive", type: i1$1.CdkTrapFocus, selector: "[cdkTrapFocus]", inputs: ["cdkTrapFocus", "cdkTrapFocusAutoCapture"], exportAs: ["cdkTrapFocus"] }], animations: [
            trigger('showHide', [
                state('visible', style({
                // display: 'block'
                })),
                state('hidden', style({
                // display: 'none'
                })),
                transition('visible <=> *', [animate('150ms')])
            ])
        ] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: ModalComponent, decorators: [{
            type: Component,
            args: [{ selector: 'c-modal', animations: [
                        trigger('showHide', [
                            state('visible', style({
                            // display: 'block'
                            })),
                            state('hidden', style({
                            // display: 'none'
                            })),
                            transition('visible <=> *', [animate('150ms')])
                        ])
                    ], exportAs: 'cModal', imports: [ModalDialogComponent, ModalContentComponent, A11yModule], host: {
                        class: 'modal',
                        '[class]': 'hostClasses()',
                        '[attr.role]': 'role()',
                        '[attr.inert]': 'ariaHidden',
                        '[attr.id]': 'id',
                        '[attr.aria-modal]': 'ariaModal()',
                        '[attr.tabindex]': '-1',
                        '[@showHide]': 'animateTrigger()',
                        '(@showHide.start)': 'animateStart($event)',
                        '(@showHide.done)': 'animateDone($event)',
                        '(mousedown)': 'onMouseDownHandler($event)',
                        '(click)': 'onClickHandler($event)',
                        '(document:keyup)': 'onKeyUpHandler($event)'
                    }, template: "<c-modal-dialog\n  [alignment]=\"alignment()\"\n  [fullscreen]=\"fullscreen()\"\n  [scrollable]=\"scrollable()\"\n  [size]=\"size()\">\n  <c-modal-content>\n    <div [cdkTrapFocus]=\"visible\" [cdkTrapFocusAutoCapture]=\"visible\" style=\"display: contents;\" #modalContentRef>\n      <ng-content />\n    </div>\n  </c-modal-content>\n</c-modal-dialog>\n" }]
        }] });

class ModalModule {
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: ModalModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
    static ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "20.3.2", ngImport: i0, type: ModalModule, imports: [ModalBodyComponent,
            ModalComponent,
            ModalContentComponent,
            ModalDialogComponent,
            ModalFooterComponent,
            ModalHeaderComponent,
            ModalTitleDirective,
            ModalToggleDirective], exports: [ModalBodyComponent,
            ModalComponent,
            ModalContentComponent,
            ModalDialogComponent,
            ModalFooterComponent,
            ModalHeaderComponent,
            ModalTitleDirective,
            ModalToggleDirective] });
    static ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: ModalModule, providers: [ModalService], imports: [ModalComponent] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: ModalModule, decorators: [{
            type: NgModule,
            args: [{
                    exports: [
                        ModalBodyComponent,
                        ModalComponent,
                        ModalContentComponent,
                        ModalDialogComponent,
                        ModalFooterComponent,
                        ModalHeaderComponent,
                        ModalTitleDirective,
                        ModalToggleDirective
                    ],
                    imports: [
                        ModalBodyComponent,
                        ModalComponent,
                        ModalContentComponent,
                        ModalDialogComponent,
                        ModalFooterComponent,
                        ModalHeaderComponent,
                        ModalTitleDirective,
                        ModalToggleDirective
                    ],
                    providers: [ModalService]
                }]
        }] });

class OffcanvasService {
    offcanvasState = new Subject();
    offcanvasState$ = this.offcanvasState.asObservable();
    toggle(action) {
        this.offcanvasState.next(action);
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: OffcanvasService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: OffcanvasService, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: OffcanvasService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root'
                }]
        }] });

let nextId$1 = 0;
class OffcanvasComponent {
    #document = inject(DOCUMENT);
    #platformId = inject(PLATFORM_ID);
    #renderer = inject(Renderer2);
    #hostElement = inject(ElementRef);
    #offcanvasService = inject(OffcanvasService);
    #backdropService = inject(BackdropService);
    #breakpointObserver = inject(BreakpointObserver);
    #destroyRef = inject(DestroyRef);
    /**
     * Apply a backdrop on body while offcanvas is open.
     * @return boolean | 'static'
     * @default true
     */
    backdrop = input(true, ...(ngDevMode ? [{ debugName: "backdrop" }] : []));
    /**
     * Closes the offcanvas when escape key is pressed [docs]
     * @return boolean
     * @default true
     */
    keyboard = input(true, ...(ngDevMode ? [{ debugName: "keyboard", transform: booleanAttribute }] : [{ transform: booleanAttribute }]));
    /**
     * Components placement, there’s no default placement.
     * @return {'start' | 'end' | 'top' | 'bottom'}
     * @default 'start'
     */
    placement = input('start', ...(ngDevMode ? [{ debugName: "placement" }] : []));
    /**
     * Responsive offcanvas property hides content outside the viewport from a specified breakpoint and down.
     * @return boolean | 'sm' | 'md' | 'lg' | 'xl' | 'xxl';
     * @default true
     * @since 4.3.10
     */
    responsive = input(true, ...(ngDevMode ? [{ debugName: "responsive" }] : []));
    id = input(`offcanvas-${this.placement()}-${nextId$1++}`, ...(ngDevMode ? [{ debugName: "id" }] : []));
    /**
     * Default role for offcanvas. [docs]
     * @return string
     * @default 'dialog'
     */
    role = input('dialog', ...(ngDevMode ? [{ debugName: "role" }] : []));
    /**
     * Set aria-modal html attr for offcanvas. [docs]
     * @return boolean
     * @default true
     */
    ariaModal = input(true, ...(ngDevMode ? [{ debugName: "ariaModal", transform: booleanAttribute }] : [{ transform: booleanAttribute }]));
    #activeBackdrop;
    #backdropClickSubscription;
    #layoutChangeSubscription;
    /**
     * Allow body scrolling while offcanvas is visible.
     * @return boolean
     * @default false
     */
    scroll = input(false, ...(ngDevMode ? [{ debugName: "scroll", transform: booleanAttribute }] : [{ transform: booleanAttribute }]));
    /**
     * Toggle the visibility of offcanvas component.
     * @return boolean
     * @default false
     */
    visibleInput = input(false, ...(ngDevMode ? [{ debugName: "visibleInput", transform: booleanAttribute, alias: 'visible' }] : [{ transform: booleanAttribute, alias: 'visible' }]));
    visible = linkedSignal({
        source: this.visibleInput,
        computation: (value) => value
    });
    visibleEffect = effect(() => {
        const visible = this.visible();
        if (visible) {
            this.setBackdrop(this.backdrop());
            this.setFocus();
        }
        else {
            this.setBackdrop(false);
        }
        this.layoutChangeSubscribe(visible);
        this.visibleChange?.emit(visible);
    }, ...(ngDevMode ? [{ debugName: "visibleEffect" }] : []));
    /**
     * Event triggered on visible change.
     * @return <boolean>
     */
    visibleChange = output();
    hostClasses = computed(() => {
        const responsive = this.responsive();
        const placement = this.placement();
        const visible = this.visible();
        return {
            offcanvas: typeof responsive === 'boolean',
            [`offcanvas-${responsive}`]: typeof responsive !== 'boolean',
            [`offcanvas-${placement}`]: !!placement,
            show: visible
        };
    }, ...(ngDevMode ? [{ debugName: "hostClasses" }] : []));
    ariaHidden = computed(() => {
        return this.visible() ? null : true;
    }, ...(ngDevMode ? [{ debugName: "ariaHidden" }] : []));
    get tabIndex() {
        return '-1';
    }
    get show() {
        return this.visible();
    }
    set show(value) {
        this.visible.set(value);
    }
    get responsiveBreakpoint() {
        const responsive = this.responsive();
        if (typeof responsive !== 'string') {
            return false;
        }
        const element = this.#document.documentElement;
        const breakpointValue = this.#document.defaultView
            ?.getComputedStyle(element)
            ?.getPropertyValue(`--cui-breakpoint-${responsive.trim()}`) ?? false;
        return breakpointValue ? `${parseFloat(breakpointValue.trim()) - 0.02}px` : false;
    }
    animateStart(event) {
        if (event.toState === 'visible') {
            if (!this.scroll()) {
                this.#backdropService.hideScrollbar();
            }
            this.#renderer.addClass(this.#hostElement.nativeElement, 'showing');
        }
        else {
            this.#renderer.addClass(this.#hostElement.nativeElement, 'hiding');
        }
    }
    animateDone(event) {
        setTimeout(() => {
            if (event.toState === 'visible') {
                this.#renderer.removeClass(this.#hostElement.nativeElement, 'showing');
            }
            if (event.toState === 'hidden') {
                this.#renderer.removeClass(this.#hostElement.nativeElement, 'hiding');
                this.#renderer.removeStyle(this.#document.body, 'overflow');
                this.#renderer.removeStyle(this.#document.body, 'paddingRight');
            }
        });
        this.show = this.visible();
    }
    onKeyDownHandler(event) {
        if (event.key === 'Escape' && this.keyboard() && this.visible() && this.backdrop() !== 'static') {
            this.#offcanvasService.toggle({ show: false, id: this.id() });
        }
    }
    ngOnInit() {
        this.stateToggleSubscribe();
        setTimeout(() => {
            // hotfix to avoid offcanvas flicker on the first render
            this.#renderer.setStyle(this.#hostElement.nativeElement, 'display', 'flex');
        });
    }
    ngOnDestroy() {
        this.#offcanvasService.toggle({ show: false, id: this.id() });
    }
    setFocus() {
        if (isPlatformBrowser(this.#platformId)) {
            setTimeout(() => this.#hostElement.nativeElement.focus());
        }
    }
    stateToggleSubscribe() {
        this.#offcanvasService.offcanvasState$.pipe(takeUntilDestroyed(this.#destroyRef)).subscribe((action) => {
            if (this === action.offcanvas || this.id() === action.id) {
                if ('show' in action) {
                    this.visible.update((value) => (action?.show === 'toggle' ? !value : action.show));
                }
            }
        });
    }
    backdropClickSubscribe(subscribe = true) {
        if (subscribe) {
            this.#backdropClickSubscription = this.#backdropService.backdropClick$
                .pipe(takeUntilDestroyed(this.#destroyRef))
                .subscribe((clicked) => {
                this.#offcanvasService.toggle({ show: !clicked, id: this.id() });
            });
        }
        else {
            this.#backdropClickSubscription?.unsubscribe();
        }
    }
    setBackdrop(setBackdrop) {
        this.#activeBackdrop = !!setBackdrop
            ? this.#backdropService.setBackdrop('offcanvas')
            : this.#backdropService.clearBackdrop(this.#activeBackdrop);
        setBackdrop === true ? this.backdropClickSubscribe() : this.backdropClickSubscribe(false);
    }
    layoutChangeSubscribe(subscribe = true) {
        if (subscribe) {
            if (!this.responsiveBreakpoint) {
                return;
            }
            const responsiveBreakpoint = `(max-width: ${this.responsiveBreakpoint})`;
            const layoutChanges = this.#breakpointObserver.observe([responsiveBreakpoint]);
            this.#layoutChangeSubscription = layoutChanges
                .pipe(filter((breakpointState) => !breakpointState.matches), takeUntilDestroyed(this.#destroyRef))
                .subscribe((breakpointState) => {
                this.visible.set(breakpointState.matches);
            });
        }
        else {
            this.#layoutChangeSubscription?.unsubscribe();
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: OffcanvasComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.1.0", version: "20.3.2", type: OffcanvasComponent, isStandalone: true, selector: "c-offcanvas", inputs: { backdrop: { classPropertyName: "backdrop", publicName: "backdrop", isSignal: true, isRequired: false, transformFunction: null }, keyboard: { classPropertyName: "keyboard", publicName: "keyboard", isSignal: true, isRequired: false, transformFunction: null }, placement: { classPropertyName: "placement", publicName: "placement", isSignal: true, isRequired: false, transformFunction: null }, responsive: { classPropertyName: "responsive", publicName: "responsive", isSignal: true, isRequired: false, transformFunction: null }, id: { classPropertyName: "id", publicName: "id", isSignal: true, isRequired: false, transformFunction: null }, role: { classPropertyName: "role", publicName: "role", isSignal: true, isRequired: false, transformFunction: null }, ariaModal: { classPropertyName: "ariaModal", publicName: "ariaModal", isSignal: true, isRequired: false, transformFunction: null }, scroll: { classPropertyName: "scroll", publicName: "scroll", isSignal: true, isRequired: false, transformFunction: null }, visibleInput: { classPropertyName: "visibleInput", publicName: "visible", isSignal: true, isRequired: false, transformFunction: null } }, outputs: { visibleChange: "visibleChange" }, host: { attributes: { "ngSkipHydration": "true" }, listeners: { "@showHide.start": "animateStart($event)", "@showHide.done": "animateDone($event)", "document:keydown": "onKeyDownHandler($event)" }, properties: { "@showHide": "this.visible() ? \"visible\" : \"hidden\"", "attr.id": "id()", "attr.inert": "ariaHidden() || null", "attr.role": "role()", "attr.aria-modal": "ariaModal()", "attr.tabindex": "tabIndex", "class": "hostClasses()" } }, exportAs: ["cOffcanvas"], hostDirectives: [{ directive: ThemeDirective, inputs: ["dark", "dark"] }], ngImport: i0, template: "<div cdkTrapFocus cdkTrapFocusAutoCapture>\n  <ng-content />\n</div>\n\n", styles: [":host{display:none}\n"], dependencies: [{ kind: "ngmodule", type: A11yModule }, { kind: "directive", type: i1$1.CdkTrapFocus, selector: "[cdkTrapFocus]", inputs: ["cdkTrapFocus", "cdkTrapFocusAutoCapture"], exportAs: ["cdkTrapFocus"] }], animations: [
            trigger('showHide', [
                state('visible', style({
                // visibility: 'visible'
                })),
                state('hidden', style({
                // visibility: 'hidden'
                })),
                transition('visible <=> *', [animate('300ms')])
            ])
        ] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: OffcanvasComponent, decorators: [{
            type: Component,
            args: [{ selector: 'c-offcanvas', animations: [
                        trigger('showHide', [
                            state('visible', style({
                            // visibility: 'visible'
                            })),
                            state('hidden', style({
                            // visibility: 'hidden'
                            })),
                            transition('visible <=> *', [animate('300ms')])
                        ])
                    ], exportAs: 'cOffcanvas', imports: [A11yModule], hostDirectives: [{ directive: ThemeDirective, inputs: ['dark'] }], host: {
                        ngSkipHydration: 'true',
                        '[@showHide]': 'this.visible() ? "visible" : "hidden"',
                        '[attr.id]': 'id()',
                        '[attr.inert]': 'ariaHidden() || null',
                        '[attr.role]': 'role()',
                        '[attr.aria-modal]': 'ariaModal()',
                        '[attr.tabindex]': 'tabIndex',
                        '[class]': 'hostClasses()',
                        '(@showHide.start)': 'animateStart($event)',
                        '(@showHide.done)': 'animateDone($event)',
                        '(document:keydown)': 'onKeyDownHandler($event)'
                    }, template: "<div cdkTrapFocus cdkTrapFocusAutoCapture>\n  <ng-content />\n</div>\n\n", styles: [":host{display:none}\n"] }]
        }] });

class OffcanvasBodyComponent {
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: OffcanvasBodyComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "20.3.2", type: OffcanvasBodyComponent, isStandalone: true, selector: "c-offcanvas-body", host: { classAttribute: "offcanvas-body" }, ngImport: i0, template: '<ng-content />', isInline: true, styles: [":host{display:block}\n"] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: OffcanvasBodyComponent, decorators: [{
            type: Component,
            args: [{ selector: 'c-offcanvas-body', template: '<ng-content />', host: { class: 'offcanvas-body' }, styles: [":host{display:block}\n"] }]
        }] });

class OffcanvasHeaderComponent {
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: OffcanvasHeaderComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "20.3.2", type: OffcanvasHeaderComponent, isStandalone: true, selector: "c-offcanvas-header", host: { classAttribute: "offcanvas-header" }, ngImport: i0, template: '<ng-content />', isInline: true });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: OffcanvasHeaderComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'c-offcanvas-header',
                    template: '<ng-content />',
                    host: { class: 'offcanvas-header' }
                }]
        }] });

class OffcanvasTitleDirective {
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: OffcanvasTitleDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "20.3.2", type: OffcanvasTitleDirective, isStandalone: true, selector: "[cOffcanvasTitle]", host: { classAttribute: "offcanvas-title" }, ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: OffcanvasTitleDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[cOffcanvasTitle]',
                    host: { class: 'offcanvas-title' }
                }]
        }] });

class OffcanvasToggleDirective {
    #offcanvasService = inject(OffcanvasService);
    /**
     * Html id attr of offcanvas to toggle.
     * @return string
     */
    id = input(undefined, ...(ngDevMode ? [{ debugName: "id", alias: 'cOffcanvasToggle' }] : [{ alias: 'cOffcanvasToggle' }]));
    toggleOpen($event) {
        $event.preventDefault();
        this.#offcanvasService.toggle({ show: 'toggle', id: this.id() });
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: OffcanvasToggleDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.1.0", version: "20.3.2", type: OffcanvasToggleDirective, isStandalone: true, selector: "[cOffcanvasToggle]", inputs: { id: { classPropertyName: "id", publicName: "cOffcanvasToggle", isSignal: true, isRequired: false, transformFunction: null } }, host: { listeners: { "click": "toggleOpen($event)" } }, ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: OffcanvasToggleDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[cOffcanvasToggle]',
                    host: {
                        '(click)': 'toggleOpen($event)'
                    }
                }]
        }] });

class OffcanvasModule {
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: OffcanvasModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
    static ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "20.3.2", ngImport: i0, type: OffcanvasModule, imports: [OffcanvasBodyComponent,
            OffcanvasComponent,
            OffcanvasHeaderComponent,
            OffcanvasTitleDirective,
            OffcanvasToggleDirective], exports: [OffcanvasBodyComponent,
            OffcanvasComponent,
            OffcanvasHeaderComponent,
            OffcanvasTitleDirective,
            OffcanvasToggleDirective] });
    static ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: OffcanvasModule, providers: [
            OffcanvasService,
            BackdropService
        ], imports: [OffcanvasComponent] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: OffcanvasModule, decorators: [{
            type: NgModule,
            args: [{
                    exports: [
                        OffcanvasBodyComponent,
                        OffcanvasComponent,
                        OffcanvasHeaderComponent,
                        OffcanvasTitleDirective,
                        OffcanvasToggleDirective
                    ],
                    imports: [
                        OffcanvasBodyComponent,
                        OffcanvasComponent,
                        OffcanvasHeaderComponent,
                        OffcanvasTitleDirective,
                        OffcanvasToggleDirective
                    ],
                    providers: [
                        OffcanvasService,
                        BackdropService
                    ]
                }]
        }] });

class PageLinkDirective {
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: PageLinkDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "20.3.2", type: PageLinkDirective, isStandalone: true, selector: "[cPageLink]", host: { classAttribute: "page-link" }, ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: PageLinkDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[cPageLink]',
                    host: { class: 'page-link' }
                }]
        }] });

class PageItemDirective {
    #renderer = inject(Renderer2);
    /**
     * Toggle the active state for the component.
     * @return boolean
     */
    active = input(...(ngDevMode ? [undefined, { debugName: "active" }] : []));
    /**
     * Toggle the disabled state for the component.
     * @return boolean
     */
    disabled = input(...(ngDevMode ? [undefined, { debugName: "disabled" }] : []));
    ariaCurrent = computed(() => {
        return this.active() ? 'page' : null;
    }, ...(ngDevMode ? [{ debugName: "ariaCurrent" }] : []));
    hostClasses = computed(() => {
        return {
            'page-item': true,
            disabled: this.disabled(),
            active: this.active()
        };
    }, ...(ngDevMode ? [{ debugName: "hostClasses" }] : []));
    pageLinkElementRef = contentChild(PageLinkDirective, ...(ngDevMode ? [{ debugName: "pageLinkElementRef", read: ElementRef }] : [{ read: ElementRef }]));
    pageLinkElementRefEffect = effect(() => {
        const pageLinkElementRef = this.pageLinkElementRef();
        const disabled = this.disabled();
        if (!pageLinkElementRef) {
            return;
        }
        const pageLinkElement = pageLinkElementRef.nativeElement;
        if (disabled) {
            this.#renderer.setAttribute(pageLinkElement, 'aria-disabled', 'true');
            this.#renderer.setAttribute(pageLinkElement, 'tabindex', '-1');
        }
        else {
            this.#renderer.removeAttribute(pageLinkElement, 'aria-disabled');
            this.#renderer.removeAttribute(pageLinkElement, 'tabindex');
        }
    }, ...(ngDevMode ? [{ debugName: "pageLinkElementRefEffect" }] : []));
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: PageItemDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.2.0", version: "20.3.2", type: PageItemDirective, isStandalone: true, selector: "[cPageItem]", inputs: { active: { classPropertyName: "active", publicName: "active", isSignal: true, isRequired: false, transformFunction: null }, disabled: { classPropertyName: "disabled", publicName: "disabled", isSignal: true, isRequired: false, transformFunction: null } }, host: { properties: { "class": "hostClasses()", "attr.aria-current": "ariaCurrent()" }, classAttribute: "page-item" }, queries: [{ propertyName: "pageLinkElementRef", first: true, predicate: PageLinkDirective, descendants: true, read: ElementRef, isSignal: true }], ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: PageItemDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[cPageItem]',
                    host: {
                        class: 'page-item',
                        '[class]': 'hostClasses()',
                        '[attr.aria-current]': 'ariaCurrent()'
                    }
                }]
        }] });

class PageItemComponent extends PageItemDirective {
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: PageItemComponent, deps: null, target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "20.3.2", type: PageItemComponent, isStandalone: true, selector: "c-page-item", usesInheritance: true, ngImport: i0, template: '<ng-content />', isInline: true, styles: [":host{display:list-item;text-align:-webkit-match-parent;text-align:match-parent}\n"] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: PageItemComponent, decorators: [{
            type: Component,
            args: [{ selector: 'c-page-item', template: '<ng-content />', styles: [":host{display:list-item;text-align:-webkit-match-parent;text-align:match-parent}\n"] }]
        }] });

class PaginationComponent {
    /**
     * Set the alignment of pagination components.
     * @values 'start', 'center', 'end'
     */
    align = input('', ...(ngDevMode ? [{ debugName: "align" }] : []));
    /**
     * Size the component small or large.
     * @values 'sm', 'lg'
     */
    size = input(...(ngDevMode ? [undefined, { debugName: "size" }] : []));
    /**
     * Default role for pagination. [docs]
     * @return string
     * @default 'navigation'
     */
    role = input('navigation', ...(ngDevMode ? [{ debugName: "role" }] : []));
    paginationClass = computed(() => {
        const size = this.size();
        const align = this.align();
        return {
            pagination: true,
            [`pagination-${size}`]: !!size,
            [`justify-content-${align}`]: !!align
        };
    }, ...(ngDevMode ? [{ debugName: "paginationClass" }] : []));
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: PaginationComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.1.0", version: "20.3.2", type: PaginationComponent, isStandalone: true, selector: "c-pagination", inputs: { align: { classPropertyName: "align", publicName: "align", isSignal: true, isRequired: false, transformFunction: null }, size: { classPropertyName: "size", publicName: "size", isSignal: true, isRequired: false, transformFunction: null }, role: { classPropertyName: "role", publicName: "role", isSignal: true, isRequired: false, transformFunction: null } }, host: { properties: { "attr.role": "role()" } }, ngImport: i0, template: "<ul [ngClass]=\"paginationClass()\">\n  <ng-content />\n</ul>\n", dependencies: [{ kind: "directive", type: NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: PaginationComponent, decorators: [{
            type: Component,
            args: [{ selector: 'c-pagination', imports: [NgClass], host: {
                        '[attr.role]': 'role()'
                    }, template: "<ul [ngClass]=\"paginationClass()\">\n  <ng-content />\n</ul>\n" }]
        }] });

class PaginationModule {
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: PaginationModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
    static ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "20.3.2", ngImport: i0, type: PaginationModule, imports: [PageItemComponent,
            PageItemDirective,
            PageLinkDirective,
            PaginationComponent], exports: [PageItemComponent,
            PageItemDirective,
            PageLinkDirective,
            PaginationComponent] });
    static ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: PaginationModule });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: PaginationModule, decorators: [{
            type: NgModule,
            args: [{
                    exports: [
                        PageItemComponent,
                        PageItemDirective,
                        PageLinkDirective,
                        PaginationComponent
                    ],
                    imports: [
                        PageItemComponent,
                        PageItemDirective,
                        PageLinkDirective,
                        PaginationComponent
                    ]
                }]
        }] });

class PlaceholderDirective {
    /**
     * placeholder toggler
     * @type boolean
     * @default false
     */
    visible = input(false, ...(ngDevMode ? [{ debugName: "visible", transform: booleanAttribute,
            alias: 'cPlaceholder' }] : [{
            transform: booleanAttribute,
            alias: 'cPlaceholder'
        }]));
    /**
     * Size the placeholder xs, small, large.
     */
    size = input(undefined, ...(ngDevMode ? [{ debugName: "size", alias: 'cPlaceholderSize' }] : [{ alias: 'cPlaceholderSize' }]));
    ariaHidden = computed(() => {
        return this.visible() ? null : true;
    }, ...(ngDevMode ? [{ debugName: "ariaHidden" }] : []));
    hostClasses = computed(() => {
        return {
            placeholder: this.visible(),
            [`placeholder-${this.size()}`]: !!this.size()
        };
    }, ...(ngDevMode ? [{ debugName: "hostClasses" }] : []));
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: PlaceholderDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.1.0", version: "20.3.2", type: PlaceholderDirective, isStandalone: true, selector: "[cPlaceholder]", inputs: { visible: { classPropertyName: "visible", publicName: "cPlaceholder", isSignal: true, isRequired: false, transformFunction: null }, size: { classPropertyName: "size", publicName: "cPlaceholderSize", isSignal: true, isRequired: false, transformFunction: null } }, host: { properties: { "class": "hostClasses()", "attr.aria-hidden": "ariaHidden()" } }, exportAs: ["cPlaceholder"], ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: PlaceholderDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[cPlaceholder]',
                    exportAs: 'cPlaceholder',
                    host: {
                        '[class]': 'hostClasses()',
                        '[attr.aria-hidden]': 'ariaHidden()'
                    }
                }]
        }] });

class PlaceholderAnimationDirective {
    /**
     * Animation type for placeholder
     * @type 'glow' | 'wave'
     * @default undefined
     */
    animation = input(undefined, ...(ngDevMode ? [{ debugName: "animation", alias: 'cPlaceholderAnimation' }] : [{
            alias: 'cPlaceholderAnimation'
        }]));
    placeholder = contentChild(PlaceholderDirective, ...(ngDevMode ? [{ debugName: "placeholder" }] : []));
    hostClasses = computed(() => {
        return {
            [`placeholder-${this.animation()}`]: this.placeholder()?.visible() && !!this.animation()
        };
    }, ...(ngDevMode ? [{ debugName: "hostClasses" }] : []));
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: PlaceholderAnimationDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.2.0", version: "20.3.2", type: PlaceholderAnimationDirective, isStandalone: true, selector: "[cPlaceholderAnimation]", inputs: { animation: { classPropertyName: "animation", publicName: "cPlaceholderAnimation", isSignal: true, isRequired: false, transformFunction: null } }, host: { properties: { "class": "hostClasses()" } }, queries: [{ propertyName: "placeholder", first: true, predicate: PlaceholderDirective, descendants: true, isSignal: true }], ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: PlaceholderAnimationDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[cPlaceholderAnimation]',
                    host: {
                        '[class]': 'hostClasses()'
                    }
                }]
        }] });

class PlaceholderModule {
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: PlaceholderModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
    static ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "20.3.2", ngImport: i0, type: PlaceholderModule, imports: [PlaceholderDirective,
            PlaceholderAnimationDirective], exports: [PlaceholderDirective,
            PlaceholderAnimationDirective] });
    static ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: PlaceholderModule });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: PlaceholderModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        PlaceholderDirective,
                        PlaceholderAnimationDirective
                    ],
                    exports: [
                        PlaceholderDirective,
                        PlaceholderAnimationDirective
                    ]
                }]
        }] });

class PopoverComponent {
    renderer = inject(Renderer2);
    /**
     * Content of popover
     * @return {string | TemplateRef}
     */
    content = input('', ...(ngDevMode ? [{ debugName: "content" }] : []));
    #contentEffect = effect(() => {
        this.updateView(this.content());
    }, ...(ngDevMode ? [{ debugName: "#contentEffect" }] : []));
    /**
     * Toggle the visibility of popover component.
     * @return boolean
     */
    visible = input(false, ...(ngDevMode ? [{ debugName: "visible", transform: booleanAttribute }] : [{ transform: booleanAttribute }]));
    id = input(...(ngDevMode ? [undefined, { debugName: "id" }] : []));
    role = input('tooltip', ...(ngDevMode ? [{ debugName: "role" }] : []));
    viewContainerRef = viewChild('popoverTemplate', ...(ngDevMode ? [{ debugName: "viewContainerRef", read: ViewContainerRef }] : [{ read: ViewContainerRef }]));
    textNode;
    hostClasses = computed(() => {
        return {
            popover: true,
            fade: true,
            show: this.visible(),
            'bs-popover-auto': true
        };
    }, ...(ngDevMode ? [{ debugName: "hostClasses" }] : []));
    ngOnDestroy() {
        this.clear();
    }
    clear() {
        this.viewContainerRef()?.clear();
        if (!!this.textNode) {
            this.renderer.removeChild(this.textNode.parentNode, this.textNode);
        }
    }
    updateView(content) {
        this.clear();
        if (!content) {
            return;
        }
        if (content instanceof TemplateRef) {
            this.viewContainerRef()?.createEmbeddedView(content);
        }
        else {
            const textNodeContent = this.renderer.createText(content);
            this.textNode = this.renderer.createElement('div');
            this.renderer.addClass(this.textNode, 'popover-body');
            this.renderer.appendChild(this.textNode, textNodeContent);
            const element = this.viewContainerRef()?.element.nativeElement;
            this.renderer.appendChild(element.parentNode, this.textNode);
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: PopoverComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.2.0", version: "20.3.2", type: PopoverComponent, isStandalone: true, selector: "c-popover", inputs: { content: { classPropertyName: "content", publicName: "content", isSignal: true, isRequired: false, transformFunction: null }, visible: { classPropertyName: "visible", publicName: "visible", isSignal: true, isRequired: false, transformFunction: null }, id: { classPropertyName: "id", publicName: "id", isSignal: true, isRequired: false, transformFunction: null }, role: { classPropertyName: "role", publicName: "role", isSignal: true, isRequired: false, transformFunction: null } }, host: { properties: { "class": "hostClasses()", "attr.role": "role()", "attr.id": "id()" }, classAttribute: "popover fade bs-popover-auto" }, viewQueries: [{ propertyName: "viewContainerRef", first: true, predicate: ["popoverTemplate"], descendants: true, read: ViewContainerRef, isSignal: true }], ngImport: i0, template: "<ng-container>\n  <div [ngClass]=\"{'popover-arrow': !!content()}\" data-popper-arrow></div>\n  <ng-container #popoverTemplate />\n</ng-container>\n", dependencies: [{ kind: "directive", type: NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: PopoverComponent, decorators: [{
            type: Component,
            args: [{ selector: 'c-popover', imports: [NgClass], host: {
                        class: 'popover fade bs-popover-auto',
                        '[class]': 'hostClasses()',
                        '[attr.role]': 'role()',
                        '[attr.id]': 'id()'
                    }, template: "<ng-container>\n  <div [ngClass]=\"{'popover-arrow': !!content()}\" data-popper-arrow></div>\n  <ng-container #popoverTemplate />\n</ng-container>\n" }]
        }] });

class PopoverDirective {
    #renderer = inject(Renderer2);
    #hostElement = inject(ElementRef);
    #viewContainerRef = inject(ViewContainerRef);
    #listenersService = inject(ListenersService);
    #changeDetectorRef = inject(ChangeDetectorRef);
    #intersectionService = inject(IntersectionService);
    #destroyRef = inject(DestroyRef);
    #document = inject(DOCUMENT);
    /**
     * Content of popover
     * @return {string | TemplateRef}
     */
    content = input(undefined, ...(ngDevMode ? [{ debugName: "content", alias: 'cPopover' }] : [{ alias: 'cPopover' }]));
    #contentEffect = effect(() => {
        if (this.content()) {
            this.destroyTooltipElement();
        }
    }, ...(ngDevMode ? [{ debugName: "#contentEffect" }] : []));
    /**
     * Optional popper Options object, takes precedence over cPopoverPlacement prop
     * @return Partial<Options>
     */
    popperOptions = input({}, ...(ngDevMode ? [{ debugName: "popperOptions", alias: 'cPopoverOptions' }] : [{ alias: 'cPopoverOptions' }]));
    #popperOptionsEffect = effect(() => {
        this._popperOptions = {
            ...this._popperOptions,
            placement: this.placement(),
            ...this.popperOptions()
        };
    }, ...(ngDevMode ? [{ debugName: "#popperOptionsEffect" }] : []));
    popperOptionsComputed = computed(() => {
        return { placement: this.placement(), ...this._popperOptions };
    }, ...(ngDevMode ? [{ debugName: "popperOptionsComputed" }] : []));
    /**
     * Describes the placement of your component after Popper.js has applied all the modifiers that may have flipped or altered the originally provided placement property.
     * @return: 'top' | 'bottom' | 'left' | 'right'
     * @default: 'top'
     */
    placement = input('top', ...(ngDevMode ? [{ debugName: "placement", alias: 'cPopoverPlacement' }] : [{ alias: 'cPopoverPlacement' }]));
    /**
     * ElementRefDirective for positioning the tooltip on reference element
     * @return: ElementRefDirective
     * @default: undefined
     */
    reference = input(undefined, ...(ngDevMode ? [{ debugName: "reference", alias: 'cTooltipRef' }] : [{ alias: 'cTooltipRef' }]));
    referenceRef = computed(() => this.reference()?.elementRef ?? this.#hostElement, ...(ngDevMode ? [{ debugName: "referenceRef" }] : []));
    /**
     * Sets which event handlers you’d like provided to your toggle prop. You can specify one trigger or an array of them.
     * @return: Triggers | Triggers[]
     */
    trigger = input('hover', ...(ngDevMode ? [{ debugName: "trigger", alias: 'cPopoverTrigger' }] : [{ alias: 'cPopoverTrigger' }]));
    /**
     * Toggle the visibility of popover component.
     * @return boolean
     */
    visible = model(false, ...(ngDevMode ? [{ debugName: "visible", alias: 'cPopoverVisible' }] : [{ alias: 'cPopoverVisible' }]));
    #visibleEffect = afterRenderEffect({
        // this fixes RuntimeError: NG0500: During hydration Angular expected <abc> but found <xyz>.
        // Find more at https://angular.dev/errors/NG0500
        write: () => {
            this.visible() ? this.addTooltipElement() : this.removeTooltipElement();
        }
    });
    get ariaDescribedBy() {
        return this.tooltipId ? this.tooltipId : null;
    }
    tooltip;
    tooltipId;
    tooltipRef;
    popperInstance;
    _popperOptions = {
        modifiers: [
            {
                name: 'offset',
                options: {
                    offset: [0, 9]
                }
            }
        ]
    };
    ngAfterViewInit() {
        this.intersectionServiceSubscribe();
    }
    ngOnDestroy() {
        this.clearListeners();
        this.destroyTooltipElement();
    }
    ngOnInit() {
        this.setListeners();
    }
    setListeners() {
        const config = {
            hostElement: this.#hostElement,
            trigger: this.trigger(),
            callbackToggle: () => {
                this.visible.update((visible) => !visible);
            },
            callbackOff: () => {
                this.visible.set(false);
            },
            callbackOn: () => {
                this.visible.set(true);
            }
        };
        this.#listenersService.setListeners(config);
    }
    clearListeners() {
        this.#listenersService.clearListeners();
    }
    intersectionServiceSubscribe() {
        this.#intersectionService.createIntersectionObserver(this.referenceRef());
        this.#intersectionService.intersecting$
            .pipe(filter((next) => next.hostElement === this.referenceRef()), debounceTime(100), finalize(() => {
            this.#intersectionService.unobserve(this.referenceRef());
        }), takeUntilDestroyed(this.#destroyRef))
            .subscribe((next) => {
            this.visible.set(next.isIntersecting ? this.visible() : false);
        });
    }
    getUID(prefix) {
        let uid = prefix ?? 'random-id';
        do {
            uid = `${prefix}-${Math.floor(Math.random() * 1000000).toString(10)}`;
        } while (this.#document.getElementById(uid));
        return uid;
    }
    createTooltipElement() {
        if (!this.tooltipRef) {
            this.tooltipRef = this.#viewContainerRef.createComponent(PopoverComponent);
            // this.viewContainerRef.detach();
        }
    }
    destroyTooltipElement() {
        this.tooltip?.remove();
        this.tooltipRef?.destroy();
        // @ts-ignore
        this.tooltipRef = undefined;
        this.popperInstance?.destroy();
        this.#viewContainerRef?.detach();
        this.#viewContainerRef?.clear();
    }
    addTooltipElement() {
        if (!this.content()) {
            this.destroyTooltipElement();
            return;
        }
        if (!this.tooltipRef) {
            this.createTooltipElement();
        }
        this.tooltipRef?.setInput('content', this.content() ?? '');
        this.tooltip = this.tooltipRef?.location.nativeElement;
        this.#renderer.addClass(this.tooltip, 'd-none');
        this.#renderer.addClass(this.tooltip, 'fade');
        this.popperInstance?.destroy();
        this.#viewContainerRef.insert(this.tooltipRef.hostView);
        this.#renderer.appendChild(this.#document.body, this.tooltip);
        this.popperInstance = createPopper(this.referenceRef().nativeElement, this.tooltip, {
            ...this.popperOptionsComputed()
        });
        if (!this.visible()) {
            this.removeTooltipElement();
            return;
        }
        setTimeout(() => {
            this.tooltipId = this.getUID('popover');
            this.tooltipRef?.setInput('id', this.tooltipId);
            this.#renderer.removeClass(this.tooltip, 'd-none');
            this.tooltipRef?.setInput('visible', this.visible());
            this.popperInstance?.forceUpdate();
            this.#changeDetectorRef?.markForCheck();
        }, 100);
    }
    removeTooltipElement() {
        this.tooltipId = '';
        if (!this.tooltipRef) {
            return;
        }
        this.tooltipRef.setInput('visible', false);
        this.tooltipRef.setInput('id', undefined);
        this.#changeDetectorRef.markForCheck();
        setTimeout(() => {
            this.#viewContainerRef?.detach();
        }, 300);
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: PopoverDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.1.0", version: "20.3.2", type: PopoverDirective, isStandalone: true, selector: "[cPopover]", inputs: { content: { classPropertyName: "content", publicName: "cPopover", isSignal: true, isRequired: false, transformFunction: null }, popperOptions: { classPropertyName: "popperOptions", publicName: "cPopoverOptions", isSignal: true, isRequired: false, transformFunction: null }, placement: { classPropertyName: "placement", publicName: "cPopoverPlacement", isSignal: true, isRequired: false, transformFunction: null }, reference: { classPropertyName: "reference", publicName: "cTooltipRef", isSignal: true, isRequired: false, transformFunction: null }, trigger: { classPropertyName: "trigger", publicName: "cPopoverTrigger", isSignal: true, isRequired: false, transformFunction: null }, visible: { classPropertyName: "visible", publicName: "cPopoverVisible", isSignal: true, isRequired: false, transformFunction: null } }, outputs: { visible: "cPopoverVisibleChange" }, host: { properties: { "attr.aria-describedby": "ariaDescribedBy" } }, providers: [ListenersService, IntersectionService], exportAs: ["cPopover"], ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: PopoverDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[cPopover]',
                    exportAs: 'cPopover',
                    providers: [ListenersService, IntersectionService],
                    host: { '[attr.aria-describedby]': 'ariaDescribedBy' }
                }]
        }] });

class PopoverModule {
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: PopoverModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
    static ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "20.3.2", ngImport: i0, type: PopoverModule, imports: [PopoverDirective,
            PopoverComponent], exports: [PopoverDirective,
            PopoverComponent] });
    static ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: PopoverModule });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: PopoverModule, decorators: [{
            type: NgModule,
            args: [{
                    exports: [
                        PopoverDirective,
                        PopoverComponent
                    ],
                    imports: [
                        PopoverDirective,
                        PopoverComponent
                    ]
                }]
        }] });

class ProgressService {
    stacked = signal(false, ...(ngDevMode ? [{ debugName: "stacked" }] : []));
    value = signal(undefined, ...(ngDevMode ? [{ debugName: "value" }] : []));
    precision = signal(0, ...(ngDevMode ? [{ debugName: "precision" }] : []));
    min = signal(0, ...(ngDevMode ? [{ debugName: "min" }] : []));
    max = signal(100, ...(ngDevMode ? [{ debugName: "max" }] : []));
    percent = computed(() => {
        return +((((this.value() ?? 0) - this.min()) / (this.max() - this.min())) * 100).toFixed(this.precision());
    }, ...(ngDevMode ? [{ debugName: "percent" }] : []));
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: ProgressService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: ProgressService });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: ProgressService, decorators: [{
            type: Injectable
        }] });

class ProgressBarDirective {
    #renderer = inject(Renderer2);
    #hostElement = inject(ElementRef);
    #progressService = inject(ProgressService);
    #valuesEffect = effect(() => {
        const host = this.#hostElement.nativeElement;
        const value = this.#progressService.value();
        const percent = this.#progressService.percent();
        const stacked = this.#progressService.stacked();
        if (value === undefined) {
            for (const name of ['aria-valuenow', 'aria-valuemax', 'aria-valuemin', 'role']) {
                this.#renderer.removeAttribute(host, name);
            }
        }
        else {
            const { min, max } = this.#progressService;
            this.#renderer.setAttribute(host, 'aria-valuenow', String(value));
            this.#renderer.setAttribute(host, 'aria-valuemin', String(min()));
            this.#renderer.setAttribute(host, 'aria-valuemax', String(max()));
            this.#renderer.setAttribute(host, 'role', this.role());
        }
        const tagName = host.tagName;
        if (percent >= 0 && ((stacked && tagName === 'C-PROGRESS') || (!stacked && tagName !== 'C-PROGRESS'))) {
            this.#renderer.setStyle(host, 'width', `${percent}%`);
        }
        else {
            this.#renderer.removeStyle(host, 'width');
        }
    }, ...(ngDevMode ? [{ debugName: "#valuesEffect" }] : []));
    /**
     * Use to animate the stripes right to left via CSS3 animations.
     * @return boolean
     */
    animated = input(undefined, ...(ngDevMode ? [{ debugName: "animated", transform: booleanAttribute }] : [{ transform: booleanAttribute }]));
    /**
     * Sets the color context of the component to one of CoreUI’s themed colors.
     * @values 'primary', 'secondary', 'success', 'danger', 'warning', 'info', 'dark', 'light'
     */
    color = input(...(ngDevMode ? [undefined, { debugName: "color" }] : []));
    precision = input(0, ...(ngDevMode ? [{ debugName: "precision", transform: numberAttribute }] : [{ transform: numberAttribute }]));
    /**
     * The percent value the ProgressBar.
     * @return number
     * @default 0
     */
    value = input(0, ...(ngDevMode ? [{ debugName: "value", transform: numberAttribute }] : [{ transform: numberAttribute }]));
    /**
     * Set the progress bar variant to optional striped.
     * @values 'striped'
     * @default undefined
     */
    variant = input(...(ngDevMode ? [undefined, { debugName: "variant" }] : []));
    /**
     * The max value of the ProgressBar.
     * @return number
     * @default 100
     */
    max = input(100, ...(ngDevMode ? [{ debugName: "max", transform: numberAttribute }] : [{ transform: numberAttribute }]));
    /**
     * Set default html role attribute.
     * @return string
     */
    role = input('progressbar', ...(ngDevMode ? [{ debugName: "role" }] : []));
    #serviceEffect = effect(() => {
        this.#progressService.precision.set(this.precision());
        const max = this.max();
        this.#progressService.max.set(isNaN(max) || max <= 0 ? 100 : max);
        const value = this.value();
        this.#progressService.value.set(value && !isNaN(value) ? value : undefined);
    }, ...(ngDevMode ? [{ debugName: "#serviceEffect" }] : []));
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: ProgressBarDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.1.0", version: "20.3.2", type: ProgressBarDirective, isStandalone: true, selector: "[cProgressBar]", inputs: { animated: { classPropertyName: "animated", publicName: "animated", isSignal: true, isRequired: false, transformFunction: null }, color: { classPropertyName: "color", publicName: "color", isSignal: true, isRequired: false, transformFunction: null }, precision: { classPropertyName: "precision", publicName: "precision", isSignal: true, isRequired: false, transformFunction: null }, value: { classPropertyName: "value", publicName: "value", isSignal: true, isRequired: false, transformFunction: null }, variant: { classPropertyName: "variant", publicName: "variant", isSignal: true, isRequired: false, transformFunction: null }, max: { classPropertyName: "max", publicName: "max", isSignal: true, isRequired: false, transformFunction: null }, role: { classPropertyName: "role", publicName: "role", isSignal: true, isRequired: false, transformFunction: null } }, exportAs: ["cProgressBar"], ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: ProgressBarDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[cProgressBar]',
                    exportAs: 'cProgressBar'
                }]
        }] });

class ProgressBarComponent {
    #progressBarDirective = inject(ProgressBarDirective, { optional: true });
    hostClasses = computed(() => {
        const animated = this.#progressBarDirective?.animated();
        const color = this.#progressBarDirective?.color();
        const variant = this.#progressBarDirective?.variant();
        return {
            'progress-bar': true,
            'progress-bar-animated': !!animated,
            [`progress-bar-${variant}`]: !!variant,
            [`bg-${color}`]: !!color
        };
    }, ...(ngDevMode ? [{ debugName: "hostClasses" }] : []));
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: ProgressBarComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "20.3.2", type: ProgressBarComponent, isStandalone: true, selector: "c-progress-bar", host: { properties: { "class": "hostClasses()" }, classAttribute: "progress-bar" }, hostDirectives: [{ directive: ProgressBarDirective, inputs: ["animated", "animated", "color", "color", "max", "max", "role", "role", "value", "value", "variant", "variant"] }], ngImport: i0, template: '<ng-content />', isInline: true });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: ProgressBarComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'c-progress-bar',
                    template: '<ng-content />',
                    hostDirectives: [
                        {
                            directive: ProgressBarDirective,
                            inputs: ['animated', 'color', 'max', 'role', 'value', 'variant']
                        }
                    ],
                    host: { class: 'progress-bar', '[class]': 'hostClasses()' }
                }]
        }] });

class ProgressStackedComponent {
    stacked = input(true, ...(ngDevMode ? [{ debugName: "stacked" }] : []));
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: ProgressStackedComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.1.0", version: "20.3.2", type: ProgressStackedComponent, isStandalone: true, selector: "c-progress-stacked", inputs: { stacked: { classPropertyName: "stacked", publicName: "stacked", isSignal: true, isRequired: false, transformFunction: null } }, host: { properties: { "class.progress-stacked": "stacked()" } }, exportAs: ["cProgressStacked"], ngImport: i0, template: '<ng-content />', isInline: true, styles: [":host{display:flex}\n"] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: ProgressStackedComponent, decorators: [{
            type: Component,
            args: [{ selector: 'c-progress-stacked', exportAs: 'cProgressStacked', template: '<ng-content />', host: { '[class.progress-stacked]': 'stacked()' }, styles: [":host{display:flex}\n"] }]
        }] });

class ProgressComponent {
    #hostElement = inject(ElementRef);
    progressBarDirective = inject(ProgressBarDirective, {
        optional: true
    });
    #stacked = inject(ProgressStackedComponent, { optional: true })?.stacked() ?? false;
    #progressService = inject(ProgressService);
    constructor() {
        this.#progressService.stacked.set(this.#stacked);
    }
    stacked = this.#progressService.stacked;
    percent = this.#progressService.percent;
    barValue = this.#progressService.value;
    contentProgressBars = contentChildren(ProgressBarComponent, ...(ngDevMode ? [{ debugName: "contentProgressBars" }] : []));
    /**
     * Sets the height of the component. If you set that value the inner `<CProgressBar>` will automatically resize accordingly.
     * @return number
     */
    height = input(0, ...(ngDevMode ? [{ debugName: "height", transform: numberAttribute }] : [{ transform: numberAttribute }]));
    /**
     * Displays thin progress.
     * @return boolean
     */
    thin = input(false, ...(ngDevMode ? [{ debugName: "thin", transform: booleanAttribute }] : [{ transform: booleanAttribute }]));
    /**
     * Change the default color to white.
     * @return boolean
     */
    white = input(false, ...(ngDevMode ? [{ debugName: "white", transform: booleanAttribute }] : [{ transform: booleanAttribute }]));
    hostClasses = computed(() => {
        return {
            progress: true,
            'progress-thin': this.thin(),
            'progress-white': this.white()
        };
    }, ...(ngDevMode ? [{ debugName: "hostClasses" }] : []));
    hostStyle = computed(() => {
        const height = this.height();
        return !!height ? `${height}px` : (this.#hostElement?.nativeElement?.style?.height ?? undefined);
    }, ...(ngDevMode ? [{ debugName: "hostStyle" }] : []));
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: ProgressComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "20.3.2", type: ProgressComponent, isStandalone: true, selector: "c-progress", inputs: { height: { classPropertyName: "height", publicName: "height", isSignal: true, isRequired: false, transformFunction: null }, thin: { classPropertyName: "thin", publicName: "thin", isSignal: true, isRequired: false, transformFunction: null }, white: { classPropertyName: "white", publicName: "white", isSignal: true, isRequired: false, transformFunction: null } }, host: { properties: { "class": "hostClasses()", "style.height": "hostStyle()" }, classAttribute: "progress" }, providers: [ProgressService], queries: [{ propertyName: "contentProgressBars", predicate: ProgressBarComponent, isSignal: true }], exportAs: ["cProgress"], hostDirectives: [{ directive: ProgressBarDirective, inputs: ["animated", "animated", "color", "color", "max", "max", "role", "role", "value", "value", "variant", "variant"] }], ngImport: i0, template: "@if (contentProgressBars()?.length) {\n  <ng-container *ngTemplateOutlet=\"defaultContent\" />\n} @else {\n  @let pbd = progressBarDirective;\n  <c-progress-bar [animated]=\"pbd?.animated()\" [variant]=\"pbd?.variant()\" [color]=\"pbd?.color()\" [value]=\"barValue()\">\n    <ng-container *ngTemplateOutlet=\"defaultContent\" />\n  </c-progress-bar>\n}\n\n<ng-template #defaultContent>\n  <ng-content />\n</ng-template>\n\n", styles: [":host-context(.progress-stacked).progress{transition:var(--cui-progress-bar-transition)}\n"], dependencies: [{ kind: "component", type: ProgressBarComponent, selector: "c-progress-bar" }, { kind: "directive", type: NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: ProgressComponent, decorators: [{
            type: Component,
            args: [{ selector: 'c-progress', exportAs: 'cProgress', imports: [ProgressBarComponent, NgTemplateOutlet], hostDirectives: [
                        {
                            directive: ProgressBarDirective,
                            inputs: ['animated', 'color', 'max', 'role', 'value', 'variant']
                        }
                    ], host: {
                        class: 'progress',
                        '[class]': 'hostClasses()',
                        '[style.height]': 'hostStyle()'
                    }, providers: [ProgressService], template: "@if (contentProgressBars()?.length) {\n  <ng-container *ngTemplateOutlet=\"defaultContent\" />\n} @else {\n  @let pbd = progressBarDirective;\n  <c-progress-bar [animated]=\"pbd?.animated()\" [variant]=\"pbd?.variant()\" [color]=\"pbd?.color()\" [value]=\"barValue()\">\n    <ng-container *ngTemplateOutlet=\"defaultContent\" />\n  </c-progress-bar>\n}\n\n<ng-template #defaultContent>\n  <ng-content />\n</ng-template>\n\n", styles: [":host-context(.progress-stacked).progress{transition:var(--cui-progress-bar-transition)}\n"] }]
        }], ctorParameters: () => [] });

class ProgressModule {
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: ProgressModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
    static ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "20.3.2", ngImport: i0, type: ProgressModule, imports: [ProgressComponent,
            ProgressBarComponent,
            ProgressBarDirective,
            ProgressStackedComponent], exports: [ProgressComponent,
            ProgressBarComponent,
            ProgressBarDirective,
            ProgressStackedComponent] });
    static ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: ProgressModule });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: ProgressModule, decorators: [{
            type: NgModule,
            args: [{
                    exports: [
                        ProgressComponent,
                        ProgressBarComponent,
                        ProgressBarDirective,
                        ProgressStackedComponent
                    ],
                    imports: [
                        ProgressComponent,
                        ProgressBarComponent,
                        ProgressBarDirective,
                        ProgressStackedComponent
                    ]
                }]
        }] });

class SidebarService {
    sidebarState = new BehaviorSubject({});
    sidebarState$ = this.sidebarState.asObservable();
    toggle(action) {
        this.sidebarState.next(action);
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: SidebarService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: SidebarService, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: SidebarService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root'
                }]
        }] });

class SidebarBackdropService {
    #document = inject(DOCUMENT);
    #sidebarService = inject(SidebarService);
    #backdrop;
    renderer;
    #clickListener = () => {
        /* empty */
    };
    setBackdrop(sidebar) {
        const backdrop = this.#document.getElementsByClassName('sidebar-backdrop');
        // console.log(`sidebar-${this.id}`, ' setBackdrop', backdrop);
        if (backdrop.length === 0) {
            this.#backdrop = this.renderer.createElement('div');
            this.renderer.addClass(this.#backdrop, 'sidebar-backdrop');
            this.renderer.appendChild(this.#document.body, this.#backdrop);
            this.#clickListener = this.renderer.listen(this.#backdrop, 'click', (e) => {
                // console.log(`sidebar-${this.id}`, ' backdrop click', e);
                this.#sidebarService.toggle({ toggle: 'visible', sidebar });
            });
        }
        // console.log(this.backdrop, sidebar.sidebarState.mobile, sidebar.sidebarState.show);
        if (this.#backdrop && sidebar.sidebarState.mobile && sidebar.sidebarState.visible) {
            this.renderer.addClass(this.#backdrop, 'fade');
            this.renderer.addClass(this.#backdrop, 'show');
            // this.renderer.removeClass(this.backdrop, 'd-none');
        }
        else {
            this.renderer.removeClass(this.#backdrop, 'show');
            this.renderer.removeClass(this.#backdrop, 'fade');
            // this.renderer.addClass(this.backdrop, 'd-none');
        }
    }
    clearBackdrop() {
        if (this.#backdrop) {
            // clear backdrop click Listener
            this.#clickListener();
            // this.renderer.listen(this.backdrop, 'click', (e): void => {} );
            this.renderer.removeChild(this.#document.body, this.#backdrop);
            // @ts-ignore
            this.#backdrop = undefined;
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: SidebarBackdropService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: SidebarBackdropService, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: SidebarBackdropService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root'
                }]
        }] });

class SidebarComponent {
    #document = inject(DOCUMENT);
    #renderer = inject(Renderer2);
    #breakpointObserver = inject(BreakpointObserver);
    #sidebarService = inject(SidebarService);
    #backdropService = inject(SidebarBackdropService);
    #onMobile = false;
    #layoutChangeSubscription;
    #stateToggleSubscription;
    state = signal({
        sidebar: this
    }, ...(ngDevMode ? [{ debugName: "state" }] : []));
    #stateInitial = {
        narrow: false,
        visible: false,
        unfoldable: false
    };
    /**
     * Sets if the color of text should be colored for a light or dark background.
     * @return 'dark' | 'light'
     */
    colorScheme = input(...(ngDevMode ? [undefined, { debugName: "colorScheme" }] : []));
    /**
     * Sets html attribute id.
     * @return string
     */
    id = input(...(ngDevMode ? [undefined, { debugName: "id" }] : []));
    /**
     * Make sidebar narrow.
     * @return boolean
     * @default false
     */
    narrowInput = input(false, ...(ngDevMode ? [{ debugName: "narrowInput", transform: booleanAttribute, alias: 'narrow' }] : [{ transform: booleanAttribute, alias: 'narrow' }]));
    #narrow = linkedSignal(this.narrowInput);
    set narrow(value) {
        this.#narrow.set(value);
    }
    get narrow() {
        return this.#narrow();
    }
    /**
     * Set sidebar to overlaid variant.
     * @return boolean
     * @default false
     */
    overlaid = input(false, ...(ngDevMode ? [{ debugName: "overlaid", transform: booleanAttribute }] : [{ transform: booleanAttribute }]));
    /**
     * Components placement, there’s no default placement.
     * @return 'start' | 'end'
     */
    placement = input(...(ngDevMode ? [undefined, { debugName: "placement" }] : []));
    /**
     * Place sidebar in non-static positions.
     * @return 'fixed' | 'sticky'
     * @default 'fixed'
     */
    position = input('fixed', ...(ngDevMode ? [{ debugName: "position" }] : []));
    /**
     * Size the component small, large, or extra large.
     * @return 'sm' | 'lg' | 'xl'
     */
    size = input(...(ngDevMode ? [undefined, { debugName: "size" }] : []));
    /**
     * Expand narrowed sidebar on hover.
     * @type boolean
     * @default false
     */
    unfoldableInput = input(false, ...(ngDevMode ? [{ debugName: "unfoldableInput", transform: booleanAttribute, alias: 'unfoldable' }] : [{ transform: booleanAttribute, alias: 'unfoldable' }]));
    unfoldable = linkedSignal({
        source: this.unfoldableInput,
        computation: (value) => value
    });
    /**
     * Toggle the visibility of sidebar component.
     * @type boolean
     * @default false
     */
    visibleInput = input(false, ...(ngDevMode ? [{ debugName: "visibleInput", transform: booleanAttribute, alias: 'visible' }] : [{ transform: booleanAttribute, alias: 'visible' }]));
    #visible = linkedSignal(this.visibleInput);
    #visibleEffect = effect(() => {
        this.visibleChange?.emit(this.#visible());
    }, ...(ngDevMode ? [{ debugName: "#visibleEffect" }] : []));
    set visible(value) {
        this.#visible.set(value);
    }
    get visible() {
        return this.#visible();
    }
    /**
     * Event emitted on visibility change.
     * @return boolean
     */
    visibleChange = output();
    set sidebarState(value) {
        const newState = value;
        if ('toggle' in newState) {
            if (newState.toggle === 'visible') {
                newState.visible = !this.state().visible;
                this.#visible.set(newState.visible);
            }
            else if (newState.toggle === 'unfoldable') {
                newState.unfoldable = !this.state().unfoldable;
                this.unfoldable.set(newState.unfoldable);
            }
        }
        else {
            this.#visible.update((visible) => (newState.visible ?? visible) && !this.overlaid());
        }
        this.state.update((state) => ({ ...state, ...newState }));
        this.state().mobile && this.state().visible
            ? this.#backdropService.setBackdrop(this)
            : this.#backdropService.clearBackdrop();
    }
    get sidebarState() {
        return { ...this.state() };
    }
    get getMobileBreakpoint() {
        const element = this.#document.documentElement;
        const mobileBreakpoint = this.#document.defaultView?.getComputedStyle(element)?.getPropertyValue('--cui-mobile-breakpoint') ?? 'md';
        const breakpointValue = this.#document.defaultView
            ?.getComputedStyle(element)
            ?.getPropertyValue(`--cui-breakpoint-${mobileBreakpoint.trim()}`) ?? '768px';
        return `${parseFloat(breakpointValue.trim()) - 0.02}px`;
    }
    constructor() {
        this.#backdropService.renderer = this.#renderer;
    }
    hostClasses = computed(() => {
        const { mobile, visible } = { ...this.sidebarState };
        const unfoldable = this.unfoldable();
        const placement = this.placement();
        const colorScheme = this.colorScheme();
        const size = this.size();
        return {
            sidebar: true,
            'sidebar-fixed': this.position() === 'fixed' && !mobile,
            'sidebar-narrow': this.#narrow() && !unfoldable,
            'sidebar-narrow-unfoldable': unfoldable,
            'sidebar-overlaid': this.overlaid(),
            [`sidebar-${placement}`]: !!placement,
            [`sidebar-${colorScheme}`]: !!colorScheme,
            [`sidebar-${size}`]: !!size,
            show: visible,
            // show: visible && this.#onMobile, //todo: check
            hide: !visible
        };
    }, ...(ngDevMode ? [{ debugName: "hostClasses" }] : []));
    ngOnInit() {
        this.setInitialState();
        this.layoutChangeSubscribe();
        this.stateToggleSubscribe();
    }
    ngOnDestroy() {
        this.stateToggleSubscribe(false);
        this.layoutChangeSubscribe(false);
    }
    ngOnChanges(changes) {
        const oldStateMap = new Map(Object.entries(this.state()));
        const newStateMap = new Map();
        newStateMap.set('sidebar', this);
        const propList = ['visible', 'unfoldable', 'narrow'];
        for (const propName in changes) {
            if (propList.includes(propName)) {
                if (changes[propName] && !changes[propName].firstChange) {
                    const value = booleanAttribute(changes[propName].currentValue);
                    if (oldStateMap.get(propName) !== value) {
                        newStateMap.set(propName, value);
                    }
                }
            }
        }
        if (newStateMap.size > 1) {
            const state = Object.fromEntries(newStateMap.entries());
            this.#sidebarService.toggle(state);
        }
    }
    setInitialState() {
        this.#stateInitial = {
            narrow: this.#narrow(),
            visible: this.#visible(),
            unfoldable: this.unfoldable()
        };
        this.#sidebarService.toggle({
            ...this.#stateInitial,
            sidebar: this
        });
    }
    stateToggleSubscribe(subscribe = true) {
        if (subscribe) {
            this.#stateToggleSubscription = this.#sidebarService.sidebarState$.subscribe((state) => {
                if (this === state.sidebar || this.id() === state.id) {
                    this.sidebarState = { ...state };
                }
            });
        }
        else {
            this.#stateToggleSubscription?.unsubscribe();
        }
    }
    layoutChangeSubscribe(subscribe = true) {
        const onMobile = `(max-width: ${this.getMobileBreakpoint})`;
        if (subscribe) {
            const layoutChanges = this.#breakpointObserver.observe([onMobile]);
            this.#layoutChangeSubscription = layoutChanges.subscribe((result) => {
                const isOnMobile = result.breakpoints[onMobile];
                const isUnfoldable = isOnMobile ? false : this.unfoldable();
                if (this.#onMobile !== isOnMobile) {
                    this.#onMobile = isOnMobile;
                    this.#sidebarService.toggle({
                        mobile: isOnMobile,
                        unfoldable: isUnfoldable,
                        visible: isOnMobile ? !isOnMobile : this.#stateInitial.visible,
                        sidebar: this
                    });
                }
            });
        }
        else {
            this.#layoutChangeSubscription?.unsubscribe();
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: SidebarComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.1.0", version: "20.3.2", type: SidebarComponent, isStandalone: true, selector: "c-sidebar", inputs: { colorScheme: { classPropertyName: "colorScheme", publicName: "colorScheme", isSignal: true, isRequired: false, transformFunction: null }, id: { classPropertyName: "id", publicName: "id", isSignal: true, isRequired: false, transformFunction: null }, narrowInput: { classPropertyName: "narrowInput", publicName: "narrow", isSignal: true, isRequired: false, transformFunction: null }, overlaid: { classPropertyName: "overlaid", publicName: "overlaid", isSignal: true, isRequired: false, transformFunction: null }, placement: { classPropertyName: "placement", publicName: "placement", isSignal: true, isRequired: false, transformFunction: null }, position: { classPropertyName: "position", publicName: "position", isSignal: true, isRequired: false, transformFunction: null }, size: { classPropertyName: "size", publicName: "size", isSignal: true, isRequired: false, transformFunction: null }, unfoldableInput: { classPropertyName: "unfoldableInput", publicName: "unfoldable", isSignal: true, isRequired: false, transformFunction: null }, visibleInput: { classPropertyName: "visibleInput", publicName: "visible", isSignal: true, isRequired: false, transformFunction: null } }, outputs: { visibleChange: "visibleChange" }, host: { properties: { "class": "hostClasses()", "attr.inert": "!this.sidebarState.visible || null" }, classAttribute: "sidebar" }, exportAs: ["cSidebar"], usesOnChanges: true, ngImport: i0, template: '<ng-content />', isInline: true });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: SidebarComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'c-sidebar',
                    exportAs: 'cSidebar',
                    template: '<ng-content />',
                    host: {
                        class: 'sidebar',
                        '[class]': 'hostClasses()',
                        '[attr.inert]': '!this.sidebarState.visible || null'
                    }
                }]
        }], ctorParameters: () => [] });

class SidebarBrandComponent {
    brandFull = input(...(ngDevMode ? [undefined, { debugName: "brandFull" }] : []));
    brandNarrow = input(...(ngDevMode ? [undefined, { debugName: "brandNarrow" }] : []));
    routerLink = input(...(ngDevMode ? [undefined, { debugName: "routerLink" }] : []));
    brandImg = computed(() => Boolean(this.brandFull() || this.brandNarrow()), ...(ngDevMode ? [{ debugName: "brandImg" }] : []));
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: SidebarBrandComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "20.3.2", type: SidebarBrandComponent, isStandalone: true, selector: "c-sidebar-brand", inputs: { brandFull: { classPropertyName: "brandFull", publicName: "brandFull", isSignal: true, isRequired: false, transformFunction: null }, brandNarrow: { classPropertyName: "brandNarrow", publicName: "brandNarrow", isSignal: true, isRequired: false, transformFunction: null }, routerLink: { classPropertyName: "routerLink", publicName: "routerLink", isSignal: true, isRequired: false, transformFunction: null } }, host: { classAttribute: "sidebar-brand" }, ngImport: i0, template: "@if (brandImg()) {\n  <a [routerLink]=\"routerLink()\">\n    @if (brandFull()) {\n      <img [cHtmlAttr]=\"brandFull()\" [ngClass]=\"'sidebar-brand-full'\">\n    }\n    @if (brandNarrow()) {\n      <img [cHtmlAttr]=\"brandNarrow()\" [ngClass]=\"'sidebar-brand-narrow'\">\n    }\n  </a>\n} @else {\n  <ng-content />\n}\n", dependencies: [{ kind: "directive", type: RouterLink, selector: "[routerLink]", inputs: ["target", "queryParams", "fragment", "queryParamsHandling", "state", "info", "relativeTo", "preserveFragment", "skipLocationChange", "replaceUrl", "routerLink"] }, { kind: "directive", type: HtmlAttributesDirective, selector: "[cHtmlAttr]", inputs: ["cHtmlAttr"], exportAs: ["cHtmlAttr"] }, { kind: "directive", type: NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: SidebarBrandComponent, decorators: [{
            type: Component,
            args: [{ selector: 'c-sidebar-brand', imports: [RouterLink, HtmlAttributesDirective, NgClass], host: { class: 'sidebar-brand' }, template: "@if (brandImg()) {\n  <a [routerLink]=\"routerLink()\">\n    @if (brandFull()) {\n      <img [cHtmlAttr]=\"brandFull()\" [ngClass]=\"'sidebar-brand-full'\">\n    }\n    @if (brandNarrow()) {\n      <img [cHtmlAttr]=\"brandNarrow()\" [ngClass]=\"'sidebar-brand-narrow'\">\n    }\n  </a>\n} @else {\n  <ng-content />\n}\n" }]
        }] });

/**
 * Allows the sidebar to be toggled/folded via click on host element.
 */
class SidebarToggleDirective {
    #sidebarService = inject(SidebarService);
    /**
     * Id of sidebar for toggle action.
     * @return string
     */
    id = input(undefined, ...(ngDevMode ? [{ debugName: "id", alias: 'cSidebarToggle' }] : [{ alias: 'cSidebarToggle' }]));
    /**
     * Sidebar property name for toggle action.
     *
     * @return 'visible' | 'unfoldable'
     * @default 'visible'
     */
    toggle = input('visible', ...(ngDevMode ? [{ debugName: "toggle" }] : []));
    toggleOpen($event) {
        $event.preventDefault();
        this.#sidebarService.toggle({ toggle: this.toggle(), id: this.id() });
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: SidebarToggleDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.1.0", version: "20.3.2", type: SidebarToggleDirective, isStandalone: true, selector: "[cSidebarToggle]", inputs: { id: { classPropertyName: "id", publicName: "cSidebarToggle", isSignal: true, isRequired: false, transformFunction: null }, toggle: { classPropertyName: "toggle", publicName: "toggle", isSignal: true, isRequired: false, transformFunction: null } }, host: { listeners: { "click": "toggleOpen($event)" } }, exportAs: ["cSidebarToggle"], ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: SidebarToggleDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[cSidebarToggle]',
                    exportAs: 'cSidebarToggle',
                    host: {
                        '(click)': 'toggleOpen($event)'
                    }
                }]
        }] });

class SidebarTogglerDirective {
    role = input('button', ...(ngDevMode ? [{ debugName: "role" }] : []));
    get getStyles() {
        return {
            appearance: 'button',
            'align-items': 'flex-start',
            cursor: 'pointer'
        };
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: SidebarTogglerDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.1.0", version: "20.3.2", type: SidebarTogglerDirective, isStandalone: true, selector: "[cSidebarToggler]", inputs: { role: { classPropertyName: "role", publicName: "role", isSignal: true, isRequired: false, transformFunction: null } }, host: { properties: { "attr.role": "role()", "style": "getStyles" }, classAttribute: "sidebar-toggler" }, hostDirectives: [{ directive: SidebarToggleDirective, inputs: ["cSidebarToggle", "cSidebarToggler", "toggle", "toggle"] }], ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: SidebarTogglerDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[cSidebarToggler]',
                    hostDirectives: [{ directive: SidebarToggleDirective, inputs: ['cSidebarToggle: cSidebarToggler', 'toggle'] }],
                    host: {
                        '[attr.role]': 'role()',
                        class: 'sidebar-toggler',
                        '[style]': 'getStyles'
                    }
                }]
        }] });

class SidebarHeaderComponent {
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: SidebarHeaderComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "20.3.2", type: SidebarHeaderComponent, isStandalone: true, selector: "c-sidebar-header", host: { classAttribute: "sidebar-header" }, ngImport: i0, template: '<ng-content />', isInline: true });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: SidebarHeaderComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'c-sidebar-header',
                    template: '<ng-content />',
                    host: { class: 'sidebar-header' }
                }]
        }] });

class SidebarFooterComponent {
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: SidebarFooterComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "20.3.2", type: SidebarFooterComponent, isStandalone: true, selector: "c-sidebar-footer", host: { classAttribute: "sidebar-footer" }, ngImport: i0, template: '<ng-content />', isInline: true });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: SidebarFooterComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'c-sidebar-footer',
                    template: '<ng-content />',
                    host: { class: 'sidebar-footer' }
                }]
        }] });

class SidebarNavService {
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: SidebarNavService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: SidebarNavService });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: SidebarNavService, decorators: [{
            type: Injectable
        }] });
class SidebarNavHelper {
    itemType(item) {
        if (item.divider) {
            return 'divider';
        }
        else if (item.title) {
            return 'title';
        }
        else if (item.children && item.children.length > 0) {
            return 'group';
        }
        else if (item.label) {
            return 'label';
        }
        else if (!Object.keys(item).length) {
            return 'empty';
        }
        else {
            return 'link';
        }
    }
    isActive(router, item) {
        return router.isActive(item.url, false);
    }
    hasBadge = (item) => Boolean(item.badge);
    hasIcon = (item) => Boolean(item.icon) || item.icon === '';
    hasIconComponent = (item) => Boolean(item.iconComponent);
    getIconClass(item) {
        const classes = {
            'nav-icon': true
        };
        const icon = item.icon;
        // @ts-ignore
        classes[icon] = this.hasIcon(item);
        return classes;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: SidebarNavHelper, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: SidebarNavHelper });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: SidebarNavHelper, decorators: [{
            type: Injectable
        }] });

class SidebarNavGroupService {
    sidebarNavGroupState = new BehaviorSubject({});
    sidebarNavGroupState$ = this.sidebarNavGroupState.asObservable();
    toggle(action) {
        this.sidebarNavGroupState.next(action);
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: SidebarNavGroupService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: SidebarNavGroupService });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: SidebarNavGroupService, decorators: [{
            type: Injectable
        }] });

class SidebarNavIconPipe {
    transform(item, args) {
        const icon = item.icon;
        return {
            'nav-icon': true,
            [`${icon}`]: !!icon
        };
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: SidebarNavIconPipe, deps: [], target: i0.ɵɵFactoryTarget.Pipe });
    static ɵpipe = i0.ɵɵngDeclarePipe({ minVersion: "14.0.0", version: "20.3.2", ngImport: i0, type: SidebarNavIconPipe, isStandalone: true, name: "cSidebarNavIcon" });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: SidebarNavIconPipe, decorators: [{
            type: Pipe,
            args: [{
                    name: 'cSidebarNavIcon'
                }]
        }] });

class SidebarNavBadgePipe {
    transform(item, args) {
        const badge = item.badge;
        return {
            badge: true,
            'ms-auto': true,
            'badge-sm': !badge.size,
            [`badge-${badge.size}`]: !!badge.size,
            [`bg-${badge.color}`]: !!badge.color,
            [`${badge.class}`]: !!badge.class
        };
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: SidebarNavBadgePipe, deps: [], target: i0.ɵɵFactoryTarget.Pipe });
    static ɵpipe = i0.ɵɵngDeclarePipe({ minVersion: "14.0.0", version: "20.3.2", ngImport: i0, type: SidebarNavBadgePipe, isStandalone: true, name: "cSidebarNavBadge" });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: SidebarNavBadgePipe, decorators: [{
            type: Pipe,
            args: [{
                    name: 'cSidebarNavBadge'
                }]
        }] });

class SidebarNavLinkPipe {
    transform(item) {
        const disabled = item?.attributes?.disabled;
        return {
            'nav-link': true,
            disabled,
            'btn-link': disabled,
            [`nav-link-${item.variant}`]: !!item.variant
        };
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: SidebarNavLinkPipe, deps: [], target: i0.ɵɵFactoryTarget.Pipe });
    static ɵpipe = i0.ɵɵngDeclarePipe({ minVersion: "14.0.0", version: "20.3.2", ngImport: i0, type: SidebarNavLinkPipe, isStandalone: true, name: "cSidebarNavLink" });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: SidebarNavLinkPipe, decorators: [{
            type: Pipe,
            args: [{
                    name: 'cSidebarNavLink'
                }]
        }] });

class SidebarNavLinkContentComponent {
    helper = inject(SidebarNavHelper);
    item = input({}, ...(ngDevMode ? [{ debugName: "item" }] : []));
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: SidebarNavLinkContentComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "20.3.2", type: SidebarNavLinkContentComponent, isStandalone: true, selector: "c-sidebar-nav-link-content", inputs: { item: { classPropertyName: "item", publicName: "item", isSignal: true, isRequired: false, transformFunction: null } }, providers: [SidebarNavHelper], ngImport: i0, template: `
    @let itemLinkContent = item();
    @if (itemLinkContent) {
      <ng-container>{{ itemLinkContent?.name ?? '' }}</ng-container>
    }
  `, isInline: true });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: SidebarNavLinkContentComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'c-sidebar-nav-link-content',
                    template: `
    @let itemLinkContent = item();
    @if (itemLinkContent) {
      <ng-container>{{ itemLinkContent?.name ?? '' }}</ng-container>
    }
  `,
                    providers: [SidebarNavHelper]
                }]
        }] });
class SidebarNavLinkComponent {
    router = inject(Router);
    item = input(...(ngDevMode ? [undefined, { debugName: "item" }] : []));
    linkClick = output();
    linkType;
    href;
    linkActive;
    url;
    navigationEndObservable;
    navSubscription;
    constructor() {
        const router = this.router;
        this.navigationEndObservable = router.events.pipe(filter((event) => {
            return event instanceof NavigationEnd;
        }), takeUntilDestroyed());
    }
    ngOnInit() {
        const item = this.item() ?? {};
        this.url =
            typeof item.url === 'string'
                ? item.url
                : this.router.serializeUrl(this.router.createUrlTree(item.url ?? ['']));
        this.linkType = this.getLinkType();
        this.href = this.isDisabled() ? '' : item.href || this.url;
        this.linkActive = this.router.url.split(/[?#(;]/)[0] === this.href.split(/[?#(;]/)[0];
        this.navSubscription = this.navigationEndObservable.subscribe((event) => {
            const itemUrlArray = this.href.split(/[?#(;]/)[0].split('/');
            const urlArray = event.urlAfterRedirects.split(/[?#(;]/)[0].split('/');
            this.linkActive = itemUrlArray.every((value, index) => value === urlArray[index]);
        });
    }
    ngOnDestroy() {
        this.navSubscription?.unsubscribe();
    }
    getLinkType() {
        return this.isDisabled() ? 'disabled' : this.isExternalLink() ? 'external' : 'link';
    }
    isDisabled() {
        return this.item()?.attributes?.['disabled'];
    }
    isExternalLink() {
        const item = this.item() ?? {};
        const linkPath = Array.isArray(item.url) ? item.url[0] : item.url;
        return !!item.href || linkPath?.substring(0, 4) === 'http';
    }
    linkClicked() {
        this.linkClick?.emit();
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: SidebarNavLinkComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "20.3.2", type: SidebarNavLinkComponent, isStandalone: true, selector: "c-sidebar-nav-link", inputs: { item: { classPropertyName: "item", publicName: "item", isSignal: true, isRequired: false, transformFunction: null } }, outputs: { linkClick: "linkClick" }, providers: [SidebarNavHelper], ngImport: i0, template: "@let linkItem = item() ?? {};\n\n@switch (linkType) {\n  @case ('disabled') {\n    <a [cHtmlAttr]=\"linkItem.attributes ?? {}\" [ngClass]=\"linkItem | cSidebarNavLink\">\n      <ng-container *ngTemplateOutlet=\"iconTemplate; context: {$implicit: linkItem}\" />\n      <c-sidebar-nav-link-content [item]=\"linkItem\" />\n      @if (linkItem.badge) {\n        <span [ngClass]=\"linkItem | cSidebarNavBadge\">{{ linkItem.badge?.text }}</span>\n      }\n    </a>\n  }\n  @case ('external') {\n    <a (click)=\"linkClicked()\" [cHtmlAttr]=\"linkItem.attributes ?? {}\" [href]=\"href\" [ngClass]=\"linkItem | cSidebarNavLink\">\n      <ng-container *ngTemplateOutlet=\"iconTemplate; context: {$implicit: linkItem}\" />\n      <c-sidebar-nav-link-content [item]=\"linkItem\" />\n      @if (linkItem.badge) {\n        <span [ngClass]=\"linkItem | cSidebarNavBadge\">{{ linkItem.badge?.text }}</span>\n      }\n    </a>\n  }\n  @default {\n    <a (click)=\"linkClicked()\"\n       [cHtmlAttr]=\"linkItem.attributes ?? {}\"\n       [fragment]=\"linkItem.linkProps?.fragment\"\n       [ngClass]=\"linkItem | cSidebarNavLink\"\n       [preserveFragment]=\"linkItem.linkProps?.preserveFragment ?? false\"\n       [queryParamsHandling]=\"linkItem.linkProps?.queryParamsHandling\"\n       [queryParams]=\"linkItem.linkProps?.queryParams ?? null\"\n       [replaceUrl]=\"linkItem.linkProps?.replaceUrl ?? false\"\n       [routerLinkActiveOptions]=\"linkItem.linkProps?.routerLinkActiveOptions ?? { exact: false }\"\n       [routerLink]=\"linkItem.url\"\n       [skipLocationChange]=\"linkItem.linkProps?.skipLocationChange ?? false\"\n       [state]=\"linkItem.linkProps?.state ?? {}\"\n       [target]=\"linkItem.attributes?.['target']\"\n       routerLinkActive=\"active\"\n    >\n      <!--    [class.active]=\"linkActive\"-->\n      <ng-container *ngTemplateOutlet=\"iconTemplate ; context: {$implicit: linkItem}\" />\n      <c-sidebar-nav-link-content [item]=\"linkItem\" />\n      @if (linkItem.badge) {\n        <span [ngClass]=\"linkItem | cSidebarNavBadge\">{{ linkItem.badge?.text }}</span>\n      }\n    </a>\n  }\n}\n<ng-template #iconTemplate let-item>\n  <!--  <i *ngIf=\"item?.icon\" [ngClass]=\"item | cSidebarNavIcon\"></i>-->\n  @if (item?.icon) {\n    <span class=\"nav-icon\">\n      <span [ngClass]=\"item.icon ?? ''\"></span>\n    </span>\n  }\n  @if (item?.iconComponent) {\n    <svg\n      [cIcon]=\"item.iconComponent?.content\"\n      [customClasses]=\"item | cSidebarNavIcon\"\n      [name]=\"item.iconComponent?.name\"\n    ></svg>\n  }\n  @if (!item?.icon && !item?.iconComponent) {\n    <span [ngClass]=\"item | cSidebarNavIcon\"></span>\n  }\n</ng-template>\n", dependencies: [{ kind: "ngmodule", type: RouterModule }, { kind: "directive", type: i1.RouterLink, selector: "[routerLink]", inputs: ["target", "queryParams", "fragment", "queryParamsHandling", "state", "info", "relativeTo", "preserveFragment", "skipLocationChange", "replaceUrl", "routerLink"] }, { kind: "directive", type: i1.RouterLinkActive, selector: "[routerLinkActive]", inputs: ["routerLinkActiveOptions", "ariaCurrentWhenActive", "routerLinkActive"], outputs: ["isActiveChange"], exportAs: ["routerLinkActive"] }, { kind: "directive", type: HtmlAttributesDirective, selector: "[cHtmlAttr]", inputs: ["cHtmlAttr"], exportAs: ["cHtmlAttr"] }, { kind: "directive", type: IconDirective, selector: "svg[cIcon]", inputs: ["cIcon", "customClasses", "size", "title", "height", "width", "name", "viewBox", "xmlns", "pointer-events", "role"], exportAs: ["cIcon"] }, { kind: "component", type: SidebarNavLinkContentComponent, selector: "c-sidebar-nav-link-content", inputs: ["item"] }, { kind: "directive", type: NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }, { kind: "directive", type: NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "pipe", type: SidebarNavLinkPipe, name: "cSidebarNavLink" }, { kind: "pipe", type: SidebarNavBadgePipe, name: "cSidebarNavBadge" }, { kind: "pipe", type: SidebarNavIconPipe, name: "cSidebarNavIcon" }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: SidebarNavLinkComponent, decorators: [{
            type: Component,
            args: [{ selector: 'c-sidebar-nav-link', providers: [SidebarNavHelper], imports: [
                        RouterModule,
                        HtmlAttributesDirective,
                        IconDirective,
                        SidebarNavLinkContentComponent,
                        SidebarNavLinkPipe,
                        SidebarNavBadgePipe,
                        SidebarNavIconPipe,
                        NgTemplateOutlet,
                        NgClass
                    ], template: "@let linkItem = item() ?? {};\n\n@switch (linkType) {\n  @case ('disabled') {\n    <a [cHtmlAttr]=\"linkItem.attributes ?? {}\" [ngClass]=\"linkItem | cSidebarNavLink\">\n      <ng-container *ngTemplateOutlet=\"iconTemplate; context: {$implicit: linkItem}\" />\n      <c-sidebar-nav-link-content [item]=\"linkItem\" />\n      @if (linkItem.badge) {\n        <span [ngClass]=\"linkItem | cSidebarNavBadge\">{{ linkItem.badge?.text }}</span>\n      }\n    </a>\n  }\n  @case ('external') {\n    <a (click)=\"linkClicked()\" [cHtmlAttr]=\"linkItem.attributes ?? {}\" [href]=\"href\" [ngClass]=\"linkItem | cSidebarNavLink\">\n      <ng-container *ngTemplateOutlet=\"iconTemplate; context: {$implicit: linkItem}\" />\n      <c-sidebar-nav-link-content [item]=\"linkItem\" />\n      @if (linkItem.badge) {\n        <span [ngClass]=\"linkItem | cSidebarNavBadge\">{{ linkItem.badge?.text }}</span>\n      }\n    </a>\n  }\n  @default {\n    <a (click)=\"linkClicked()\"\n       [cHtmlAttr]=\"linkItem.attributes ?? {}\"\n       [fragment]=\"linkItem.linkProps?.fragment\"\n       [ngClass]=\"linkItem | cSidebarNavLink\"\n       [preserveFragment]=\"linkItem.linkProps?.preserveFragment ?? false\"\n       [queryParamsHandling]=\"linkItem.linkProps?.queryParamsHandling\"\n       [queryParams]=\"linkItem.linkProps?.queryParams ?? null\"\n       [replaceUrl]=\"linkItem.linkProps?.replaceUrl ?? false\"\n       [routerLinkActiveOptions]=\"linkItem.linkProps?.routerLinkActiveOptions ?? { exact: false }\"\n       [routerLink]=\"linkItem.url\"\n       [skipLocationChange]=\"linkItem.linkProps?.skipLocationChange ?? false\"\n       [state]=\"linkItem.linkProps?.state ?? {}\"\n       [target]=\"linkItem.attributes?.['target']\"\n       routerLinkActive=\"active\"\n    >\n      <!--    [class.active]=\"linkActive\"-->\n      <ng-container *ngTemplateOutlet=\"iconTemplate ; context: {$implicit: linkItem}\" />\n      <c-sidebar-nav-link-content [item]=\"linkItem\" />\n      @if (linkItem.badge) {\n        <span [ngClass]=\"linkItem | cSidebarNavBadge\">{{ linkItem.badge?.text }}</span>\n      }\n    </a>\n  }\n}\n<ng-template #iconTemplate let-item>\n  <!--  <i *ngIf=\"item?.icon\" [ngClass]=\"item | cSidebarNavIcon\"></i>-->\n  @if (item?.icon) {\n    <span class=\"nav-icon\">\n      <span [ngClass]=\"item.icon ?? ''\"></span>\n    </span>\n  }\n  @if (item?.iconComponent) {\n    <svg\n      [cIcon]=\"item.iconComponent?.content\"\n      [customClasses]=\"item | cSidebarNavIcon\"\n      [name]=\"item.iconComponent?.name\"\n    ></svg>\n  }\n  @if (!item?.icon && !item?.iconComponent) {\n    <span [ngClass]=\"item | cSidebarNavIcon\"></span>\n  }\n</ng-template>\n" }]
        }], ctorParameters: () => [] });

class SidebarNavLabelComponent {
    helper = inject(SidebarNavHelper);
    item = input({}, ...(ngDevMode ? [{ debugName: "item" }] : []));
    itemClass = computed(() => {
        const classes = {
            'c-nav-label': true,
            'c-active': true
        };
        const itemClass = this.item().class;
        if (itemClass) {
            classes[itemClass] = !!itemClass;
        }
        return classes;
    }, ...(ngDevMode ? [{ debugName: "itemClass" }] : []));
    labelIconClass = computed(() => {
        const item = this.item();
        const iconClasses = this.helper.getIconClass(item);
        const variant = `text-${item.label?.variant}`;
        iconClasses[variant] = !!item.label?.variant;
        const labelClass = item.label?.class ?? '';
        iconClasses[labelClass] = !!labelClass;
        return iconClasses;
    }, ...(ngDevMode ? [{ debugName: "labelIconClass" }] : []));
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: SidebarNavLabelComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "20.3.2", type: SidebarNavLabelComponent, isStandalone: true, selector: "c-sidebar-nav-label", inputs: { item: { classPropertyName: "item", publicName: "item", isSignal: true, isRequired: false, transformFunction: null } }, ngImport: i0, template: "@let labelItem = item();\n<a [cHtmlAttr]=\"labelItem.attributes\"\n   [ngClass]=\"itemClass()\"\n   href=\"{{labelItem.url}}\">\n  @if (helper.hasIcon(labelItem)) {\n    <i [ngClass]=\"labelIconClass()\"></i>\n  }\n  <ng-container>{{ labelItem.name }}</ng-container>\n  @if (helper.hasBadge(labelItem)) {\n    <span [ngClass]=\"labelItem | cSidebarNavBadge\">{{ labelItem.badge?.text ?? '' }}</span>\n  }\n</a>\n", dependencies: [{ kind: "directive", type: HtmlAttributesDirective, selector: "[cHtmlAttr]", inputs: ["cHtmlAttr"], exportAs: ["cHtmlAttr"] }, { kind: "directive", type: NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "pipe", type: SidebarNavBadgePipe, name: "cSidebarNavBadge" }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: SidebarNavLabelComponent, decorators: [{
            type: Component,
            args: [{ selector: 'c-sidebar-nav-label', imports: [HtmlAttributesDirective, SidebarNavBadgePipe, NgClass], template: "@let labelItem = item();\n<a [cHtmlAttr]=\"labelItem.attributes\"\n   [ngClass]=\"itemClass()\"\n   href=\"{{labelItem.url}}\">\n  @if (helper.hasIcon(labelItem)) {\n    <i [ngClass]=\"labelIconClass()\"></i>\n  }\n  <ng-container>{{ labelItem.name }}</ng-container>\n  @if (helper.hasBadge(labelItem)) {\n    <span [ngClass]=\"labelItem | cSidebarNavBadge\">{{ labelItem.badge?.text ?? '' }}</span>\n  }\n</a>\n" }]
        }] });

class SidebarNavTitleComponent {
    #elementRef = inject(ElementRef);
    #renderer = inject(Renderer2);
    item = input(...(ngDevMode ? [undefined, { debugName: "item" }] : []));
    #itemEffect = effect(() => {
        const item = this.item();
        if (item?.name) {
            const nativeElement = this.#elementRef.nativeElement;
            const name = this.#renderer.createText(item.name);
            if (item?.class) {
                const classes = item.class;
                this.#renderer.addClass(nativeElement, classes);
            }
            if (item?.wrapper) {
                const wrapper = this.#renderer.createElement(item.wrapper.element);
                this.addAttribs(item.wrapper.attributes, wrapper);
                this.#renderer.appendChild(wrapper, name);
                this.#renderer.appendChild(nativeElement, wrapper);
            }
            else {
                this.#renderer.appendChild(nativeElement, name);
            }
        }
    }, ...(ngDevMode ? [{ debugName: "#itemEffect" }] : []));
    addAttribs(attribs, element) {
        if (attribs) {
            for (const attr in attribs) {
                if (attr === 'style' && typeof attribs[attr] === 'object') {
                    this.setStyle(attribs[attr], element);
                }
                else if (attr === 'class') {
                    this.addClass(attribs[attr], element);
                }
                else {
                    this.setAttrib(attr, attribs[attr], element);
                }
            }
        }
    }
    setStyle(styles, el) {
        for (const style in styles) {
            if (style) {
                this.#renderer.setStyle(el, style, styles[style]);
            }
        }
    }
    addClass(classes, el) {
        const classArray = Array.isArray(classes) ? classes : classes.split(' ');
        classArray
            .filter((element) => element.length > 0)
            .forEach((element) => {
            this.#renderer.addClass(el, element);
        });
    }
    setAttrib(key, value, el) {
        this.#renderer.setAttribute(el, key, value);
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: SidebarNavTitleComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.1.0", version: "20.3.2", type: SidebarNavTitleComponent, isStandalone: true, selector: "c-sidebar-nav-title", inputs: { item: { classPropertyName: "item", publicName: "item", isSignal: true, isRequired: false, transformFunction: null } }, ngImport: i0, template: '', isInline: true });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: SidebarNavTitleComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'c-sidebar-nav-title',
                    template: ''
                }]
        }] });

class SidebarNavDividerComponent {
    item = input(...(ngDevMode ? [undefined, { debugName: "item" }] : []));
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: SidebarNavDividerComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.1.0", version: "20.3.2", type: SidebarNavDividerComponent, isStandalone: true, selector: "c-sidebar-nav-divider", inputs: { item: { classPropertyName: "item", publicName: "item", isSignal: true, isRequired: false, transformFunction: null } }, ngImport: i0, template: ``, isInline: true });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: SidebarNavDividerComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'c-sidebar-nav-divider',
                    template: ``
                }]
        }] });

class SidebarNavItemClassPipe {
    helper = inject(SidebarNavHelper);
    // transform(item: any, ...args: any[]): any {
    transform(item, args) {
        const itemType = this.helper.itemType(item);
        let itemClass;
        if (['divider', 'title'].includes(itemType)) {
            itemClass = `nav-${itemType}`;
        }
        else if (itemType === 'group') {
            // itemClass = 'c-sidebar-nav-group' ;
            itemClass = '';
        }
        else {
            itemClass = 'nav-item';
        }
        return item.class ? `${itemClass} ${item.class}` : itemClass;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: SidebarNavItemClassPipe, deps: [], target: i0.ɵɵFactoryTarget.Pipe });
    static ɵpipe = i0.ɵɵngDeclarePipe({ minVersion: "14.0.0", version: "20.3.2", ngImport: i0, type: SidebarNavItemClassPipe, isStandalone: true, name: "cSidebarNavItemClass" });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: SidebarNavItemClassPipe, decorators: [{
            type: Pipe,
            args: [{
                    name: 'cSidebarNavItemClass'
                }]
        }] });

class SidebarNavGroupComponent {
    #router = inject(Router);
    #renderer = inject(Renderer2);
    #hostElement = inject(ElementRef);
    #sidebarNavGroupService = inject(SidebarNavGroupService);
    helper = inject(SidebarNavHelper);
    constructor() {
        const router = this.#router;
        this.navigationEndObservable = router.events.pipe(filter((event) => event instanceof NavigationEnd));
    }
    item;
    dropdownMode = 'path';
    show;
    compact;
    get hostClasses() {
        return {
            'nav-group': true,
            show: this.open
        };
    }
    sidebarNav;
    navigationEndObservable;
    navSubscription;
    navGroupSubscription;
    open;
    navItems = [];
    display = { display: 'block' };
    ngOnInit() {
        this.navItems = [...this.item.children];
        this.navSubscription = this.navigationEndObservable.subscribe((event) => {
            if (this.dropdownMode !== 'none') {
                const samePath = this.samePath(event.url);
                this.openGroup(samePath);
            }
        });
        if (this.samePath(this.#router.routerState.snapshot.url)) {
            this.openGroup(true);
        }
        this.navGroupSubscription = this.#sidebarNavGroupService.sidebarNavGroupState$.subscribe((next) => {
            if (this.dropdownMode === 'close' && next.sidebarNavGroup && next.sidebarNavGroup !== this) {
                if (next.sidebarNavGroup.item.url.startsWith(this.item.url)) {
                    return;
                }
                if (this.samePath(this.#router.routerState.snapshot.url)) {
                    this.openGroup(true);
                    return;
                }
                this.openGroup(false);
            }
        });
    }
    samePath(url) {
        // console.log('item:', this.item.name, this.item.url, 'url:', url);
        const itemArray = this.item.url?.split('/');
        const urlArray = url.split('/');
        return itemArray?.every((value, index) => {
            // console.log(value === urlArray[index], 'value:', value, 'index:', index, urlArray[index], url);
            return value === urlArray[index];
        });
    }
    openGroup(open) {
        this.open = open;
    }
    toggleGroup($event) {
        $event.preventDefault();
        this.openGroup(!this.open);
        if (this.open) {
            this.#sidebarNavGroupService.toggle({ open: this.open, sidebarNavGroup: this });
        }
    }
    ngOnDestroy() {
        this.navSubscription?.unsubscribe();
    }
    onAnimationStart($event) {
        this.display = { display: 'block' };
        setTimeout(() => {
            const host = this.sidebarNav?.nativeElement;
            if ($event.toState === 'open' && host) {
                this.#renderer.setStyle(host, 'height', `${host['scrollHeight']}px`);
            }
        });
    }
    onAnimationDone($event) {
        setTimeout(() => {
            const host = this.sidebarNav?.nativeElement;
            if ($event.toState === 'open' && host) {
                this.#renderer.setStyle(host, 'height', 'auto');
            }
            if ($event.toState === 'closed') {
                setTimeout(() => {
                    this.display = null;
                });
            }
        });
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: SidebarNavGroupComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "20.3.2", type: SidebarNavGroupComponent, isStandalone: true, selector: "c-sidebar-nav-group", inputs: { item: "item", dropdownMode: "dropdownMode", show: "show", compact: ["compact", "compact", booleanAttribute] }, host: { properties: { "class": "this.hostClasses" } }, providers: [SidebarNavHelper, SidebarNavGroupService], viewQueries: [{ propertyName: "sidebarNav", first: true, predicate: i0.forwardRef(() => SidebarNavComponent), descendants: true, read: ElementRef }], ngImport: i0, template: "<a (click)=\"toggleGroup($event)\"\n   [cHtmlAttr]=\"item.attributes\"\n   class=\"nav-link nav-group-toggle\"\n   href>\n  <ng-container *ngTemplateOutlet=\"iconTemplate ; context: {$implicit: item}\" />\n  <ng-container>{{ item.name }}</ng-container>\n  @if (helper.hasBadge(item)) {\n    <span [ngClass]=\"item | cSidebarNavBadge\">{{ item.badge.text }}</span>\n  }\n</a>\n<c-sidebar-nav\n  (@openClose.done)=\"onAnimationDone($event)\"\n  (@openClose.start)=\"onAnimationStart($event)\"\n  [@openClose]=\"open ? 'open' : 'closed'\"\n  [compact]=\"compact\"\n  [dropdownMode]=\"dropdownMode\"\n  [groupItems]=\"true\"\n  [navItems]=\"navItems\"\n  [ngStyle]=\"display\"\n/>\n\n<ng-template #iconTemplate let-item>\n  <!--  <i *ngIf=\"item?.icon\" [ngClass]=\"item | cSidebarNavIcon\"></i>-->\n  @if (item?.icon) {\n    <span class=\"nav-icon\">\n    <span [ngClass]=\"item.icon ?? ''\"></span>\n  </span>\n  }\n  @if (item?.iconComponent) {\n    <svg\n      [cIcon]=\"item.iconComponent?.content\"\n      [customClasses]=\"item | cSidebarNavIcon\"\n      [name]=\"item.iconComponent?.name\"\n    />\n  }\n  @if (!item?.icon && !item?.iconComponent) {\n    <span [ngClass]=\"item | cSidebarNavIcon\"></span>\n  }\n</ng-template>\n", styles: [".nav-group-toggle{cursor:pointer}.nav-group-items{display:block}\n"], dependencies: [{ kind: "directive", type: i0.forwardRef(() => HtmlAttributesDirective), selector: "[cHtmlAttr]", inputs: ["cHtmlAttr"], exportAs: ["cHtmlAttr"] }, { kind: "directive", type: i0.forwardRef(() => IconDirective), selector: "svg[cIcon]", inputs: ["cIcon", "customClasses", "size", "title", "height", "width", "name", "viewBox", "xmlns", "pointer-events", "role"], exportAs: ["cIcon"] }, { kind: "directive", type: i0.forwardRef(() => NgTemplateOutlet), selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }, { kind: "directive", type: i0.forwardRef(() => NgClass), selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "component", type: i0.forwardRef(() => SidebarNavComponent), selector: "c-sidebar-nav", inputs: ["navItems", "dropdownMode", "groupItems", "compact", "role"] }, { kind: "directive", type: i0.forwardRef(() => NgStyle), selector: "[ngStyle]", inputs: ["ngStyle"] }, { kind: "pipe", type: i0.forwardRef(() => SidebarNavIconPipe), name: "cSidebarNavIcon" }, { kind: "pipe", type: i0.forwardRef(() => SidebarNavBadgePipe), name: "cSidebarNavBadge" }], animations: [
            trigger('openClose', [
                state('open', style({
                    height: '*'
                })),
                state('closed', style({
                    height: '0px'
                })),
                transition('open <=> closed', [animate('.15s ease')])
            ])
        ] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: SidebarNavGroupComponent, decorators: [{
            type: Component,
            args: [{ selector: 'c-sidebar-nav-group', providers: [SidebarNavHelper, SidebarNavGroupService], imports: [
                        HtmlAttributesDirective,
                        IconDirective,
                        NgTemplateOutlet,
                        NgClass,
                        SidebarNavIconPipe,
                        SidebarNavBadgePipe,
                        forwardRef(() => SidebarNavComponent),
                        NgStyle
                    ], animations: [
                        trigger('openClose', [
                            state('open', style({
                                height: '*'
                            })),
                            state('closed', style({
                                height: '0px'
                            })),
                            transition('open <=> closed', [animate('.15s ease')])
                        ])
                    ], template: "<a (click)=\"toggleGroup($event)\"\n   [cHtmlAttr]=\"item.attributes\"\n   class=\"nav-link nav-group-toggle\"\n   href>\n  <ng-container *ngTemplateOutlet=\"iconTemplate ; context: {$implicit: item}\" />\n  <ng-container>{{ item.name }}</ng-container>\n  @if (helper.hasBadge(item)) {\n    <span [ngClass]=\"item | cSidebarNavBadge\">{{ item.badge.text }}</span>\n  }\n</a>\n<c-sidebar-nav\n  (@openClose.done)=\"onAnimationDone($event)\"\n  (@openClose.start)=\"onAnimationStart($event)\"\n  [@openClose]=\"open ? 'open' : 'closed'\"\n  [compact]=\"compact\"\n  [dropdownMode]=\"dropdownMode\"\n  [groupItems]=\"true\"\n  [navItems]=\"navItems\"\n  [ngStyle]=\"display\"\n/>\n\n<ng-template #iconTemplate let-item>\n  <!--  <i *ngIf=\"item?.icon\" [ngClass]=\"item | cSidebarNavIcon\"></i>-->\n  @if (item?.icon) {\n    <span class=\"nav-icon\">\n    <span [ngClass]=\"item.icon ?? ''\"></span>\n  </span>\n  }\n  @if (item?.iconComponent) {\n    <svg\n      [cIcon]=\"item.iconComponent?.content\"\n      [customClasses]=\"item | cSidebarNavIcon\"\n      [name]=\"item.iconComponent?.name\"\n    />\n  }\n  @if (!item?.icon && !item?.iconComponent) {\n    <span [ngClass]=\"item | cSidebarNavIcon\"></span>\n  }\n</ng-template>\n", styles: [".nav-group-toggle{cursor:pointer}.nav-group-items{display:block}\n"] }]
        }], ctorParameters: () => [], propDecorators: { item: [{
                type: Input
            }], dropdownMode: [{
                type: Input
            }], show: [{
                type: Input
            }], compact: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], hostClasses: [{
                type: HostBinding,
                args: ['class']
            }], sidebarNav: [{
                type: ViewChild,
                args: [forwardRef(() => SidebarNavComponent), { read: ElementRef }]
            }] } });
class SidebarNavComponent {
    sidebar = inject(SidebarComponent, { optional: true });
    helper = inject(SidebarNavHelper);
    router = inject(Router);
    #renderer = inject(Renderer2);
    #hostElement = inject(ElementRef);
    #sidebarService = inject(SidebarService);
    navItems = [];
    dropdownMode = 'path';
    groupItems;
    compact;
    get hostClasses() {
        return {
            'sidebar-nav': !this.groupItems,
            'nav-group-items': this.groupItems,
            compact: this.groupItems && this.compact
        };
    }
    // @HostBinding('class.nav-group-items')
    // get sidebarNavGroupItemsClass(): boolean {
    //   return !!this.groupItems;
    // }
    role = 'navigation';
    navItemsArray = [];
    ngOnChanges(changes) {
        this.navItemsArray = Array.isArray(this.navItems) ? this.navItems.slice() : [];
    }
    hideMobile() {
        // todo: proper scrollIntoView() after NavigationEnd
        if (this.sidebar && this.sidebar.sidebarState.mobile) {
            this.#sidebarService.toggle({ toggle: 'visible', sidebar: this.sidebar });
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: SidebarNavComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "20.3.2", type: SidebarNavComponent, isStandalone: true, selector: "c-sidebar-nav", inputs: { navItems: "navItems", dropdownMode: "dropdownMode", groupItems: ["groupItems", "groupItems", booleanAttribute], compact: ["compact", "compact", booleanAttribute], role: "role" }, host: { properties: { "class": "this.hostClasses", "attr.role": "this.role" } }, usesOnChanges: true, ngImport: i0, template: "@for (item of navItemsArray; track item) {\n  @switch (helper.itemType(item)) {\n    @case ('group') {\n      <c-sidebar-nav-group\n        #rla=\"routerLinkActive\"\n        [dropdownMode]=\"dropdownMode\"\n        [item]=\"item\"\n        [ngClass]=\"item | cSidebarNavItemClass\"\n        [routerLinkActiveOptions]=\"{exact: true}\"\n        routerLinkActive=\"show\"\n        [compact]=\"compact\"\n      />\n    }\n    @case ('divider') {\n      <c-sidebar-nav-divider\n        [cHtmlAttr]=\"item.attributes ?? {}\"\n        [item]=\"item\"\n        [ngClass]=\"item | cSidebarNavItemClass\"\n      />\n    }\n    @case ('title') {\n      <c-sidebar-nav-title\n        [cHtmlAttr]=\"item.attributes ?? {}\"\n        [item]=\"item\"\n        [ngClass]=\"item | cSidebarNavItemClass\"\n      />\n    }\n    @case ('label') {\n      <c-sidebar-nav-label\n        [item]=\"item\"\n        [ngClass]=\"item | cSidebarNavItemClass\"\n      />\n    }\n    @case ('empty') {\n      <ng-container />\n    }\n    @default {\n      <c-sidebar-nav-link\n        (linkClick)=\"hideMobile()\"\n        [item]=\"item\"\n        [ngClass]=\"item | cSidebarNavItemClass\"\n      />\n    }\n  }\n}\n<ng-content />\n", dependencies: [{ kind: "directive", type: i0.forwardRef(() => NgClass), selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "directive", type: i0.forwardRef(() => HtmlAttributesDirective), selector: "[cHtmlAttr]", inputs: ["cHtmlAttr"], exportAs: ["cHtmlAttr"] }, { kind: "component", type: i0.forwardRef(() => SidebarNavLinkComponent), selector: "c-sidebar-nav-link", inputs: ["item"], outputs: ["linkClick"] }, { kind: "component", type: i0.forwardRef(() => SidebarNavLabelComponent), selector: "c-sidebar-nav-label", inputs: ["item"] }, { kind: "component", type: i0.forwardRef(() => SidebarNavTitleComponent), selector: "c-sidebar-nav-title", inputs: ["item"] }, { kind: "component", type: i0.forwardRef(() => SidebarNavDividerComponent), selector: "c-sidebar-nav-divider", inputs: ["item"] }, { kind: "component", type: i0.forwardRef(() => SidebarNavGroupComponent), selector: "c-sidebar-nav-group", inputs: ["item", "dropdownMode", "show", "compact"] }, { kind: "ngmodule", type: i0.forwardRef(() => RouterModule) }, { kind: "directive", type: i0.forwardRef(() => i1.RouterLinkActive), selector: "[routerLinkActive]", inputs: ["routerLinkActiveOptions", "ariaCurrentWhenActive", "routerLinkActive"], outputs: ["isActiveChange"], exportAs: ["routerLinkActive"] }, { kind: "pipe", type: i0.forwardRef(() => SidebarNavItemClassPipe), name: "cSidebarNavItemClass" }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: SidebarNavComponent, decorators: [{
            type: Component,
            args: [{ selector: 'c-sidebar-nav', imports: [
                        NgClass,
                        HtmlAttributesDirective,
                        SidebarNavLinkComponent,
                        SidebarNavLabelComponent,
                        SidebarNavTitleComponent,
                        SidebarNavDividerComponent,
                        forwardRef(() => SidebarNavGroupComponent),
                        SidebarNavItemClassPipe,
                        RouterModule
                    ], template: "@for (item of navItemsArray; track item) {\n  @switch (helper.itemType(item)) {\n    @case ('group') {\n      <c-sidebar-nav-group\n        #rla=\"routerLinkActive\"\n        [dropdownMode]=\"dropdownMode\"\n        [item]=\"item\"\n        [ngClass]=\"item | cSidebarNavItemClass\"\n        [routerLinkActiveOptions]=\"{exact: true}\"\n        routerLinkActive=\"show\"\n        [compact]=\"compact\"\n      />\n    }\n    @case ('divider') {\n      <c-sidebar-nav-divider\n        [cHtmlAttr]=\"item.attributes ?? {}\"\n        [item]=\"item\"\n        [ngClass]=\"item | cSidebarNavItemClass\"\n      />\n    }\n    @case ('title') {\n      <c-sidebar-nav-title\n        [cHtmlAttr]=\"item.attributes ?? {}\"\n        [item]=\"item\"\n        [ngClass]=\"item | cSidebarNavItemClass\"\n      />\n    }\n    @case ('label') {\n      <c-sidebar-nav-label\n        [item]=\"item\"\n        [ngClass]=\"item | cSidebarNavItemClass\"\n      />\n    }\n    @case ('empty') {\n      <ng-container />\n    }\n    @default {\n      <c-sidebar-nav-link\n        (linkClick)=\"hideMobile()\"\n        [item]=\"item\"\n        [ngClass]=\"item | cSidebarNavItemClass\"\n      />\n    }\n  }\n}\n<ng-content />\n" }]
        }], propDecorators: { navItems: [{
                type: Input
            }], dropdownMode: [{
                type: Input
            }], groupItems: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], compact: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], hostClasses: [{
                type: HostBinding,
                args: ['class']
            }], role: [{
                type: HostBinding,
                args: ['attr.role']
            }, {
                type: Input
            }] } });

class SidebarModule {
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: SidebarModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
    static ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "20.3.2", ngImport: i0, type: SidebarModule, imports: [SidebarComponent,
            SidebarBrandComponent,
            SidebarFooterComponent,
            SidebarHeaderComponent,
            SidebarNavComponent,
            SidebarNavBadgePipe,
            SidebarNavDividerComponent,
            SidebarNavGroupComponent,
            SidebarNavIconPipe,
            SidebarNavItemClassPipe,
            SidebarNavLabelComponent,
            SidebarNavLinkComponent,
            SidebarNavLinkContentComponent,
            SidebarNavLinkPipe,
            SidebarNavTitleComponent,
            SidebarToggleDirective,
            SidebarTogglerDirective], exports: [SidebarComponent,
            SidebarToggleDirective,
            SidebarTogglerDirective,
            SidebarBrandComponent,
            SidebarNavComponent,
            SidebarHeaderComponent,
            SidebarFooterComponent] });
    static ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: SidebarModule, providers: [
            SidebarService,
            SidebarNavHelper,
            SidebarNavGroupService
        ], imports: [SidebarNavComponent,
            SidebarNavGroupComponent,
            SidebarNavLinkComponent] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: SidebarModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        SidebarComponent,
                        SidebarBrandComponent,
                        SidebarFooterComponent,
                        SidebarHeaderComponent,
                        SidebarNavComponent,
                        SidebarNavBadgePipe,
                        SidebarNavDividerComponent,
                        SidebarNavGroupComponent,
                        SidebarNavIconPipe,
                        SidebarNavItemClassPipe,
                        SidebarNavLabelComponent,
                        SidebarNavLinkComponent,
                        SidebarNavLinkContentComponent,
                        SidebarNavLinkPipe,
                        SidebarNavTitleComponent,
                        SidebarToggleDirective,
                        SidebarTogglerDirective
                    ],
                    exports: [
                        SidebarComponent,
                        SidebarToggleDirective,
                        SidebarTogglerDirective,
                        SidebarBrandComponent,
                        SidebarNavComponent,
                        SidebarHeaderComponent,
                        SidebarFooterComponent
                    ],
                    providers: [
                        SidebarService,
                        SidebarNavHelper,
                        SidebarNavGroupService
                    ]
                }]
        }] });

class SpinnerComponent {
    /**
     * Sets the color context of the component to one of CoreUI’s themed colors.
     * @type Colors
     */
    color = input(...(ngDevMode ? [undefined, { debugName: "color" }] : []));
    /**
     * Label for accessibility.
     * @type string
     * @default 'Loading...'
     */
    label = input('Loading...', ...(ngDevMode ? [{ debugName: "label" }] : []));
    /**
     * Size the component small.
     * @type string
     * @values 'sm'
     */
    size = input(...(ngDevMode ? [undefined, { debugName: "size" }] : []));
    /**
     * Set the button variant to an outlined button or a ghost button.
     * @values 'border' | 'grow'
     * @default 'border'
     */
    variant = input('border', ...(ngDevMode ? [{ debugName: "variant" }] : []));
    /**
     * Default role attr for Spinner. [docs]
     * @type string
     * @default 'status'
     */
    role = input('status', ...(ngDevMode ? [{ debugName: "role" }] : []));
    hostClasses = computed(() => {
        return {
            [`spinner-${this.variant()}`]: true,
            [`text-${this.color()}`]: !!this.color(),
            [`spinner-${this.variant()}-${this.size()}`]: !!this.size()
        };
    }, ...(ngDevMode ? [{ debugName: "hostClasses" }] : []));
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: SpinnerComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.1.0", version: "20.3.2", type: SpinnerComponent, isStandalone: true, selector: "c-spinner", inputs: { color: { classPropertyName: "color", publicName: "color", isSignal: true, isRequired: false, transformFunction: null }, label: { classPropertyName: "label", publicName: "label", isSignal: true, isRequired: false, transformFunction: null }, size: { classPropertyName: "size", publicName: "size", isSignal: true, isRequired: false, transformFunction: null }, variant: { classPropertyName: "variant", publicName: "variant", isSignal: true, isRequired: false, transformFunction: null }, role: { classPropertyName: "role", publicName: "role", isSignal: true, isRequired: false, transformFunction: null } }, host: { properties: { "attr.role": "role()", "class": "hostClasses()" } }, ngImport: i0, template: "<ng-content>\n  <span class=\"visually-hidden\">{{ label() }}</span>\n</ng-content>\n" });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: SpinnerComponent, decorators: [{
            type: Component,
            args: [{ selector: 'c-spinner', host: {
                        '[attr.role]': 'role()',
                        '[class]': 'hostClasses()'
                    }, template: "<ng-content>\n  <span class=\"visually-hidden\">{{ label() }}</span>\n</ng-content>\n" }]
        }] });

class SpinnerModule {
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: SpinnerModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
    static ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "20.3.2", ngImport: i0, type: SpinnerModule, imports: [SpinnerComponent], exports: [SpinnerComponent] });
    static ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: SpinnerModule });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: SpinnerModule, decorators: [{
            type: NgModule,
            args: [{
                    exports: [
                        SpinnerComponent
                    ],
                    imports: [
                        SpinnerComponent
                    ]
                }]
        }] });

class TableColorDirective {
    /**
     * Use contextual color for tables, table rows or individual cells.
     * @return Colors
     */
    color = input(undefined, ...(ngDevMode ? [{ debugName: "color", alias: 'cTableColor' }] : [{ alias: 'cTableColor' }]));
    hostClasses = computed(() => {
        const color = this.color();
        return {
            [`table-${color}`]: !!color
        };
    }, ...(ngDevMode ? [{ debugName: "hostClasses" }] : []));
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: TableColorDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.1.0", version: "20.3.2", type: TableColorDirective, isStandalone: true, selector: "[cTableColor]", inputs: { color: { classPropertyName: "color", publicName: "cTableColor", isSignal: true, isRequired: false, transformFunction: null } }, host: { properties: { "class": "hostClasses()" } }, exportAs: ["cTableColor"], ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: TableColorDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[cTableColor]',
                    exportAs: 'cTableColor',
                    host: {
                        '[class]': 'hostClasses()'
                    }
                }]
        }] });

class TableActiveDirective {
    /**
     * Highlight a table row or cell
     * @return boolean
     */
    active = input(false, ...(ngDevMode ? [{ debugName: "active", alias: "cTableActive", transform: booleanAttribute }] : [{ alias: "cTableActive", transform: booleanAttribute }]));
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: TableActiveDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.1.0", version: "20.3.2", type: TableActiveDirective, isStandalone: true, selector: "[cTableActive]", inputs: { active: { classPropertyName: "active", publicName: "cTableActive", isSignal: true, isRequired: false, transformFunction: null } }, host: { properties: { "class.table-active": "active()" } }, exportAs: ["cTableActive"], ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: TableActiveDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[cTableActive]',
                    exportAs: 'cTableActive',
                    host: {
                        '[class.table-active]': 'active()'
                    }
                }]
        }] });

class TableDirective {
    static ngAcceptInputType_bordered;
    static ngAcceptInputType_borderless;
    static ngAcceptInputType_hover;
    static ngAcceptInputType_small;
    static ngAcceptInputType_striped;
    static ngAcceptInputType_stripedColumns;
    #renderer = inject(Renderer2);
    #hostElement = inject(ElementRef);
    /**
     * Set the vertical alignment.
     * @return string
     * @values 'bottom' | 'middle' | 'top'
     */
    align = input(...(ngDevMode ? [undefined, { debugName: "align" }] : []));
    /**
     * Sets the border color of the component to one of CoreUI’s themed colors.
     * @return Colors
     */
    borderColor = input(...(ngDevMode ? [undefined, { debugName: "borderColor" }] : []));
    /**
     * Add borders on all sides of the table and cells.
     * @return boolean
     */
    bordered = input(false, ...(ngDevMode ? [{ debugName: "bordered", transform: booleanAttribute }] : [{ transform: booleanAttribute }]));
    /**
     * Remove borders on all sides of the table and cells.
     * @return boolean
     */
    borderless = input(false, ...(ngDevMode ? [{ debugName: "borderless", transform: booleanAttribute }] : [{ transform: booleanAttribute }]));
    /**
     * Put the `<caption>` on the top of the table.
     * @return 'top'
     * @values 'top'
     */
    caption = input(...(ngDevMode ? [undefined, { debugName: "caption" }] : []));
    /**
     * Sets the color context of the component to one of CoreUI’s themed colors.
     * @return Colors
     */
    color = input(...(ngDevMode ? [undefined, { debugName: "color" }] : []));
    /**
     * Enable a hover state on table rows within table body.
     * @return boolean
     */
    hover = input(false, ...(ngDevMode ? [{ debugName: "hover", transform: booleanAttribute }] : [{ transform: booleanAttribute }]));
    /**
     * Make table responsive across all viewports or pick a maximum breakpoint with which to have a responsive table up to.
     * @values: {boolean | 'sm' | 'md' | 'lg' | 'xl' | 'xxl'}
     */
    responsive = input(...(ngDevMode ? [undefined, { debugName: "responsive" }] : []));
    /**
     * Make table more compact by cutting all cell `padding` in half.
     * @return boolean
     */
    small = input(false, ...(ngDevMode ? [{ debugName: "small", transform: booleanAttribute }] : [{ transform: booleanAttribute }]));
    /**
     * Add zebra-striping to any table row within the table body.
     * @return boolean
     */
    striped = input(false, ...(ngDevMode ? [{ debugName: "striped", transform: booleanAttribute }] : [{ transform: booleanAttribute }]));
    /**
     * Add zebra-striping to any table column.
     * @return boolean
     * @since 4.2.4
     */
    stripedColumns = input(false, ...(ngDevMode ? [{ debugName: "stripedColumns", transform: booleanAttribute }] : [{ transform: booleanAttribute }]));
    hostClasses = computed(() => {
        const align = this.align();
        const caption = this.caption();
        const borderColor = this.borderColor();
        const bordered = this.bordered();
        const borderless = this.borderless();
        const color = this.color();
        const hover = this.hover();
        const small = this.small();
        const striped = this.striped();
        const stripedColumns = this.stripedColumns();
        return {
            table: true,
            [`align-${align}`]: !!align,
            [`caption-${caption}`]: !!caption,
            [`border-${borderColor}`]: !!borderColor,
            'table-bordered': bordered,
            'table-borderless': borderless,
            [`table-${color}`]: !!color,
            'table-hover': hover,
            'table-sm': small,
            'table-striped': striped,
            'table-striped-columns': stripedColumns
        };
    }, ...(ngDevMode ? [{ debugName: "hostClasses" }] : []));
    #responsiveWrapperEffect = afterRenderEffect({
        // this fixes RuntimeError: NG0500: During hydration Angular expected <abc> but found <xyz>.
        // Find more at https://angular.dev/errors/NG0500
        write: () => {
            const responsive = this.responsive();
            if (!!responsive) {
                const nativeElement = this.#hostElement.nativeElement;
                const wrapper = this.#renderer.createElement('div');
                const className = responsive === true ? 'table-responsive' : `table-responsive-${responsive}`;
                this.#renderer.addClass(wrapper, className);
                const parentNode = this.#renderer.parentNode(nativeElement);
                this.#renderer.appendChild(parentNode, wrapper);
                this.#renderer.insertBefore(parentNode, wrapper, nativeElement);
                this.#renderer.appendChild(wrapper, nativeElement);
            }
        }
    });
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: TableDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.1.0", version: "20.3.2", type: TableDirective, isStandalone: true, selector: "table[cTable]", inputs: { align: { classPropertyName: "align", publicName: "align", isSignal: true, isRequired: false, transformFunction: null }, borderColor: { classPropertyName: "borderColor", publicName: "borderColor", isSignal: true, isRequired: false, transformFunction: null }, bordered: { classPropertyName: "bordered", publicName: "bordered", isSignal: true, isRequired: false, transformFunction: null }, borderless: { classPropertyName: "borderless", publicName: "borderless", isSignal: true, isRequired: false, transformFunction: null }, caption: { classPropertyName: "caption", publicName: "caption", isSignal: true, isRequired: false, transformFunction: null }, color: { classPropertyName: "color", publicName: "color", isSignal: true, isRequired: false, transformFunction: null }, hover: { classPropertyName: "hover", publicName: "hover", isSignal: true, isRequired: false, transformFunction: null }, responsive: { classPropertyName: "responsive", publicName: "responsive", isSignal: true, isRequired: false, transformFunction: null }, small: { classPropertyName: "small", publicName: "small", isSignal: true, isRequired: false, transformFunction: null }, striped: { classPropertyName: "striped", publicName: "striped", isSignal: true, isRequired: false, transformFunction: null }, stripedColumns: { classPropertyName: "stripedColumns", publicName: "stripedColumns", isSignal: true, isRequired: false, transformFunction: null } }, host: { properties: { "class": "hostClasses()" }, classAttribute: "table" }, exportAs: ["cTable"], ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: TableDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: 'table[cTable]',
                    exportAs: 'cTable',
                    host: {
                        class: 'table',
                        '[class]': 'hostClasses()'
                    }
                }]
        }] });

class TableModule {
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: TableModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
    static ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "20.3.2", ngImport: i0, type: TableModule, imports: [TableDirective,
            TableColorDirective,
            TableActiveDirective], exports: [TableDirective,
            TableColorDirective,
            TableActiveDirective] });
    static ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: TableModule });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: TableModule, decorators: [{
            type: NgModule,
            args: [{
                    exports: [
                        TableDirective,
                        TableColorDirective,
                        TableActiveDirective
                    ],
                    imports: [
                        TableDirective,
                        TableColorDirective,
                        TableActiveDirective
                    ]
                }]
        }] });

class TabService {
    activeTabPaneIdx = new Subject();
    activeTabPaneIdx$ = this.activeTabPaneIdx.asObservable();
    setActiveTabIdx(tabContentState) {
        this.activeTabPaneIdx.next(tabContentState);
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: TabService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: TabService, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: TabService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root'
                }]
        }] });

class TabPaneComponent {
    #changeDetectorRef = inject(ChangeDetectorRef);
    #tabService = inject(TabService);
    constructor() {
        this.subscribeTabService();
    }
    tabPaneIdx;
    tabContent;
    #tabServiceSubscription;
    set active(value) {
        const newValue = booleanAttribute(value);
        if (this.#active !== newValue) {
            this.#active = newValue;
            this.#changeDetectorRef.markForCheck();
        }
    }
    get active() {
        return this.#active;
    }
    #active = false;
    get hostClasses() {
        return {
            'tab-pane': true,
            fade: true,
            show: this.active,
            active: this.active
        };
    }
    role = 'tabpanel';
    ngOnDestroy() {
        this.subscribeTabService(false);
    }
    subscribeTabService(subscribe = true) {
        if (subscribe) {
            this.#tabServiceSubscription = this.#tabService.activeTabPaneIdx$.subscribe((tabContentState) => {
                if (tabContentState.tabContent === this.tabContent) {
                    this.active = tabContentState.activeIdx === this.tabPaneIdx;
                }
            });
        }
        else {
            this.#tabServiceSubscription?.unsubscribe();
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: TabPaneComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "20.3.2", type: TabPaneComponent, isStandalone: true, selector: "c-tab-pane", inputs: { role: "role" }, host: { properties: { "class": "this.hostClasses", "attr.role": "this.role" }, classAttribute: "tab-pane" }, exportAs: ["cTabPane"], ngImport: i0, template: '<ng-content />', isInline: true, styles: [":host{display:block}\n"] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: TabPaneComponent, decorators: [{
            type: Component,
            args: [{ selector: 'c-tab-pane', template: '<ng-content />', exportAs: 'cTabPane', host: { class: 'tab-pane' }, styles: [":host{display:block}\n"] }]
        }], ctorParameters: () => [], propDecorators: { hostClasses: [{
                type: HostBinding,
                args: ['class']
            }], role: [{
                type: Input
            }, {
                type: HostBinding,
                args: ['attr.role']
            }] } });

class TabContentComponent {
    #changeDetectorRef = inject(ChangeDetectorRef);
    #tabService = inject(TabService);
    /**
     * Set active tabPane index
     * @type number
     */
    set activeTabPaneIdx(value) {
        const newValue = value;
        if (this.#activeTabPaneIdx != newValue) {
            this.#activeTabPaneIdx = newValue;
            this.activeTabPaneIdxChange?.emit(newValue);
            this.#changeDetectorRef.markForCheck();
            this.#changeDetectorRef.detectChanges();
        }
    }
    get activeTabPaneIdx() {
        return this.#activeTabPaneIdx;
    }
    #activeTabPaneIdx = -1;
    /**
     * Event emitted on the active tab pane index change.
     */
    activeTabPaneIdxChange = output();
    panes;
    #tabServiceSubscription;
    ngAfterContentInit() {
        this.subscribeTabService();
    }
    ngAfterContentChecked() {
        this.panes?.forEach((tabPane, index) => {
            tabPane.tabContent = this;
            tabPane.tabPaneIdx = index;
        });
        this.refreshTabPaneActive(this.activeTabPaneIdx);
        this.#tabService.setActiveTabIdx({ tabContent: this, activeIdx: this.activeTabPaneIdx });
    }
    ngOnChanges(changes) {
        if (changes['activeTabPaneIdx']?.currentValue) {
            this.#tabService.setActiveTabIdx({ tabContent: this, activeIdx: changes['activeTabPaneIdx'].currentValue });
        }
    }
    ngOnDestroy() {
        this.subscribeTabService(false);
    }
    subscribeTabService(subscribe = true) {
        if (subscribe) {
            this.#tabServiceSubscription = this.#tabService.activeTabPaneIdx$.subscribe((tabContentState) => {
                if (this === tabContentState.tabContent) {
                    this.activeTabPaneIdx = tabContentState.activeIdx;
                }
            });
        }
        else {
            this.#tabServiceSubscription?.unsubscribe();
        }
    }
    refreshTabPaneActive(idx) {
        // hack for active state pane refresh todo?
        this.panes?.forEach((tabPane, index) => {
            tabPane.active = idx === index;
        });
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: TabContentComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "16.1.0", version: "20.3.2", type: TabContentComponent, isStandalone: true, selector: "c-tab-content", inputs: { activeTabPaneIdx: ["activeTabPaneIdx", "activeTabPaneIdx", numberAttribute] }, outputs: { activeTabPaneIdxChange: "activeTabPaneIdxChange" }, host: { classAttribute: "tab-content" }, queries: [{ propertyName: "panes", predicate: TabPaneComponent }], exportAs: ["cTabContent"], usesOnChanges: true, ngImport: i0, template: '<ng-content />', isInline: true, styles: [":host{display:block}\n"], changeDetection: i0.ChangeDetectionStrategy.OnPush });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: TabContentComponent, decorators: [{
            type: Component,
            args: [{ selector: 'c-tab-content', template: '<ng-content />', changeDetection: ChangeDetectionStrategy.OnPush, exportAs: 'cTabContent', host: { class: 'tab-content' }, styles: [":host{display:block}\n"] }]
        }], propDecorators: { activeTabPaneIdx: [{
                type: Input,
                args: [{ transform: numberAttribute }]
            }], panes: [{
                type: ContentChildren,
                args: [TabPaneComponent]
            }] } });

class TabContentRefDirective {
    #changeDetectorRef = inject(ChangeDetectorRef);
    #tabService = inject(TabService);
    constructor() {
        this.subscribeTabService();
    }
    #tabServiceSubscription;
    /**
     * Template Ref
     * @type TemplateRef
     */
    tabContentRef;
    /**
     * Set active state of tab content
     * @type boolean
     * @default false
     */
    set active(value) {
        const newValue = value;
        if (this.#active !== newValue) {
            this.#active = newValue;
            this.#changeDetectorRef.detectChanges();
        }
    }
    get active() {
        return this.#active;
    }
    #active = false;
    /**
     * Set disabled state of tab content
     * @type boolean
     */
    set disabled(value) {
        this.#disabled = value;
    }
    get disabled() {
        return this.#disabled || this.tabPaneIdx >= this.tabContentRef?.panes?.length;
    }
    #disabled = false;
    /**
     * c-tab-pane index respectively
     * @type number
     */
    tabPaneIdx = -1;
    get hostClasses() {
        return {
            active: this.active,
            disabled: this.disabled
        };
    }
    get isDisabled() {
        return this.disabled || null;
    }
    get attrDisabled() {
        return this.disabled ? '' : null;
    }
    get ariaSelected() {
        return this.active;
    }
    role = 'tab';
    get getTabindex() {
        return this.disabled ? '-1' : null;
    }
    ngOnChanges(changes) {
        if (changes['active']?.currentValue) {
            this.setActiveTabPane();
        }
    }
    toggleOpen($event) {
        $event.preventDefault();
        this.setActiveTabPane();
    }
    setActiveTabPane() {
        setTimeout(() => {
            if (this.tabPaneIdx < this.tabContentRef.panes.length) {
                this.active = true;
                this.#tabService.setActiveTabIdx({ tabContent: this.tabContentRef, activeIdx: this.tabPaneIdx });
            }
            else {
                this.active = false;
            }
        });
    }
    ngOnDestroy() {
        this.subscribeTabService(false);
    }
    subscribeTabService(subscribe = true) {
        if (subscribe) {
            this.#tabServiceSubscription = this.#tabService.activeTabPaneIdx$.subscribe((tabContentState) => {
                if (tabContentState.tabContent === this.tabContentRef) {
                    this.active = tabContentState.activeIdx === this.tabPaneIdx;
                }
            });
        }
        else {
            this.#tabServiceSubscription?.unsubscribe();
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: TabContentRefDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "16.1.0", version: "20.3.2", type: TabContentRefDirective, isStandalone: true, selector: "[cTabContent]", inputs: { tabContentRef: ["cTabContent", "tabContentRef"], active: ["active", "active", booleanAttribute], disabled: ["disabled", "disabled", booleanAttribute], tabPaneIdx: ["tabPaneIdx", "tabPaneIdx", numberAttribute], role: "role" }, host: { listeners: { "click": "toggleOpen($event)" }, properties: { "class": "this.hostClasses", "attr.aria-disabled": "this.isDisabled", "attr.disabled": "this.attrDisabled", "attr.aria-selected": "this.ariaSelected", "attr.role": "this.role", "attr.tabindex": "this.getTabindex" } }, usesOnChanges: true, ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: TabContentRefDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[cTabContent]'
                }]
        }], ctorParameters: () => [], propDecorators: { tabContentRef: [{
                type: Input,
                args: ['cTabContent']
            }], active: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], disabled: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], tabPaneIdx: [{
                type: Input,
                args: [{ transform: numberAttribute }]
            }], hostClasses: [{
                type: HostBinding,
                args: ['class']
            }], isDisabled: [{
                type: HostBinding,
                args: ['attr.aria-disabled']
            }], attrDisabled: [{
                type: HostBinding,
                args: ['attr.disabled']
            }], ariaSelected: [{
                type: HostBinding,
                args: ['attr.aria-selected']
            }], role: [{
                type: Input
            }, {
                type: HostBinding,
                args: ['attr.role']
            }], getTabindex: [{
                type: HostBinding,
                args: ['attr.tabindex']
            }], toggleOpen: [{
                type: HostListener,
                args: ['click', ['$event']]
            }] } });

class TabsModule {
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: TabsModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
    static ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "20.3.2", ngImport: i0, type: TabsModule, imports: [TabContentComponent,
            TabContentRefDirective,
            TabPaneComponent], exports: [TabContentComponent,
            TabPaneComponent,
            TabContentRefDirective] });
    static ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: TabsModule, providers: [
            TabService
        ] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: TabsModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        TabContentComponent,
                        TabContentRefDirective,
                        TabPaneComponent
                    ],
                    exports: [
                        TabContentComponent,
                        TabPaneComponent,
                        TabContentRefDirective
                    ],
                    providers: [
                        TabService
                    ]
                }]
        }] });

class TabsService {
    activeItem = signal(undefined, ...(ngDevMode ? [{ debugName: "activeItem" }] : []));
    activeItemKey = signal(undefined, ...(ngDevMode ? [{ debugName: "activeItemKey" }] : []));
    id = signal(undefined, ...(ngDevMode ? [{ debugName: "id" }] : []));
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: TabsService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: TabsService });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: TabsService, decorators: [{
            type: Injectable
        }] });

let nextId = 0;
class TabsComponent {
    tabsService = inject(TabsService);
    /**
     * The active item key.
     * @type <string | number | undefined>
     */
    activeItemKey = model(...(ngDevMode ? [undefined, { debugName: "activeItemKey" }] : []));
    /**
     * The id attribute
     * @type string
     */
    tabsId = `tabs-${nextId++}`;
    id = input(this.tabsId, ...(ngDevMode ? [{ debugName: "id" }] : []));
    #activeItemEffect = effect(() => {
        this.tabsService.id.set(this.id());
        this.tabsService.activeItemKey.set(this.activeItemKey());
    }, ...(ngDevMode ? [{ debugName: "#activeItemEffect" }] : []));
    #tabsServiceEffect = effect(() => {
        this.activeItemKey.set(this.tabsService.activeItemKey());
    }, ...(ngDevMode ? [{ debugName: "#tabsServiceEffect" }] : []));
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: TabsComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.1.0", version: "20.3.2", type: TabsComponent, isStandalone: true, selector: "c-tabs", inputs: { activeItemKey: { classPropertyName: "activeItemKey", publicName: "activeItemKey", isSignal: true, isRequired: false, transformFunction: null }, id: { classPropertyName: "id", publicName: "id", isSignal: true, isRequired: false, transformFunction: null } }, outputs: { activeItemKey: "activeItemKeyChange" }, host: { properties: { "id": "id()" }, classAttribute: "tabs" }, providers: [TabsService], exportAs: ["cTabs"], ngImport: i0, template: '<ng-content />', isInline: true, styles: [":host{display:block}\n"] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: TabsComponent, decorators: [{
            type: Component,
            args: [{ exportAs: 'cTabs', selector: 'c-tabs', imports: [], template: '<ng-content />', providers: [TabsService], host: {
                        '[id]': 'id()',
                        class: 'tabs'
                    }, styles: [":host{display:block}\n"] }]
        }] });

class TabDirective {
    #injector = inject(Injector);
    #destroyRef = inject(DestroyRef);
    #elementRef = inject(ElementRef);
    #tabsService = inject(TabsService);
    /**
     * Disabled attribute
     * @return boolean
     * @default false
     */
    disabledInput = input(false, ...(ngDevMode ? [{ debugName: "disabledInput", transform: booleanAttribute, alias: 'disabled' }] : [{ transform: booleanAttribute, alias: 'disabled' }]));
    #disabled = linkedSignal(this.disabledInput);
    attrDisabled = computed(() => this.#disabled() || null, ...(ngDevMode ? [{ debugName: "attrDisabled" }] : []));
    set disabled(value) {
        this.#disabled.set(value);
    }
    get disabled() {
        return this.#disabled();
    }
    /**
     * Item key.
     * @type string | number
     * @required
     */
    itemKey = input.required(...(ngDevMode ? [{ debugName: "itemKey" }] : []));
    /**
     * Element id attribute
     * @type string
     * @default undefined
     */
    id = input(...(ngDevMode ? [undefined, { debugName: "id" }] : []));
    /**
     * aria-controls attribute
     * @type string
     * @default undefined
     */
    ariaControls = input(undefined, ...(ngDevMode ? [{ debugName: "ariaControls", alias: 'aria-controls' }] : [{
            alias: 'aria-controls'
        }]));
    isActive = signal(false, ...(ngDevMode ? [{ debugName: "isActive" }] : []));
    hostClasses = computed(() => {
        return {
            'nav-link': true,
            active: this.isActive(),
            disabled: this.#disabled()
        };
    }, ...(ngDevMode ? [{ debugName: "hostClasses" }] : []));
    propId = computed(() => this.id() ?? `${this.#tabsService.id()}-tab-${this.itemKey()}`, ...(ngDevMode ? [{ debugName: "propId" }] : []));
    attrAriaControls = computed(() => this.ariaControls() ?? `${this.#tabsService.id()}-panel-${this.itemKey()}`, ...(ngDevMode ? [{ debugName: "attrAriaControls" }] : []));
    #disabledSignalEffect = effect(() => {
        const disabled = this.#disabled();
        if (!disabled) {
            const click$ = fromEvent(this.#elementRef.nativeElement, 'click');
            const focusIn$ = fromEvent(this.#elementRef.nativeElement, 'focusin');
            merge(focusIn$, click$)
                .pipe(filter(($event) => !disabled), tap(($event) => {
                this.#tabsService.activeItemKey.set(untracked(this.itemKey));
            }), takeWhile(() => !disabled), takeUntilDestroyed(this.#destroyRef))
                .subscribe();
        }
    }, ...(ngDevMode ? [{ debugName: "#disabledSignalEffect" }] : []));
    focus(origin) {
        this.#elementRef.nativeElement.focus();
    }
    ngOnInit() {
        runInInjectionContext(this.#injector, () => {
            effect(() => {
                const isActive = !this.#disabled() && this.#tabsService.activeItemKey() === this.itemKey();
                this.isActive.set(isActive);
            });
        });
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: TabDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.1.0", version: "20.3.2", type: TabDirective, isStandalone: true, selector: "button[cTab]", inputs: { disabledInput: { classPropertyName: "disabledInput", publicName: "disabled", isSignal: true, isRequired: false, transformFunction: null }, itemKey: { classPropertyName: "itemKey", publicName: "itemKey", isSignal: true, isRequired: true, transformFunction: null }, id: { classPropertyName: "id", publicName: "id", isSignal: true, isRequired: false, transformFunction: null }, ariaControls: { classPropertyName: "ariaControls", publicName: "aria-controls", isSignal: true, isRequired: false, transformFunction: null } }, host: { attributes: { "type": "button", "role": "tab" }, properties: { "class": "hostClasses()", "attr.aria-selected": "isActive()", "attr.aria-controls": "attrAriaControls()", "attr.disabled": "attrDisabled() || null", "id": "propId()", "tabindex": "isActive() ? 0 : -1" } }, exportAs: ["cTab"], ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: TabDirective, decorators: [{
            type: Directive,
            args: [{
                    exportAs: 'cTab',
                    selector: 'button[cTab]',
                    host: {
                        '[class]': 'hostClasses()',
                        type: 'button',
                        role: 'tab',
                        '[attr.aria-selected]': 'isActive()',
                        '[attr.aria-controls]': 'attrAriaControls()',
                        '[attr.disabled]': 'attrDisabled() || null',
                        '[id]': 'propId()',
                        '[tabindex]': 'isActive() ? 0 : -1'
                    }
                }]
        }] });

class TabsListComponent {
    #destroyRef = inject(DestroyRef);
    #elementRef = inject(ElementRef);
    tabsService = inject(TabsService);
    #rtlService = inject(RtlService);
    #isRtl = signal(false, ...(ngDevMode ? [{ debugName: "#isRtl" }] : []));
    constructor() {
        afterEveryRender({
            read: () => {
                this.#isRtl.set(this.#rtlService.isRTL(this.#elementRef.nativeElement));
            }
        });
    }
    /**
     * Specify a layout type for component.
     * @type 'fill' | 'justified' | undefined
     * @default undefined
     */
    layout = input(...(ngDevMode ? [undefined, { debugName: "layout" }] : []));
    /**
     * Set the variant to tabs, pills or underline.
     * @type 'pills' | 'tabs' | 'underline' | 'underline-border' | undefined
     * @default undefined
     */
    variant = input(...(ngDevMode ? [undefined, { debugName: "variant" }] : []));
    /**
     * Set the role to tab list.
     * @default 'tablist'
     */
    role = input('tablist', ...(ngDevMode ? [{ debugName: "role" }] : []));
    hostClasses = computed(() => ({
        nav: true,
        [`nav-${this.layout()}`]: this.layout(),
        [`nav-${this.variant()}`]: this.variant()
    }), ...(ngDevMode ? [{ debugName: "hostClasses" }] : []));
    tabs = contentChildren(TabDirective, ...(ngDevMode ? [{ debugName: "tabs" }] : []));
    #focusKeyManager;
    #tabsEffect = effect(() => {
        const tabs = this.tabs();
        if (tabs.length === 0) {
            return;
        }
        const isRtl = this.#isRtl();
        this.#focusKeyManager = new FocusKeyManager(tabs)
            .skipPredicate((tab) => tab.disabled === true)
            .withHorizontalOrientation(isRtl ? 'rtl' : 'ltr')
            .withHomeAndEnd()
            .withWrap();
        this.#focusKeyManager.change
            .pipe(tap((value) => {
            this.tabsService.activeItemKey.set(this.#focusKeyManager.activeItem?.itemKey());
            this.tabsService.activeItem.set(this.#focusKeyManager.activeItem);
        }), takeUntilDestroyed(this.#destroyRef))
            .subscribe();
        untracked(() => {
            setTimeout(() => {
                const activeItem = tabs.find((tab) => tab.isActive()) ?? tabs.find((tab) => !tab.disabled);
                const activeItemIndex = tabs.findIndex((tab) => tab === activeItem);
                this.#focusKeyManager?.updateActiveItem(activeItemIndex < 0 ? 0 : activeItemIndex);
                this.tabsService.activeItemKey.set(this.#focusKeyManager.activeItem?.itemKey());
                this.tabsService.activeItem.set(this.#focusKeyManager.activeItem);
            });
        });
    }, ...(ngDevMode ? [{ debugName: "#tabsEffect" }] : []));
    #tabsServiceEffect = effect(() => {
        const activeItemIndex = this.tabs().findIndex((tab) => untracked(tab.isActive) && untracked(tab.itemKey) === this.tabsService.activeItemKey());
        this.#focusKeyManager?.updateActiveItem(activeItemIndex < 0 ? 0 : activeItemIndex);
    }, ...(ngDevMode ? [{ debugName: "#tabsServiceEffect" }] : []));
    onKeyDown($event) {
        if (['ArrowLeft', 'ArrowRight'].includes($event.key)) {
            this.#focusKeyManager.onKeydown($event);
            return;
        }
        if (['Tab'].includes($event.key)) {
            this.#focusKeyManager?.tabOut.next();
        }
        return;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: TabsListComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.2.0", version: "20.3.2", type: TabsListComponent, isStandalone: true, selector: "c-tabs-list", inputs: { layout: { classPropertyName: "layout", publicName: "layout", isSignal: true, isRequired: false, transformFunction: null }, variant: { classPropertyName: "variant", publicName: "variant", isSignal: true, isRequired: false, transformFunction: null }, role: { classPropertyName: "role", publicName: "role", isSignal: true, isRequired: false, transformFunction: null } }, host: { listeners: { "keydown": "onKeyDown($event)" }, properties: { "attr.role": "role()", "class": "hostClasses()" } }, queries: [{ propertyName: "tabs", predicate: TabDirective, isSignal: true }], exportAs: ["cTabsList"], ngImport: i0, template: '<ng-content />', isInline: true });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: TabsListComponent, decorators: [{
            type: Component,
            args: [{
                    exportAs: 'cTabsList',
                    selector: 'c-tabs-list',
                    template: '<ng-content />',
                    host: {
                        '[attr.role]': 'role()',
                        '[class]': 'hostClasses()',
                        '(keydown)': 'onKeyDown($event)'
                    }
                }]
        }], ctorParameters: () => [] });

class TabsContentComponent {
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: TabsContentComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "20.3.2", type: TabsContentComponent, isStandalone: true, selector: "c-tabs-content", host: { classAttribute: "tab-content" }, exportAs: ["cTabsContent"], ngImport: i0, template: '<ng-content />', isInline: true });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: TabsContentComponent, decorators: [{
            type: Component,
            args: [{
                    exportAs: 'cTabsContent',
                    selector: 'c-tabs-content',
                    template: '<ng-content />',
                    host: {
                        class: 'tab-content'
                    }
                }]
        }] });

class TabPanelComponent {
    tabsService = inject(TabsService);
    /**
     * aria-labelledby attribute
     * @type string
     * @default undefined
     */
    ariaLabelledBy = input(undefined, ...(ngDevMode ? [{ debugName: "ariaLabelledBy", alias: 'aria-labelledby' }] : [{
            alias: 'aria-labelledby'
        }]));
    /**
     * Element id attribute
     * @type string
     * @default undefined
     */
    id = input(...(ngDevMode ? [undefined, { debugName: "id" }] : []));
    /**
     * Item key.
     * @type string | number
     * @required
     */
    itemKey = input.required(...(ngDevMode ? [{ debugName: "itemKey" }] : []));
    /**
     * Element role.
     * @type string
     * @default 'tabpanel'
     */
    role = input('tabpanel', ...(ngDevMode ? [{ debugName: "role" }] : []));
    /**
     * tabindex attribute.
     * @type number
     * @default 0
     */
    tabindex = input(0, ...(ngDevMode ? [{ debugName: "tabindex", transform: numberAttribute }] : [{ transform: numberAttribute }]));
    /**
     * Enable fade in transition.
     * @type boolean
     * @default true
     */
    transition = input(true, ...(ngDevMode ? [{ debugName: "transition" }] : []));
    /**
     * visible change output
     * @type OutputEmitterRef<VisibleChangeEvent>
     */
    visibleChange = output();
    show = signal(false, ...(ngDevMode ? [{ debugName: "show" }] : []));
    visible = computed(() => {
        const visible = this.tabsService.activeItemKey() === this.itemKey() && !this.tabsService.activeItem()?.disabled;
        this.visibleChange?.emit({ itemKey: this.itemKey(), visible });
        return visible;
    }, ...(ngDevMode ? [{ debugName: "visible" }] : []));
    propId = computed(() => this.id() ?? `${this.tabsService.id()}-panel-${this.itemKey()}`, ...(ngDevMode ? [{ debugName: "propId" }] : []));
    attrAriaLabelledBy = computed(() => this.ariaLabelledBy() ?? `${this.tabsService.id()}-tab-${this.itemKey()}`, ...(ngDevMode ? [{ debugName: "attrAriaLabelledBy" }] : []));
    hostClasses = computed(() => ({
        'tab-pane': true,
        active: this.show(),
        fade: this.transition(),
        show: this.show(),
        invisible: this.tabsService.activeItem()?.disabled
    }), ...(ngDevMode ? [{ debugName: "hostClasses" }] : []));
    onAnimationDone($event) {
        this.show.set(this.visible());
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: TabPanelComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.1.0", version: "20.3.2", type: TabPanelComponent, isStandalone: true, selector: "c-tab-panel", inputs: { ariaLabelledBy: { classPropertyName: "ariaLabelledBy", publicName: "aria-labelledby", isSignal: true, isRequired: false, transformFunction: null }, id: { classPropertyName: "id", publicName: "id", isSignal: true, isRequired: false, transformFunction: null }, itemKey: { classPropertyName: "itemKey", publicName: "itemKey", isSignal: true, isRequired: true, transformFunction: null }, role: { classPropertyName: "role", publicName: "role", isSignal: true, isRequired: false, transformFunction: null }, tabindex: { classPropertyName: "tabindex", publicName: "tabindex", isSignal: true, isRequired: false, transformFunction: null }, transition: { classPropertyName: "transition", publicName: "transition", isSignal: true, isRequired: false, transformFunction: null } }, outputs: { visibleChange: "visibleChange" }, host: { listeners: { "@fadeInOut.done": "onAnimationDone($event)" }, properties: { "class": "hostClasses()", "tabindex": "visible() ? tabindex() : -1", "attr.aria-labelledby": "attrAriaLabelledBy()", "id": "propId()", "attr.role": "role()", "@.disabled": "!transition()", "@fadeInOut": "visible() ? \"show\" : \"hide\"" } }, exportAs: ["cTabPanel"], ngImport: i0, template: '<ng-content />', isInline: true, animations: [
            trigger('fadeInOut', [
                state('show', style({ opacity: 1 })),
                state('hide', style({ opacity: 0 })),
                state('void', style({ opacity: 1 })),
                transition('* => *', [query('@*', [animateChild()], { optional: true }), animate('150ms linear')])
            ])
        ] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: TabPanelComponent, decorators: [{
            type: Component,
            args: [{
                    exportAs: 'cTabPanel',
                    selector: 'c-tab-panel',
                    template: '<ng-content />',
                    host: {
                        '[class]': 'hostClasses()',
                        '[tabindex]': 'visible() ? tabindex() : -1',
                        '[attr.aria-labelledby]': 'attrAriaLabelledBy()',
                        '[id]': 'propId()',
                        '[attr.role]': 'role()',
                        '[@.disabled]': '!transition()',
                        '[@fadeInOut]': 'visible() ? "show" : "hide"',
                        '(@fadeInOut.done)': 'onAnimationDone($event)'
                    },
                    animations: [
                        trigger('fadeInOut', [
                            state('show', style({ opacity: 1 })),
                            state('hide', style({ opacity: 0 })),
                            state('void', style({ opacity: 1 })),
                            transition('* => *', [query('@*', [animateChild()], { optional: true }), animate('150ms linear')])
                        ])
                    ]
                }]
        }] });

class Tabs2Module {
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: Tabs2Module, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
    static ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "20.3.2", ngImport: i0, type: Tabs2Module, imports: [TabsComponent, TabsListComponent, TabDirective, TabsContentComponent, TabPanelComponent], exports: [TabsComponent, TabsListComponent, TabDirective, TabsContentComponent, TabPanelComponent] });
    static ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: Tabs2Module, providers: [TabsService] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: Tabs2Module, decorators: [{
            type: NgModule,
            args: [{
                    imports: [TabsComponent, TabsListComponent, TabDirective, TabsContentComponent, TabPanelComponent],
                    exports: [TabsComponent, TabsListComponent, TabDirective, TabsContentComponent, TabPanelComponent],
                    providers: [TabsService]
                }]
        }] });

class ToasterService {
    #toasterState = new BehaviorSubject({});
    toasterState$ = this.#toasterState.asObservable();
    setState(state) {
        this.#toasterState.next({ ...state });
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: ToasterService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: ToasterService, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: ToasterService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root'
                }]
        }] });

class ToastComponent {
    changeDetectorRef = inject(ChangeDetectorRef);
    hostElement = inject(ElementRef);
    renderer = inject(Renderer2);
    toasterService = inject(ToasterService);
    dynamic = input(...(ngDevMode ? [undefined, { debugName: "dynamic" }] : []));
    placementInput = input(undefined, ...(ngDevMode ? [{ debugName: "placementInput", alias: 'placement' }] : [{ alias: 'placement' }]));
    get placement() {
        return this.placementInput();
    }
    /**
     * Auto hide the toast.
     * @return boolean
     */
    autohide = input(true, ...(ngDevMode ? [{ debugName: "autohide" }] : []));
    /**
     * Sets the color context of the component to one of CoreUI’s themed colors.
     * @return Colors
     */
    color = input('', ...(ngDevMode ? [{ debugName: "color" }] : []));
    /**
     * Delay hiding the toast (ms).
     * @return number
     */
    delay = input(5000, ...(ngDevMode ? [{ debugName: "delay", transform: numberAttribute }] : [{ transform: numberAttribute }]));
    /**
     * Apply fade transition to the toast.
     * @return boolean
     */
    fade = input(true, ...(ngDevMode ? [{ debugName: "fade" }] : []));
    /**
     * Toggle the visibility of component.
     * @return boolean
     */
    visibleInput = input(false, ...(ngDevMode ? [{ debugName: "visibleInput", transform: booleanAttribute, alias: 'visible' }] : [{ transform: booleanAttribute, alias: 'visible' }]));
    #visible = linkedSignal(this.visibleInput);
    #visibleEffect = effect(() => {
        const newValue = this.#visible();
        newValue ? this.setTimer() : this.clearTimer();
        this.visibleChange?.emit(newValue);
        this.changeDetectorRef.markForCheck();
    }, ...(ngDevMode ? [{ debugName: "#visibleEffect" }] : []));
    set visible(value) {
        this.#visible.set(value);
    }
    get visible() {
        return this.#visible();
    }
    /**
     * @ignore
     */
    index = input(0, ...(ngDevMode ? [{ debugName: "index", transform: numberAttribute }] : [{ transform: numberAttribute }]));
    /**
     * Event emitted on visibility change. [docs]
     * @return <boolean>
     */
    visibleChange = output();
    /**
     * Event emitted on timer tick. [docs]
     * @return number
     */
    timer = output();
    timerId;
    clockId;
    clockTimerId;
    _clock;
    get clock() {
        return this._clock;
    }
    set clock(value) {
        this._clock = value;
        this.timer?.emit(this._clock);
        this.changeDetectorRef.markForCheck();
    }
    animationDisabled = computed(() => {
        return !this.fade();
    }, ...(ngDevMode ? [{ debugName: "animationDisabled" }] : []));
    get animateType() {
        return this.visible ? 'show' : 'hide';
    }
    hostClasses = computed(() => {
        const color = this.color();
        return {
            toast: true,
            show: true,
            [`bg-${color}`]: !!color,
            'border-0': !!color
        };
    }, ...(ngDevMode ? [{ debugName: "hostClasses" }] : []));
    ngOnInit() {
        if (this.visible) {
            this.toasterService.setState({
                toast: this,
                show: this.visible,
                placement: this.placement
            });
            this.clearTimer();
            this.setTimer();
        }
    }
    ngOnDestroy() {
        this.clearTimer();
    }
    setTimer() {
        this.clearTimer();
        if (this.autohide() && this.visible) {
            this.timerId = this.delay() > 0 ? setTimeout(() => this.onClose(), this.delay()) : undefined;
            this.setClock();
        }
    }
    clearTimer() {
        this.clearClock();
        clearTimeout(this.timerId);
        this.timerId = undefined;
    }
    onClose() {
        this.clearTimer();
        this.toasterService.setState({
            toast: this,
            show: false,
            placement: this.placement
        });
    }
    setClock() {
        this.clearClock();
        this.clock = 0;
        this.clockId = setInterval(() => {
            this.clock += 1;
            this.changeDetectorRef.markForCheck();
        }, 1000);
        this.clockTimerId = setTimeout(() => {
            this.clearClock();
        }, this.delay());
    }
    clearClock() {
        clearTimeout(this.clockTimerId);
        clearInterval(this.clockId);
        this.clockId = undefined;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: ToastComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.1.0", version: "20.3.2", type: ToastComponent, isStandalone: true, selector: "c-toast", inputs: { dynamic: { classPropertyName: "dynamic", publicName: "dynamic", isSignal: true, isRequired: false, transformFunction: null }, placementInput: { classPropertyName: "placementInput", publicName: "placement", isSignal: true, isRequired: false, transformFunction: null }, autohide: { classPropertyName: "autohide", publicName: "autohide", isSignal: true, isRequired: false, transformFunction: null }, color: { classPropertyName: "color", publicName: "color", isSignal: true, isRequired: false, transformFunction: null }, delay: { classPropertyName: "delay", publicName: "delay", isSignal: true, isRequired: false, transformFunction: null }, fade: { classPropertyName: "fade", publicName: "fade", isSignal: true, isRequired: false, transformFunction: null }, visibleInput: { classPropertyName: "visibleInput", publicName: "visible", isSignal: true, isRequired: false, transformFunction: null }, index: { classPropertyName: "index", publicName: "index", isSignal: true, isRequired: false, transformFunction: null } }, outputs: { visibleChange: "visibleChange", timer: "timer" }, host: { listeners: { "mouseover": "clearTimer()", "mouseout": "setTimer()" }, properties: { "class": "hostClasses()", "@fadeInOut": "animateType", "@.disabled": "animationDisabled()" }, classAttribute: "toast show" }, exportAs: ["cToast"], ngImport: i0, template: '<ng-content />', isInline: true, styles: [":host{display:block;overflow:hidden}\n"], animations: [
            trigger('fadeInOut', [
                state('show', style({ opacity: 1, height: '*', padding: '*', border: '*', margin: '*' })),
                state('hide', style({ opacity: 0, height: 0, padding: 0, border: 0, margin: 0 })),
                state('void', style({ opacity: 0, height: 0, padding: 0, border: 0, margin: 0 })),
                transition('show => hide', [animate('{{ time }} {{ easing }}')], {
                    params: { time: '300ms', easing: 'ease-out' }
                }),
                transition('hide => show', [animate('{{ time }} {{ easing }}')], {
                    params: { time: '300ms', easing: 'ease-in' }
                }),
                transition('show => void', [animate('{{ time }} {{ easing }}')], {
                    params: { time: '300ms', easing: 'ease-out' }
                }),
                transition('void => show', [animate('{{ time }} {{ easing }}')], {
                    params: { time: '300ms', easing: 'ease-in' }
                })
            ])
        ] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: ToastComponent, decorators: [{
            type: Component,
            args: [{ selector: 'c-toast', template: '<ng-content />', exportAs: 'cToast', animations: [
                        trigger('fadeInOut', [
                            state('show', style({ opacity: 1, height: '*', padding: '*', border: '*', margin: '*' })),
                            state('hide', style({ opacity: 0, height: 0, padding: 0, border: 0, margin: 0 })),
                            state('void', style({ opacity: 0, height: 0, padding: 0, border: 0, margin: 0 })),
                            transition('show => hide', [animate('{{ time }} {{ easing }}')], {
                                params: { time: '300ms', easing: 'ease-out' }
                            }),
                            transition('hide => show', [animate('{{ time }} {{ easing }}')], {
                                params: { time: '300ms', easing: 'ease-in' }
                            }),
                            transition('show => void', [animate('{{ time }} {{ easing }}')], {
                                params: { time: '300ms', easing: 'ease-out' }
                            }),
                            transition('void => show', [animate('{{ time }} {{ easing }}')], {
                                params: { time: '300ms', easing: 'ease-in' }
                            })
                        ])
                    ], host: {
                        class: 'toast show',
                        '[class]': 'hostClasses()',
                        '(mouseover)': 'clearTimer()',
                        '(mouseout)': 'setTimer()',
                        '[@fadeInOut]': 'animateType',
                        '[@.disabled]': 'animationDisabled()'
                    }, styles: [":host{display:block;overflow:hidden}\n"] }]
        }] });

class ToastBodyComponent {
    toast = inject(ToastComponent, { optional: true });
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: ToastBodyComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "20.3.2", type: ToastBodyComponent, isStandalone: true, selector: "c-toast-body", host: { classAttribute: "toast-body" }, exportAs: ["cToastBody"], ngImport: i0, template: '<ng-content />', isInline: true, styles: [":host{display:block}\n"] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: ToastBodyComponent, decorators: [{
            type: Component,
            args: [{ selector: 'c-toast-body', template: '<ng-content />', exportAs: 'cToastBody', host: {
                        class: 'toast-body',
                    }, styles: [":host{display:block}\n"] }]
        }] });

class ToastCloseDirective {
    #toasterService = inject(ToasterService);
    cToastClose = input(...(ngDevMode ? [undefined, { debugName: "cToastClose" }] : []));
    toggleOpen($event) {
        $event.preventDefault();
        this.#toasterService.setState({ show: false, toast: this.cToastClose() });
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: ToastCloseDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.1.0", version: "20.3.2", type: ToastCloseDirective, isStandalone: true, selector: "[cToastClose]", inputs: { cToastClose: { classPropertyName: "cToastClose", publicName: "cToastClose", isSignal: true, isRequired: false, transformFunction: null } }, host: { listeners: { "click": "toggleOpen($event)" } }, exportAs: ["cToastClose"], ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: ToastCloseDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[cToastClose]',
                    exportAs: 'cToastClose',
                    host: {
                        '(click)': 'toggleOpen($event)'
                    }
                }]
        }] });

class ToastHeaderComponent {
    #toast = inject(ToastComponent, { optional: true });
    toast = signal(this.#toast ?? undefined, ...(ngDevMode ? [{ debugName: "toast" }] : []));
    /**
     * Add close button to a toast header
     * @return boolean
     */
    closeButton = input(true, ...(ngDevMode ? [{ debugName: "closeButton" }] : []));
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: ToastHeaderComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "20.3.2", type: ToastHeaderComponent, isStandalone: true, selector: "c-toast-header", inputs: { closeButton: { classPropertyName: "closeButton", publicName: "closeButton", isSignal: true, isRequired: false, transformFunction: null } }, host: { classAttribute: "toast-header" }, exportAs: ["cToastHeader"], ngImport: i0, template: "<ng-container>\n  <ng-content />\n  @if (closeButton()) {\n    <button [cToastClose]=\"toast()\" [style]=\"{outline: 0}\" aria-label=\"close\" cButtonClose class=\"ms-auto\"></button>\n  }\n</ng-container>\n", dependencies: [{ kind: "directive", type: ToastCloseDirective, selector: "[cToastClose]", inputs: ["cToastClose"], exportAs: ["cToastClose"] }, { kind: "directive", type: ButtonCloseDirective, selector: "[cButtonClose]", inputs: ["white"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: ToastHeaderComponent, decorators: [{
            type: Component,
            args: [{ selector: 'c-toast-header', exportAs: 'cToastHeader', imports: [ToastCloseDirective, ButtonCloseDirective], host: {
                        class: 'toast-header'
                    }, template: "<ng-container>\n  <ng-content />\n  @if (closeButton()) {\n    <button [cToastClose]=\"toast()\" [style]=\"{outline: 0}\" aria-label=\"close\" cButtonClose class=\"ms-auto\"></button>\n  }\n</ng-container>\n" }]
        }] });

class ToasterHostDirective {
    viewContainerRef = inject(ViewContainerRef);
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: ToasterHostDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "20.3.2", type: ToasterHostDirective, isStandalone: true, selector: "[cToasterHost]", exportAs: ["cToasterHost"], ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: ToasterHostDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[cToasterHost]',
                    exportAs: 'cToasterHost'
                }]
        }] });

var ToasterPlacement;
(function (ToasterPlacement) {
    ToasterPlacement["Static"] = "static";
    ToasterPlacement["TopStart"] = "top-start";
    ToasterPlacement["TopCenter"] = "top-center";
    ToasterPlacement["TopEnd"] = "top-end";
    ToasterPlacement["MiddleStart"] = "middle-start";
    ToasterPlacement["MiddleCenter"] = "middle-center";
    ToasterPlacement["MiddleEnd"] = "middle-end";
    ToasterPlacement["BottomStart"] = "bottom-start";
    ToasterPlacement["BottomCenter"] = "bottom-center";
    ToasterPlacement["BottomEnd"] = "bottom-end";
})(ToasterPlacement || (ToasterPlacement = {}));
class ToasterComponent {
    #hostElement = inject(ElementRef);
    #renderer = inject(Renderer2);
    #toasterService = inject(ToasterService);
    #destroyRef = inject(DestroyRef);
    placements = Object.values(ToasterPlacement);
    toastsDynamic = [];
    /**
     * Toaster placement
     * @return TToasterPlacement
     */
    placementInput = input(ToasterPlacement.TopEnd, ...(ngDevMode ? [{ debugName: "placementInput", alias: 'placement' }] : [{ alias: 'placement' }]));
    get placement() {
        return this.placementInput();
    }
    /**
     * Toaster position
     * @return (string | 'absolute' | 'fixed' | 'static')
     */
    position = input('absolute', ...(ngDevMode ? [{ debugName: "position" }] : []));
    toasterHost = viewChild.required(ToasterHostDirective);
    contentToasts = contentChildren(ToastComponent, ...(ngDevMode ? [{ debugName: "contentToasts", read: ViewContainerRef }] : [{ read: ViewContainerRef }]));
    #contentToastsEffect = effect(() => {
        // Ensure that the contentToasts is available before accessing it
        // temp fix for: ASSERTION ERROR: Unexpected state: no hydration info available for a given TNode, which represents a view container. [Expected=> null != undefined <=Actual]
        this.contentToasts();
    }, ...(ngDevMode ? [{ debugName: "#contentToastsEffect" }] : []));
    hostClasses = computed(() => {
        const placement = this.placement;
        const position = this.position();
        return {
            toaster: true,
            'toast-container': true,
            [`position-${position}`]: !!position,
            'top-0': placement.includes('top'),
            'top-50': placement.includes('middle'),
            'bottom-0': placement.includes('bottom'),
            'start-0': placement.includes('start'),
            'start-50': placement.includes('center'),
            'end-0': placement.includes('end'),
            'translate-middle-x': placement.includes('center') && !placement.includes('middle'),
            'translate-middle-y': placement.includes('middle') && !placement.includes('center'),
            'translate-middle': placement.includes('middle') && placement.includes('center')
        };
    }, ...(ngDevMode ? [{ debugName: "hostClasses" }] : []));
    ngOnInit() {
        this.stateToasterSubscribe();
    }
    addToast(toast, props, options) {
        const componentRef = this.toasterHost().viewContainerRef.createComponent(toast, options);
        this.toastsDynamic.push(componentRef);
        const index = this.toastsDynamic.indexOf(componentRef);
        for (const [key, value] of Object.entries(props)) {
            componentRef.setInput(key, value);
        }
        componentRef.setInput('placement', this.placement);
        componentRef.setInput('dynamic', true);
        componentRef.setInput('index', index);
        componentRef.setInput('visible', true);
        componentRef.instance['visibleChange']?.emit(true);
        componentRef.changeDetectorRef?.detectChanges();
        return componentRef;
    }
    removeToast(state) {
        this.toastsDynamic?.forEach((item) => {
            if (state.toast?.dynamic() && item.instance === state.toast) {
                item.setInput('visible', false);
                item.instance['visibleChange'].emit(false);
                item.destroy();
            }
        });
        this.contentToasts()?.forEach((item) => {
            if (state.toast && item.element.nativeElement === state.toast.hostElement.nativeElement) {
                if (!state.toast.dynamic()) {
                    state.toast.visible = false;
                }
            }
        });
    }
    stateToasterSubscribe() {
        this.#toasterService.toasterState$.pipe(takeUntilDestroyed(this.#destroyRef)).subscribe((state) => {
            if (state.show === false) {
                this.removeToast(state);
            }
            // if (state.show === true && state.toast?.dynamic() === undefined) {
            //   /* empty */
            // }
        });
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: ToasterComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.2.0", version: "20.3.2", type: ToasterComponent, isStandalone: true, selector: "c-toaster", inputs: { placementInput: { classPropertyName: "placementInput", publicName: "placement", isSignal: true, isRequired: false, transformFunction: null }, position: { classPropertyName: "position", publicName: "position", isSignal: true, isRequired: false, transformFunction: null } }, host: { properties: { "class": "hostClasses()" }, classAttribute: "toaster toast-container" }, providers: [ToasterService], queries: [{ propertyName: "contentToasts", predicate: ToastComponent, read: ViewContainerRef, isSignal: true }], viewQueries: [{ propertyName: "toasterHost", first: true, predicate: ToasterHostDirective, descendants: true, isSignal: true }], exportAs: ["cToaster"], ngImport: i0, template: "<ng-template cToasterHost />\n<ng-content />\n", dependencies: [{ kind: "directive", type: ToasterHostDirective, selector: "[cToasterHost]", exportAs: ["cToasterHost"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: ToasterComponent, decorators: [{
            type: Component,
            args: [{ selector: 'c-toaster', exportAs: 'cToaster', imports: [ToasterHostDirective], host: {
                        class: 'toaster toast-container',
                        '[class]': 'hostClasses()'
                    }, providers: [ToasterService], template: "<ng-template cToasterHost />\n<ng-content />\n" }]
        }] });

class ToastModule {
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: ToastModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
    static ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "20.3.2", ngImport: i0, type: ToastModule, imports: [ToastBodyComponent,
            ToastComponent,
            ToastCloseDirective,
            ToastHeaderComponent,
            ToasterComponent,
            ToasterHostDirective], exports: [ToastBodyComponent,
            ToastComponent,
            ToastCloseDirective,
            ToastHeaderComponent,
            ToasterComponent,
            ToasterHostDirective] });
    static ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: ToastModule, providers: [ToasterService] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: ToastModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        ToastBodyComponent,
                        ToastComponent,
                        ToastCloseDirective,
                        ToastHeaderComponent,
                        ToasterComponent,
                        ToasterHostDirective
                    ],
                    providers: [ToasterService],
                    exports: [
                        ToastBodyComponent,
                        ToastComponent,
                        ToastCloseDirective,
                        ToastHeaderComponent,
                        ToasterComponent,
                        ToasterHostDirective
                    ]
                }]
        }] });

class TooltipComponent {
    renderer = inject(Renderer2);
    /**
     * Content of tooltip
     * @type {string | TemplateRef}
     */
    content = input('', ...(ngDevMode ? [{ debugName: "content" }] : []));
    #contentEffect = effect(() => {
        this.updateView(this.content());
    }, ...(ngDevMode ? [{ debugName: "#contentEffect" }] : []));
    /**
     * Toggle the visibility of popover component.
     * @type boolean
     */
    visible = input(false, ...(ngDevMode ? [{ debugName: "visible", transform: booleanAttribute }] : [{ transform: booleanAttribute }]));
    id = input(...(ngDevMode ? [undefined, { debugName: "id" }] : []));
    role = input('tooltip', ...(ngDevMode ? [{ debugName: "role" }] : []));
    viewContainerRef = viewChild('tooltipTemplate', ...(ngDevMode ? [{ debugName: "viewContainerRef", read: ViewContainerRef }] : [{ read: ViewContainerRef }]));
    textNode;
    hostClasses = computed(() => {
        return {
            tooltip: true,
            fade: true,
            show: this.visible(),
            'bs-tooltip-auto': true
        };
    }, ...(ngDevMode ? [{ debugName: "hostClasses" }] : []));
    ngOnDestroy() {
        this.clear();
    }
    clear() {
        this.viewContainerRef()?.clear();
        if (!!this.textNode) {
            this.renderer.removeChild(this.textNode.parentNode, this.textNode);
        }
    }
    updateView(content) {
        this.clear();
        if (!content) {
            return;
        }
        if (content instanceof TemplateRef) {
            this.viewContainerRef()?.createEmbeddedView(content);
        }
        else {
            this.textNode = this.renderer.createText(content);
            const element = this.viewContainerRef()?.element.nativeElement;
            this.renderer.appendChild(element.parentNode, this.textNode);
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: TooltipComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.2.0", version: "20.3.2", type: TooltipComponent, isStandalone: true, selector: "c-tooltip", inputs: { content: { classPropertyName: "content", publicName: "content", isSignal: true, isRequired: false, transformFunction: null }, visible: { classPropertyName: "visible", publicName: "visible", isSignal: true, isRequired: false, transformFunction: null }, id: { classPropertyName: "id", publicName: "id", isSignal: true, isRequired: false, transformFunction: null }, role: { classPropertyName: "role", publicName: "role", isSignal: true, isRequired: false, transformFunction: null } }, host: { properties: { "class": "hostClasses()", "attr.role": "role()", "attr.id": "id()" }, classAttribute: "tooltip fade bs-tooltip-auto" }, viewQueries: [{ propertyName: "viewContainerRef", first: true, predicate: ["tooltipTemplate"], descendants: true, read: ViewContainerRef, isSignal: true }], ngImport: i0, template: "<ng-container>\n  <div class=\"tooltip-arrow\" data-popper-arrow></div>\n  <div class=\"tooltip-inner\">\n    <ng-container #tooltipTemplate />\n  </div>\n</ng-container>\n" });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: TooltipComponent, decorators: [{
            type: Component,
            args: [{ selector: 'c-tooltip', host: {
                        class: 'tooltip fade bs-tooltip-auto',
                        '[class]': 'hostClasses()',
                        '[attr.role]': 'role()',
                        '[attr.id]': 'id()'
                    }, template: "<ng-container>\n  <div class=\"tooltip-arrow\" data-popper-arrow></div>\n  <div class=\"tooltip-inner\">\n    <ng-container #tooltipTemplate />\n  </div>\n</ng-container>\n" }]
        }] });

class TooltipDirective {
    #renderer = inject(Renderer2);
    #hostElement = inject(ElementRef);
    #viewContainerRef = inject(ViewContainerRef);
    #listenersService = inject(ListenersService);
    #changeDetectorRef = inject(ChangeDetectorRef);
    #intersectionService = inject(IntersectionService);
    #destroyRef = inject(DestroyRef);
    #document = inject(DOCUMENT);
    /**
     * Content of tooltip
     * @return {string | TemplateRef}
     */
    content = input(undefined, ...(ngDevMode ? [{ debugName: "content", alias: 'cTooltip' }] : [{ alias: 'cTooltip' }]));
    #contentEffect = effect(() => {
        if (this.content()) {
            this.destroyTooltipElement();
        }
    }, ...(ngDevMode ? [{ debugName: "#contentEffect" }] : []));
    /**
     * Optional popper Options object, takes precedence over cPopoverPlacement prop
     * @return Partial<Options>
     */
    popperOptions = input({}, ...(ngDevMode ? [{ debugName: "popperOptions", alias: 'cTooltipOptions' }] : [{ alias: 'cTooltipOptions' }]));
    #popperOptionsEffect = effect(() => {
        this._popperOptions = {
            ...this._popperOptions,
            placement: this.placement(),
            ...this.popperOptions()
        };
    }, ...(ngDevMode ? [{ debugName: "#popperOptionsEffect" }] : []));
    popperOptionsComputed = computed(() => {
        return { placement: this.placement(), ...this._popperOptions };
    }, ...(ngDevMode ? [{ debugName: "popperOptionsComputed" }] : []));
    /**
     * Describes the placement of your component after Popper.js has applied all the modifiers that may have flipped or altered the originally provided placement property.
     * @return: 'top' | 'bottom' | 'left' | 'right'
     * @default: 'top'
     */
    placement = input('top', ...(ngDevMode ? [{ debugName: "placement", alias: 'cTooltipPlacement' }] : [{ alias: 'cTooltipPlacement' }]));
    /**
     * ElementRefDirective for positioning the tooltip on reference element
     * @return: ElementRefDirective
     * @default: undefined
     */
    reference = input(undefined, ...(ngDevMode ? [{ debugName: "reference", alias: 'cTooltipRef' }] : [{ alias: 'cTooltipRef' }]));
    referenceRef = computed(() => this.reference()?.elementRef ?? this.#hostElement, ...(ngDevMode ? [{ debugName: "referenceRef" }] : []));
    /**
     * Sets which event handlers you’d like provided to your toggle prop. You can specify one trigger or an array of them.
     * @return: 'Triggers | Triggers[]
     */
    trigger = input('hover', ...(ngDevMode ? [{ debugName: "trigger", alias: 'cTooltipTrigger' }] : [{ alias: 'cTooltipTrigger' }]));
    /**
     * Toggle the visibility of tooltip component.
     * @return boolean
     */
    visible = model(false, ...(ngDevMode ? [{ debugName: "visible", alias: 'cTooltipVisible' }] : [{ alias: 'cTooltipVisible' }]));
    #visibleEffect = afterRenderEffect({
        // this fixes RuntimeError: NG0500: During hydration Angular expected <abc> but found <xyz>.
        // Find more at https://angular.dev/errors/NG0500
        write: () => {
            this.visible() ? this.addTooltipElement() : this.removeTooltipElement();
        }
    });
    get ariaDescribedBy() {
        return this.tooltipId ? this.tooltipId : null;
    }
    tooltip;
    tooltipId;
    tooltipRef;
    popperInstance;
    _popperOptions = {
        modifiers: [
            {
                name: 'offset',
                options: {
                    offset: [0, 5]
                }
            }
        ]
    };
    ngAfterViewInit() {
        this.intersectionServiceSubscribe();
    }
    ngOnDestroy() {
        this.clearListeners();
        this.destroyTooltipElement();
    }
    ngOnInit() {
        this.setListeners();
    }
    setListeners() {
        const config = {
            hostElement: this.#hostElement,
            trigger: this.trigger(),
            callbackToggle: () => {
                this.visible.update((value) => !value);
            },
            callbackOff: () => {
                this.visible.set(false);
            },
            callbackOn: () => {
                this.visible.set(true);
            }
        };
        this.#listenersService.setListeners(config);
    }
    clearListeners() {
        this.#listenersService.clearListeners();
    }
    intersectionServiceSubscribe() {
        this.#intersectionService.createIntersectionObserver(this.referenceRef());
        this.#intersectionService.intersecting$
            .pipe(filter((next) => next.hostElement === this.referenceRef()), debounceTime(100), finalize(() => {
            this.#intersectionService.unobserve(this.referenceRef());
        }), takeUntilDestroyed(this.#destroyRef))
            .subscribe((next) => {
            this.visible.set(next.isIntersecting ? this.visible() : false);
        });
    }
    getUID(prefix) {
        let uid = prefix ?? 'random-id';
        do {
            uid = `${prefix}-${Math.floor(Math.random() * 1000000).toString(10)}`;
        } while (this.#document.getElementById(uid));
        return uid;
    }
    createTooltipElement() {
        if (!this.tooltipRef) {
            this.tooltipRef = this.#viewContainerRef.createComponent(TooltipComponent);
            // this.viewContainerRef.detach();
        }
    }
    destroyTooltipElement() {
        this.tooltip?.remove();
        this.tooltipRef?.destroy();
        // @ts-ignore
        this.tooltipRef = undefined;
        this.popperInstance?.destroy();
        this.#viewContainerRef?.detach();
        this.#viewContainerRef?.clear();
    }
    addTooltipElement() {
        if (!this.content()) {
            this.destroyTooltipElement();
            return;
        }
        if (!this.tooltipRef) {
            this.createTooltipElement();
        }
        this.tooltipRef?.setInput('content', this.content() ?? '');
        this.tooltip = this.tooltipRef?.location.nativeElement;
        this.#renderer.addClass(this.tooltip, 'd-none');
        this.#renderer.addClass(this.tooltip, 'fade');
        this.popperInstance?.destroy();
        this.#viewContainerRef.insert(this.tooltipRef.hostView);
        this.#renderer.appendChild(this.#document.body, this.tooltip);
        this.popperInstance = createPopper(this.referenceRef().nativeElement, this.tooltip, {
            ...this.popperOptionsComputed()
        });
        if (!this.visible()) {
            this.removeTooltipElement();
            return;
        }
        setTimeout(() => {
            this.tooltipId = this.getUID('tooltip');
            this.tooltipRef?.setInput('id', this.tooltipId);
            this.#renderer.removeClass(this.tooltip, 'd-none');
            this.tooltipRef?.setInput('visible', this.visible());
            this.popperInstance?.forceUpdate();
            this.#changeDetectorRef?.markForCheck();
        }, 100);
    }
    removeTooltipElement() {
        this.tooltipId = '';
        if (!this.tooltipRef) {
            return;
        }
        this.tooltipRef.setInput('visible', false);
        this.tooltipRef.setInput('id', undefined);
        this.#changeDetectorRef.markForCheck();
        setTimeout(() => {
            this.#viewContainerRef?.detach();
        }, 300);
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: TooltipDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.1.0", version: "20.3.2", type: TooltipDirective, isStandalone: true, selector: "[cTooltip]", inputs: { content: { classPropertyName: "content", publicName: "cTooltip", isSignal: true, isRequired: false, transformFunction: null }, popperOptions: { classPropertyName: "popperOptions", publicName: "cTooltipOptions", isSignal: true, isRequired: false, transformFunction: null }, placement: { classPropertyName: "placement", publicName: "cTooltipPlacement", isSignal: true, isRequired: false, transformFunction: null }, reference: { classPropertyName: "reference", publicName: "cTooltipRef", isSignal: true, isRequired: false, transformFunction: null }, trigger: { classPropertyName: "trigger", publicName: "cTooltipTrigger", isSignal: true, isRequired: false, transformFunction: null }, visible: { classPropertyName: "visible", publicName: "cTooltipVisible", isSignal: true, isRequired: false, transformFunction: null } }, outputs: { visible: "cTooltipVisibleChange" }, host: { properties: { "attr.aria-describedby": "ariaDescribedBy" } }, providers: [ListenersService, IntersectionService], exportAs: ["cTooltip"], ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: TooltipDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[cTooltip]',
                    exportAs: 'cTooltip',
                    providers: [ListenersService, IntersectionService],
                    host: { '[attr.aria-describedby]': 'ariaDescribedBy' }
                }]
        }] });

class TooltipModule {
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: TooltipModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
    static ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "20.3.2", ngImport: i0, type: TooltipModule, imports: [TooltipComponent,
            TooltipDirective], exports: [TooltipComponent,
            TooltipDirective] });
    static ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: TooltipModule });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: TooltipModule, decorators: [{
            type: NgModule,
            args: [{
                    exports: [
                        TooltipComponent,
                        TooltipDirective
                    ],
                    imports: [
                        TooltipComponent,
                        TooltipDirective
                    ]
                }]
        }] });

class WidgetStatAComponent extends CardComponent {
    /**
     * Sets the color context of the component to one of CoreUI’s themed colors.
     * @type Colors
     */
    // override readonly color = input<Colors>();
    /**
     * Title of the widget to display
     * @type string
     */
    title = input(...(ngDevMode ? [undefined, { debugName: "title" }] : []));
    /**
     * Value for your widget to display
     * @type string
     */
    value = input(...(ngDevMode ? [undefined, { debugName: "value" }] : []));
    templates = {};
    contentTemplates = contentChildren(TemplateIdDirective, ...(ngDevMode ? [{ debugName: "contentTemplates", descendants: true }] : [{ descendants: true }]));
    #contentTemplatesEffect = effect(() => {
        this.contentTemplates().forEach((child) => {
            this.templates[child.id] = child.templateRef;
        });
    }, ...(ngDevMode ? [{ debugName: "#contentTemplatesEffect" }] : []));
    hostClasses = computed(() => {
        const color = this.color();
        return {
            card: true,
            [`bg-${color}`]: !!color,
            'text-white': !!color
        };
    }, ...(ngDevMode ? [{ debugName: "hostClasses" }] : []));
    get bodyClasses() {
        return {
            'pb-0': true,
            'd-flex': true,
            'justify-content-between': true,
            'align-items-start': true
        };
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: WidgetStatAComponent, deps: null, target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "20.3.2", type: WidgetStatAComponent, isStandalone: true, selector: "c-widget-stat-a", inputs: { title: { classPropertyName: "title", publicName: "title", isSignal: true, isRequired: false, transformFunction: null }, value: { classPropertyName: "value", publicName: "value", isSignal: true, isRequired: false, transformFunction: null } }, host: { properties: { "class": "hostClasses()" }, classAttribute: "card" }, queries: [{ propertyName: "contentTemplates", predicate: TemplateIdDirective, descendants: true, isSignal: true }], exportAs: ["cWidgetStatA"], usesInheritance: true, ngImport: i0, template: "<ng-container>\n  <c-card-body [ngClass]=\"bodyClasses\">\n    <div>\n      @if (!!value() || templates?.['widgetValueTemplate']) {\n        <div class=\"fs-4 fw-semibold\">\n          <ng-container *ngTemplateOutlet=\"templates?.['widgetValueTemplate'] || defaultWidgetValueTemplate\" />\n        </div>\n      }\n      @if (!!title() || templates?.['widgetTitleTemplate']) {\n        <div>\n          <ng-container *ngTemplateOutlet=\"templates?.['widgetTitleTemplate'] || defaultWidgetTitleTemplate\" />\n        </div>\n      }\n    </div>\n    <ng-container *ngTemplateOutlet=\"templates?.['widgetActionTemplate'] || defaultWidgetActionTemplate\" />\n  </c-card-body>\n  <ng-container *ngTemplateOutlet=\"templates?.['widgetChartTemplate'] || defaultWidgetChartTemplate\" />\n</ng-container>\n\n<ng-template #defaultWidgetTitleTemplate>\n  {{ title() }}\n</ng-template>\n\n<ng-template #defaultWidgetValueTemplate>\n  {{ value() }}\n</ng-template>\n\n<ng-template #defaultWidgetChartTemplate>\n  <ng-content select=\".chart-wrapper\" />\n</ng-template>\n\n<ng-template #defaultWidgetActionTemplate>\n  <ng-content />\n</ng-template>\n", dependencies: [{ kind: "component", type: CardBodyComponent, selector: "c-card-body, [c-card-body]" }, { kind: "directive", type: NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "directive", type: NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: WidgetStatAComponent, decorators: [{
            type: Component,
            args: [{ selector: 'c-widget-stat-a', exportAs: 'cWidgetStatA', imports: [CardBodyComponent, NgClass, NgTemplateOutlet], host: { class: 'card', '[class]': 'hostClasses()' }, template: "<ng-container>\n  <c-card-body [ngClass]=\"bodyClasses\">\n    <div>\n      @if (!!value() || templates?.['widgetValueTemplate']) {\n        <div class=\"fs-4 fw-semibold\">\n          <ng-container *ngTemplateOutlet=\"templates?.['widgetValueTemplate'] || defaultWidgetValueTemplate\" />\n        </div>\n      }\n      @if (!!title() || templates?.['widgetTitleTemplate']) {\n        <div>\n          <ng-container *ngTemplateOutlet=\"templates?.['widgetTitleTemplate'] || defaultWidgetTitleTemplate\" />\n        </div>\n      }\n    </div>\n    <ng-container *ngTemplateOutlet=\"templates?.['widgetActionTemplate'] || defaultWidgetActionTemplate\" />\n  </c-card-body>\n  <ng-container *ngTemplateOutlet=\"templates?.['widgetChartTemplate'] || defaultWidgetChartTemplate\" />\n</ng-container>\n\n<ng-template #defaultWidgetTitleTemplate>\n  {{ title() }}\n</ng-template>\n\n<ng-template #defaultWidgetValueTemplate>\n  {{ value() }}\n</ng-template>\n\n<ng-template #defaultWidgetChartTemplate>\n  <ng-content select=\".chart-wrapper\" />\n</ng-template>\n\n<ng-template #defaultWidgetActionTemplate>\n  <ng-content />\n</ng-template>\n" }]
        }] });

class WidgetStatBComponent extends CardComponent {
    constructor() {
        super();
    }
    /**
     * Sets the color context of the component to one of CoreUI themed colors.
     * @type Colors
     */
    // override readonly color: InputSignal<Colors | undefined> = input();
    /**
     * Sets the text-color context of the component to one of CoreUI themed colors.
     * via TextColorDirective
     * @type TextColors
     */
    // override readonly textColor: InputSignal<TextColors | undefined> = input();
    /**
     * Title of the widget to display
     * @type string
     */
    title = input(...(ngDevMode ? [undefined, { debugName: "title" }] : []));
    /**
     * Helper text for your widget.
     * @type string
     */
    text = input(...(ngDevMode ? [undefined, { debugName: "text" }] : []));
    /**
     * Value for your widget to display
     * @type string
     */
    value = input(...(ngDevMode ? [undefined, { debugName: "value" }] : []));
    /**
     * Invert colors from their default dark shade.
     * @type boolean
     */
    inverse = input(false, ...(ngDevMode ? [{ debugName: "inverse", transform: booleanAttribute }] : [{ transform: booleanAttribute }]));
    hostClasses = computed(() => {
        const color = this.color();
        const textColor = this.textColor();
        return {
            card: true,
            [`bg-${color}`]: !!color,
            [`text-${textColor}`]: !!textColor,
            'text-white': this.inverse()
        };
    }, ...(ngDevMode ? [{ debugName: "hostClasses" }] : []));
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: WidgetStatBComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "20.3.2", type: WidgetStatBComponent, isStandalone: true, selector: "c-widget-stat-b", inputs: { title: { classPropertyName: "title", publicName: "title", isSignal: true, isRequired: false, transformFunction: null }, text: { classPropertyName: "text", publicName: "text", isSignal: true, isRequired: false, transformFunction: null }, value: { classPropertyName: "value", publicName: "value", isSignal: true, isRequired: false, transformFunction: null }, inverse: { classPropertyName: "inverse", publicName: "inverse", isSignal: true, isRequired: false, transformFunction: null } }, host: { properties: { "class": "hostClasses()" }, classAttribute: "card" }, exportAs: ["cWidgetStatB"], usesInheritance: true, ngImport: i0, template: "<c-card-body>\n  @if (!!value()) {\n    <div class=\"fs-4 fw-semibold\">{{ value() }}</div>\n  }\n  @if (!!title()) {\n    <div>{{ title() }}</div>\n  }\n  <ng-content />\n  @if (text()) {\n    <small [ngClass]=\"inverse() ? 'text-white text-opacity-75' : 'text-body-secondary'\">\n      {{ text() }}\n    </small>\n  }\n</c-card-body>\n", dependencies: [{ kind: "component", type: CardBodyComponent, selector: "c-card-body, [c-card-body]" }, { kind: "directive", type: NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: WidgetStatBComponent, decorators: [{
            type: Component,
            args: [{ selector: 'c-widget-stat-b', exportAs: 'cWidgetStatB', imports: [CardBodyComponent, NgClass], host: { class: 'card', '[class]': 'hostClasses()' }, template: "<c-card-body>\n  @if (!!value()) {\n    <div class=\"fs-4 fw-semibold\">{{ value() }}</div>\n  }\n  @if (!!title()) {\n    <div>{{ title() }}</div>\n  }\n  <ng-content />\n  @if (text()) {\n    <small [ngClass]=\"inverse() ? 'text-white text-opacity-75' : 'text-body-secondary'\">\n      {{ text() }}\n    </small>\n  }\n</c-card-body>\n" }]
        }], ctorParameters: () => [] });

class WidgetStatCComponent extends CardComponent {
    constructor() {
        super();
    }
    /**
     * Icon for your component.
     * @type string
     */
    icon = input(...(ngDevMode ? [undefined, { debugName: "icon" }] : []));
    /**
     * Title of the widget to display
     * @type string
     */
    title = input(...(ngDevMode ? [undefined, { debugName: "title" }] : []));
    /**
     * Value for your widget to display
     * @type string|number
     */
    value = input(...(ngDevMode ? [undefined, { debugName: "value" }] : []));
    /**
     * Invert colors from their default dark shade.
     * @type boolean
     */
    inverse = input(false, ...(ngDevMode ? [{ debugName: "inverse", transform: booleanAttribute }] : [{ transform: booleanAttribute }]));
    templates = {};
    contentTemplates = contentChildren(TemplateIdDirective, ...(ngDevMode ? [{ debugName: "contentTemplates", descendants: true }] : [{ descendants: true }]));
    #contentTemplatesEffect = effect(() => {
        this.contentTemplates().forEach((child) => {
            this.templates[child.id] = child.templateRef;
        });
    }, ...(ngDevMode ? [{ debugName: "#contentTemplatesEffect" }] : []));
    hostExtendedClass = computed(() => {
        return { ...this.hostClasses(), 'text-white': this.inverse() };
    }, ...(ngDevMode ? [{ debugName: "hostExtendedClass" }] : []));
    titleClasses = computed(() => {
        const inverse = this.inverse();
        return {
            'text-body-secondary': !inverse,
            'text-white': inverse,
            'text-opacity-75': inverse,
            [`text-${this.textColor()}`]: !!this.textColor()
        };
    }, ...(ngDevMode ? [{ debugName: "titleClasses" }] : []));
    valueClasses = computed(() => {
        return {
            'fs-4': !this.textColor(),
            'fw-semibold': true,
            ...this.titleClasses(),
            'text-opacity-75': false
        };
    }, ...(ngDevMode ? [{ debugName: "valueClasses" }] : []));
    iconClasses = computed(() => {
        return {
            'mb-4': !this.textColor(),
            'text-end': true,
            ...this.titleClasses()
        };
    }, ...(ngDevMode ? [{ debugName: "iconClasses" }] : []));
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: WidgetStatCComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "20.3.2", type: WidgetStatCComponent, isStandalone: true, selector: "c-widget-stat-c", inputs: { icon: { classPropertyName: "icon", publicName: "icon", isSignal: true, isRequired: false, transformFunction: null }, title: { classPropertyName: "title", publicName: "title", isSignal: true, isRequired: false, transformFunction: null }, value: { classPropertyName: "value", publicName: "value", isSignal: true, isRequired: false, transformFunction: null }, inverse: { classPropertyName: "inverse", publicName: "inverse", isSignal: true, isRequired: false, transformFunction: null } }, host: { properties: { "class": "hostExtendedClass()" } }, queries: [{ propertyName: "contentTemplates", predicate: TemplateIdDirective, descendants: true, isSignal: true }], exportAs: ["cWidgetStatC"], usesInheritance: true, ngImport: i0, template: "<c-card-body>\n  @if (icon() || templates?.['widgetIconTemplate']) {\n    <div [ngClass]=\"iconClasses()\">\n      <ng-container *ngTemplateOutlet=\"templates?.['widgetIconTemplate'] || defaultWidgetIconTemplate\" />\n    </div>\n  }\n  @if (!!value()) {\n    <div [ngClass]=\"valueClasses()\">\n      {{ value() }}\n    </div>\n  }\n  @if (!!title()) {\n    <div [ngClass]=\"titleClasses()\">\n      {{ title() }}\n    </div>\n  }\n  @if (templates?.['widgetProgressTemplate']) {\n    <ng-container *ngTemplateOutlet=\"templates?.['widgetProgressTemplate'] || defaultWidgetProgressTemplate\" />\n  }\n</c-card-body>\n\n<ng-template #defaultWidgetIconTemplate>\n  {{ icon() }}\n</ng-template>\n\n<ng-template #defaultWidgetProgressTemplate>\n  <ng-content />\n</ng-template>\n", dependencies: [{ kind: "component", type: CardBodyComponent, selector: "c-card-body, [c-card-body]" }, { kind: "directive", type: NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "directive", type: NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: WidgetStatCComponent, decorators: [{
            type: Component,
            args: [{ selector: 'c-widget-stat-c', exportAs: 'cWidgetStatC', imports: [CardBodyComponent, NgClass, NgTemplateOutlet], host: { '[class]': 'hostExtendedClass()' }, template: "<c-card-body>\n  @if (icon() || templates?.['widgetIconTemplate']) {\n    <div [ngClass]=\"iconClasses()\">\n      <ng-container *ngTemplateOutlet=\"templates?.['widgetIconTemplate'] || defaultWidgetIconTemplate\" />\n    </div>\n  }\n  @if (!!value()) {\n    <div [ngClass]=\"valueClasses()\">\n      {{ value() }}\n    </div>\n  }\n  @if (!!title()) {\n    <div [ngClass]=\"titleClasses()\">\n      {{ title() }}\n    </div>\n  }\n  @if (templates?.['widgetProgressTemplate']) {\n    <ng-container *ngTemplateOutlet=\"templates?.['widgetProgressTemplate'] || defaultWidgetProgressTemplate\" />\n  }\n</c-card-body>\n\n<ng-template #defaultWidgetIconTemplate>\n  {{ icon() }}\n</ng-template>\n\n<ng-template #defaultWidgetProgressTemplate>\n  <ng-content />\n</ng-template>\n" }]
        }], ctorParameters: () => [] });

class WidgetStatDComponent extends CardComponent {
    /**
     * Sets the color context of the component to one of CoreUI’s themed colors.
     * @type Colors
     */
    // override readonly color = input<Colors>();
    /**
     * Values and subtitles for your component.
     * @type WidgetStatDValue
     */
    values = input(...(ngDevMode ? [undefined, { debugName: "values" }] : []));
    headerClasses = computed(() => {
        return {
            'position-relative': true,
            'd-flex': true,
            'justify-content-center': true,
            'align-items-center': true,
            [`bg-${this.color()}`]: this.color()
        };
    }, ...(ngDevMode ? [{ debugName: "headerClasses" }] : []));
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: WidgetStatDComponent, deps: null, target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "20.3.2", type: WidgetStatDComponent, isStandalone: true, selector: "c-widget-stat-d", inputs: { values: { classPropertyName: "values", publicName: "values", isSignal: true, isRequired: false, transformFunction: null } }, host: { classAttribute: "card" }, exportAs: ["cWidgetStatD"], usesInheritance: true, ngImport: i0, template: "<c-card-header [ngClass]=\"headerClasses()\">\n  <ng-content />\n</c-card-header>\n<c-card-body cRow class=\"text-center\">\n  @for (item of values(); track item; let i = $index) {\n    @if (i % 2 !== 0) {\n      <div class=\"vr\"></div>\n    }\n    <c-col>\n      <div class=\"fs-5 fw-semibold\">{{ item.value }}</div>\n      <div class=\"text-uppercase text-body-secondary small\">{{ item.title }}</div>\n    </c-col>\n  }\n</c-card-body>\n", dependencies: [{ kind: "component", type: CardHeaderComponent, selector: "c-card-header, [c-card-header]" }, { kind: "component", type: CardBodyComponent, selector: "c-card-body, [c-card-body]" }, { kind: "component", type: ColComponent, selector: "c-col" }, { kind: "directive", type: RowDirective, selector: "[cRow]", inputs: ["xs", "sm", "md", "lg", "xl", "xxl"] }, { kind: "directive", type: NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: WidgetStatDComponent, decorators: [{
            type: Component,
            args: [{ selector: 'c-widget-stat-d', exportAs: 'cWidgetStatD', imports: [CardHeaderComponent, CardBodyComponent, ColComponent, RowDirective, NgClass], host: { class: 'card' }, template: "<c-card-header [ngClass]=\"headerClasses()\">\n  <ng-content />\n</c-card-header>\n<c-card-body cRow class=\"text-center\">\n  @for (item of values(); track item; let i = $index) {\n    @if (i % 2 !== 0) {\n      <div class=\"vr\"></div>\n    }\n    <c-col>\n      <div class=\"fs-5 fw-semibold\">{{ item.value }}</div>\n      <div class=\"text-uppercase text-body-secondary small\">{{ item.title }}</div>\n    </c-col>\n  }\n</c-card-body>\n" }]
        }] });

class WidgetStatEComponent extends CardComponent {
    constructor() {
        super();
    }
    /**
     * Title of the widget to display
     * @type string
     */
    title = input(...(ngDevMode ? [undefined, { debugName: "title" }] : []));
    /**
     * Value for your widget to display
     * @type string | number
     */
    value = input(...(ngDevMode ? [undefined, { debugName: "value" }] : []));
    titleClasses = computed(() => {
        const textColor = this.textColor();
        return {
            'text-body-secondary': !textColor,
            small: true,
            'text-uppercase': true,
            'fw-semibold': true,
            [`text-${textColor}`]: !!textColor
        };
    }, ...(ngDevMode ? [{ debugName: "titleClasses" }] : []));
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: WidgetStatEComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "20.3.2", type: WidgetStatEComponent, isStandalone: true, selector: "c-widget-stat-e", inputs: { title: { classPropertyName: "title", publicName: "title", isSignal: true, isRequired: false, transformFunction: null }, value: { classPropertyName: "value", publicName: "value", isSignal: true, isRequired: false, transformFunction: null } }, exportAs: ["cWidgetStatE"], usesInheritance: true, ngImport: i0, template: "<c-card-body class=\"text-center\">\n  @if (!!title()) {\n    <div [ngClass]=\"titleClasses()\">{{ title() }}</div>\n  }\n  @if (!!value()) {\n    <div class=\"fs-6 fw-semibold py-3\">{{ value() }}</div>\n  }\n  <ng-content />\n</c-card-body>\n", dependencies: [{ kind: "component", type: CardBodyComponent, selector: "c-card-body, [c-card-body]" }, { kind: "directive", type: NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: WidgetStatEComponent, decorators: [{
            type: Component,
            args: [{ selector: 'c-widget-stat-e', exportAs: 'cWidgetStatE', imports: [CardBodyComponent, NgClass], template: "<c-card-body class=\"text-center\">\n  @if (!!title()) {\n    <div [ngClass]=\"titleClasses()\">{{ title() }}</div>\n  }\n  @if (!!value()) {\n    <div class=\"fs-6 fw-semibold py-3\">{{ value() }}</div>\n  }\n  <ng-content />\n</c-card-body>\n" }]
        }], ctorParameters: () => [] });

class WidgetStatFComponent extends CardComponent {
    /**
     * Sets the color context of the component to one of CoreUI’s themed colors.
     * @type Colors
     */
    // override readonly color = input<Colors>();
    /**
     * Sets the text-color context of the component to one of CoreUI’s themed colors.
     * @type Colors
     */
    // override readonly textColor = input<TextColors | 'white' | 'muted'>();
    /**
     * Footer for your widget
     * @type string
     */
    footer = input(...(ngDevMode ? [undefined, { debugName: "footer" }] : []));
    /**
     * Icon for your widget
     * @type string
     */
    icon = input(...(ngDevMode ? [undefined, { debugName: "icon" }] : []));
    /**
     * Set padding of your component.
     * @type boolean
     */
    padding = input(false, ...(ngDevMode ? [{ debugName: "padding", transform: booleanAttribute }] : [{ transform: booleanAttribute }]));
    /**
     * Title of the widget to display
     * @type string
     */
    title = input(...(ngDevMode ? [undefined, { debugName: "title" }] : []));
    /**
     * Value for your widget to display
     * @type string
     */
    value = input(...(ngDevMode ? [undefined, { debugName: "value" }] : []));
    templates = {};
    contentTemplates = contentChildren(TemplateIdDirective, ...(ngDevMode ? [{ debugName: "contentTemplates", descendants: true }] : [{ descendants: true }]));
    #contentTemplatesEffect = effect(() => {
        this.contentTemplates().forEach((child) => {
            this.templates[child.id] = child.templateRef;
        });
    }, ...(ngDevMode ? [{ debugName: "#contentTemplatesEffect" }] : []));
    cardBodyClasses = computed(() => {
        return {
            'd-flex': true,
            'align-items-center': true,
            'p-0': !this.padding()
        };
    }, ...(ngDevMode ? [{ debugName: "cardBodyClasses" }] : []));
    iconClasses = computed(() => {
        const color = this.color();
        const padding = this.padding();
        return {
            'me-3': !this.textColor(),
            'text-white': true,
            [`bg-${color}`]: !!color,
            'p-3': padding,
            'p-4': !padding,
            'rounded-start-1': !padding
        };
    }, ...(ngDevMode ? [{ debugName: "iconClasses" }] : []));
    titleClasses = computed(() => {
        const textColor = this.textColor();
        return {
            'text-body-secondary': !textColor,
            small: true,
            'text-uppercase': true,
            'fw-semibold': true,
            [`text-${textColor}`]: !!textColor
        };
    }, ...(ngDevMode ? [{ debugName: "titleClasses" }] : []));
    valueClasses = computed(() => {
        const textColor = this.textColor();
        return {
            'fs-6': !textColor,
            'fw-semibold': true,
            [`text-${textColor}`]: !!textColor
        };
    }, ...(ngDevMode ? [{ debugName: "valueClasses" }] : []));
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: WidgetStatFComponent, deps: null, target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "20.3.2", type: WidgetStatFComponent, isStandalone: true, selector: "c-widget-stat-f", inputs: { footer: { classPropertyName: "footer", publicName: "footer", isSignal: true, isRequired: false, transformFunction: null }, icon: { classPropertyName: "icon", publicName: "icon", isSignal: true, isRequired: false, transformFunction: null }, padding: { classPropertyName: "padding", publicName: "padding", isSignal: true, isRequired: false, transformFunction: null }, title: { classPropertyName: "title", publicName: "title", isSignal: true, isRequired: false, transformFunction: null }, value: { classPropertyName: "value", publicName: "value", isSignal: true, isRequired: false, transformFunction: null } }, host: { properties: { "class": "hostClasses()" }, classAttribute: "card" }, queries: [{ propertyName: "contentTemplates", predicate: TemplateIdDirective, descendants: true, isSignal: true }], exportAs: ["cWidgetStatB"], usesInheritance: true, ngImport: i0, template: "<ng-container>\n  <c-card-body [ngClass]=\"cardBodyClasses()\">\n    <div [ngClass]=\"iconClasses()\">\n      <ng-container *ngTemplateOutlet=\"templates?.['widgetIconTemplate'] || defaultWidgetIconTemplate\" />\n    </div>\n    <div>\n      <div [ngClass]=\"valueClasses()\">{{ value() }}</div>\n      <div [ngClass]=\"titleClasses()\">{{ title() }}</div>\n    </div>\n  </c-card-body>\n  @if (footer() || templates?.['widgetFooterTemplate']) {\n    <c-card-footer>\n      <ng-container *ngTemplateOutlet=\"templates?.['widgetFooterTemplate'] || defaultFooterIconTemplate\" />\n    </c-card-footer>\n  }\n</ng-container>\n\n<ng-template #defaultWidgetIconTemplate>\n  <span>{{ icon() }}</span>\n</ng-template>\n\n<ng-template #defaultFooterIconTemplate>\n  <span>{{ footer() }}</span>\n</ng-template>\n", dependencies: [{ kind: "component", type: CardBodyComponent, selector: "c-card-body, [c-card-body]" }, { kind: "component", type: CardFooterComponent, selector: "c-card-footer, [c-card-footer]" }, { kind: "directive", type: NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "directive", type: NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: WidgetStatFComponent, decorators: [{
            type: Component,
            args: [{ selector: 'c-widget-stat-f', exportAs: 'cWidgetStatB', imports: [CardBodyComponent, CardFooterComponent, NgClass, NgTemplateOutlet], host: { class: 'card', '[class]': 'hostClasses()' }, template: "<ng-container>\n  <c-card-body [ngClass]=\"cardBodyClasses()\">\n    <div [ngClass]=\"iconClasses()\">\n      <ng-container *ngTemplateOutlet=\"templates?.['widgetIconTemplate'] || defaultWidgetIconTemplate\" />\n    </div>\n    <div>\n      <div [ngClass]=\"valueClasses()\">{{ value() }}</div>\n      <div [ngClass]=\"titleClasses()\">{{ title() }}</div>\n    </div>\n  </c-card-body>\n  @if (footer() || templates?.['widgetFooterTemplate']) {\n    <c-card-footer>\n      <ng-container *ngTemplateOutlet=\"templates?.['widgetFooterTemplate'] || defaultFooterIconTemplate\" />\n    </c-card-footer>\n  }\n</ng-container>\n\n<ng-template #defaultWidgetIconTemplate>\n  <span>{{ icon() }}</span>\n</ng-template>\n\n<ng-template #defaultFooterIconTemplate>\n  <span>{{ footer() }}</span>\n</ng-template>\n" }]
        }] });

class WidgetModule {
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: WidgetModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
    static ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "20.3.2", ngImport: i0, type: WidgetModule, imports: [WidgetStatAComponent,
            WidgetStatBComponent,
            WidgetStatCComponent,
            WidgetStatDComponent,
            WidgetStatEComponent,
            WidgetStatFComponent], exports: [WidgetStatAComponent,
            WidgetStatBComponent,
            WidgetStatCComponent,
            WidgetStatDComponent,
            WidgetStatEComponent,
            WidgetStatFComponent] });
    static ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: WidgetModule });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.2", ngImport: i0, type: WidgetModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        WidgetStatAComponent,
                        WidgetStatBComponent,
                        WidgetStatCComponent,
                        WidgetStatDComponent,
                        WidgetStatEComponent,
                        WidgetStatFComponent
                    ],
                    exports: [
                        WidgetStatAComponent,
                        WidgetStatBComponent,
                        WidgetStatCComponent,
                        WidgetStatDComponent,
                        WidgetStatEComponent,
                        WidgetStatFComponent
                    ]
                }]
        }] });

/*
 * Public API Surface of coreui-angular
 */

/**
 * Generated bundle index. Do not edit.
 */

export { AccordionButtonDirective, AccordionComponent, AccordionItemComponent, AccordionModule, AlertComponent, AlertHeadingDirective, AlertLinkDirective, AlertModule, AlignDirective, AvatarComponent, AvatarModule, BackdropService, BadgeComponent, BadgeModule, BgColorDirective, BorderDirective, BreadcrumbComponent, BreadcrumbItemComponent, BreadcrumbModule, BreadcrumbRouterComponent, BreadcrumbRouterService, BreakpointInfix, ButtonCloseDirective, ButtonDirective, ButtonGroupComponent, ButtonGroupModule, ButtonModule, ButtonToolbarComponent, CalloutComponent, CalloutModule, CardBodyComponent, CardComponent, CardFooterComponent, CardGroupComponent, CardHeaderActionsComponent, CardHeaderComponent, CardImgDirective, CardImgOverlayComponent, CardLinkDirective, CardModule, CardSubtitleDirective, CardTextDirective, CardTitleDirective, CarouselCaptionComponent, CarouselComponent, CarouselConfig, CarouselControlComponent, CarouselIndicatorsComponent, CarouselInnerComponent, CarouselItemComponent, CarouselModule, ClassToggleService, ColComponent, ColDirective, CollapseDirective, CollapseModule, ColorModeService, ContainerComponent, DropdownCloseDirective, DropdownComponent, DropdownDividerDirective, DropdownHeaderDirective, DropdownItemDirective, DropdownItemPlainDirective, DropdownMenuDirective, DropdownModule, DropdownService, DropdownToggleDirective, ElementRefDirective, FooterComponent, FooterModule, FormCheckComponent, FormCheckInputDirective, FormCheckLabelDirective, FormControlDirective, FormDirective, FormFeedbackComponent, FormFloatingDirective, FormLabelDirective, FormModule, FormSelectDirective, FormTextDirective, GridModule, GutterDirective, HeaderBrandComponent, HeaderComponent, HeaderDividerComponent, HeaderModule, HeaderNavComponent, HeaderTextComponent, HeaderTogglerDirective, HtmlAttributesDirective, ImgDirective, ImgModule, InMemoryStorageService, InputGroupComponent, InputGroupTextDirective, IntersectionService, ListGroupDirective, ListGroupItemDirective, ListGroupModule, ListenersService, LocalStorageService, ModalBodyComponent, ModalComponent, ModalContentComponent, ModalDialogComponent, ModalFooterComponent, ModalHeaderComponent, ModalModule, ModalService, ModalTitleDirective, ModalToggleDirective, NavComponent, NavItemComponent, NavLinkDirective, NavModule, NavbarBrandDirective, NavbarComponent, NavbarModule, NavbarNavComponent, NavbarTextComponent, NavbarTogglerDirective, OffcanvasBodyComponent, OffcanvasComponent, OffcanvasHeaderComponent, OffcanvasModule, OffcanvasService, OffcanvasTitleDirective, OffcanvasToggleDirective, PageItemComponent, PageItemDirective, PageLinkDirective, PaginationComponent, PaginationModule, PlaceholderAnimationDirective, PlaceholderDirective, PlaceholderModule, PopoverComponent, PopoverDirective, PopoverModule, ProgressBarComponent, ProgressBarDirective, ProgressComponent, ProgressModule, ProgressStackedComponent, RoundedDirective, RowComponent, RowDirective, RtlService, ShadowOnScrollDirective, SharedModule, SidebarBrandComponent, SidebarComponent, SidebarFooterComponent, SidebarHeaderComponent, SidebarModule, SidebarNavComponent, SidebarNavHelper, SidebarService, SidebarToggleDirective, SidebarTogglerDirective, SpinnerComponent, SpinnerModule, TabContentComponent, TabContentRefDirective, TabDirective, TabPaneComponent, TabPanelComponent, TabService, TableActiveDirective, TableColorDirective, TableDirective, TableModule, Tabs2Module, TabsComponent, TabsContentComponent, TabsListComponent, TabsModule, TabsService, TemplateIdDirective, TextBgColorDirective, TextColorDirective, ThemeDirective, ToastBodyComponent, ToastCloseDirective, ToastComponent, ToastHeaderComponent, ToastModule, ToasterComponent, ToasterHostDirective, ToasterPlacement, ToasterService, TooltipComponent, TooltipDirective, TooltipModule, UIDService, UtilitiesModule, WidgetModule, WidgetStatAComponent, WidgetStatBComponent, WidgetStatCComponent, WidgetStatDComponent, WidgetStatEComponent, WidgetStatFComponent };
//# sourceMappingURL=coreui-angular.mjs.map
