import { IsActiveMatchOptions, UrlTree, Router, NavigationEnd } from '@angular/router';
import * as i0 from '@angular/core';
import { ElementRef, TemplateRef, ModuleWithProviders, OnInit, OnDestroy, InputSignal, InputSignalWithTransform, AfterContentInit, AfterContentChecked, AfterViewInit, Renderer2, ViewContainerRef, WritableSignal, OnChanges, SimpleChanges, PipeTransform, QueryList, ModelSignal, OutputEmitterRef, ComponentRef, Injector, NgModuleRef, ChangeDetectorRef } from '@angular/core';
import { AnimationEvent } from '@angular/animations';
import * as rxjs from 'rxjs';
import { Observable, Subscription } from 'rxjs';
import { FocusableOption, FocusOrigin } from '@angular/cdk/a11y';
import * as _popperjs_core from '@popperjs/core';
import { Placement, Options } from '@popperjs/core';
import { BooleanInput as BooleanInput$1, NumberInput as NumberInput$1 } from '@angular/cdk/coercion';

declare type BooleanInput = string | boolean | null | undefined;
declare type NumberInput = string | number | null | undefined;
type NgCssClass = string | string[] | Set<string> | {
    [klass: string]: any;
};
declare enum BreakpointInfix {
    xs = "xs",
    sm = "sm",
    md = "md",
    lg = "lg",
    xl = "xl",
    xxl = "xxl"
}
type BreakpointInfixStrings = keyof typeof BreakpointInfix;
type Breakpoints = BreakpointInfixStrings | string;
type Sizes = 'sm' | 'md' | 'lg' | 'xl' | 'xxl' | string;
type Colors = 'primary' | 'secondary' | 'success' | 'danger' | 'warning' | 'info' | 'dark' | 'light' | 'primary-gradient' | 'secondary-gradient' | 'success-gradient' | 'danger-gradient' | 'warning-gradient' | 'info-gradient' | 'dark-gradient' | 'light-gradient' | string;
type BackgroundColors = Colors | 'body' | 'white' | 'transparent';
type Directions = 'down' | 'up' | 'start' | 'end' | '';
type TextColors = Colors | 'primary-emphasis' | 'secondary-emphasis' | 'success-emphasis' | 'danger-emphasis' | 'warning-emphasis' | 'info-emphasis' | 'light-emphasis' | 'body' | 'body-emphasis' | 'body-secondary' | 'body-tertiary' | 'black' | 'black-50' | 'white' | 'white-50' | string;
type Alignment = 'baseline' | 'top' | 'middle' | 'bottom' | 'text-top' | 'text-bottom';
type BadgePositions = 'top-start' | 'top-end' | 'bottom-end' | 'bottom-start' | string | undefined;
type Placements = 'auto' | 'auto-start' | 'auto-end' | 'top-end' | 'top' | 'top-start' | 'bottom-end' | 'bottom' | 'bottom-start' | 'right-start' | 'right' | 'right-end' | 'left-start' | 'left' | 'left-end' | undefined;
type Shapes = 'rounded' | 'rounded-top' | 'rounded-end' | 'rounded-bottom' | 'rounded-start' | 'rounded-circle' | 'rounded-pill' | 'rounded-0' | 'rounded-1' | 'rounded-2' | 'rounded-3' | string;
type Triggers = 'hover' | 'focus' | 'click' | 'focusin';
type Positions = 'fixed' | 'sticky';
type InputType = 'button' | 'color' | 'date' | 'datetime' | 'datetime-local' | 'email' | 'file' | 'hidden' | 'image' | 'month' | 'number' | 'password' | 'range' | 'reset' | 'search' | 'submit' | 'tel' | 'text' | 'time' | 'url' | 'week' | 'checkbox' | 'radio';
interface INavLinkProps$1 {
    queryParams?: {
        [k: string]: any;
    };
    fragment?: string;
    queryParamsHandling?: 'merge' | 'preserve' | '' | null;
    preserveFragment?: boolean;
    skipLocationChange?: boolean;
    replaceUrl?: boolean;
    state?: {
        [k: string]: any;
    };
    routerLinkActiveOptions?: {
        exact: boolean;
    } | IsActiveMatchOptions;
    routerLinkActive?: string | string[];
    ariaCurrentWhenActive?: 'page' | 'step' | 'location' | 'date' | 'time' | true | false;
}
interface INavAttributes$1 {
    [propName: string]: any;
}
type ButtonType = 'button' | 'submit' | 'reset';

declare class ElementRefDirective {
    readonly elementRef: ElementRef<any>;
    static ɵfac: i0.ɵɵFactoryDeclaration<ElementRefDirective, never>;
    static ɵdir: i0.ɵɵDirectiveDeclaration<ElementRefDirective, "[cElementRef]", ["cElementRef"], {}, {}, never, never, true, never>;
}

declare class HtmlAttributesDirective {
    #private;
    readonly cHtmlAttr: i0.InputSignal<Record<string, any> | undefined>;
    private setStyle;
    private addClass;
    private setAttrib;
    static ɵfac: i0.ɵɵFactoryDeclaration<HtmlAttributesDirective, never>;
    static ɵdir: i0.ɵɵDirectiveDeclaration<HtmlAttributesDirective, "[cHtmlAttr]", ["cHtmlAttr"], { "cHtmlAttr": { "alias": "cHtmlAttr"; "required": false; "isSignal": true; }; }, {}, never, never, true, never>;
}

declare class TemplateIdDirective {
    readonly templateRef: TemplateRef<any>;
    readonly cTemplateId: i0.InputSignal<string>;
    get id(): string;
    static ɵfac: i0.ɵɵFactoryDeclaration<TemplateIdDirective, never>;
    static ɵdir: i0.ɵɵDirectiveDeclaration<TemplateIdDirective, "[cTemplateId]", never, { "cTemplateId": { "alias": "cTemplateId"; "required": true; "isSignal": true; }; }, {}, never, never, true, never>;
}

declare class ThemeDirective {
    #private;
    /**
     * Add dark theme attribute.
     * @return 'dark' | 'light' | undefined
     */
    readonly colorScheme: i0.InputSignal<"dark" | "light" | undefined>;
    readonly dark: i0.InputSignalWithTransform<boolean, unknown>;
    setTheme(theme?: string): void;
    unsetTheme(): void;
    static ɵfac: i0.ɵɵFactoryDeclaration<ThemeDirective, never>;
    static ɵdir: i0.ɵɵDirectiveDeclaration<ThemeDirective, "[cTheme]", ["cTheme"], { "colorScheme": { "alias": "colorScheme"; "required": false; "isSignal": true; }; "dark": { "alias": "dark"; "required": false; "isSignal": true; }; }, {}, never, never, true, never>;
}

declare class SharedModule {
    static forRoot(): ModuleWithProviders<SharedModule>;
    static ɵfac: i0.ɵɵFactoryDeclaration<SharedModule, never>;
    static ɵmod: i0.ɵɵNgModuleDeclaration<SharedModule, never, [typeof ElementRefDirective, typeof HtmlAttributesDirective, typeof TemplateIdDirective, typeof ThemeDirective], [typeof ElementRefDirective, typeof HtmlAttributesDirective, typeof TemplateIdDirective, typeof ThemeDirective]>;
    static ɵinj: i0.ɵɵInjectorDeclaration<SharedModule>;
}

declare class AccordionButtonDirective {
    /**
     * Toggles an accordion button collapsed state. Use in accordionHeaderTemplate. [docs]
     * @type boolean
     */
    readonly collapsed: i0.InputSignal<boolean | undefined>;
    /**
     * Default type for cAccordionButton. [docs]
     * @type string
     * @default 'button'
     */
    readonly type: i0.InputSignal<string>;
    readonly hostClasses: i0.Signal<Record<string, boolean>>;
    readonly ariaExpanded: i0.Signal<boolean>;
    static ɵfac: i0.ɵɵFactoryDeclaration<AccordionButtonDirective, never>;
    static ɵdir: i0.ɵɵDirectiveDeclaration<AccordionButtonDirective, "[cAccordionButton]", never, { "collapsed": { "alias": "collapsed"; "required": false; "isSignal": true; }; "type": { "alias": "type"; "required": false; "isSignal": true; }; }, {}, never, never, true, never>;
}

declare class AccordionComponent {
    #private;
    /**
     * Removes the default background-color, some borders, and some rounded corners to render accordions edge-to-edge with their parent container.
     * @type boolean
     */
    readonly flush: i0.InputSignalWithTransform<boolean, unknown>;
    /**
     * Make accordion items stay open when another item is opened
     * @type boolean
     */
    readonly alwaysOpen: i0.InputSignalWithTransform<boolean, unknown>;
    readonly hostClasses: i0.Signal<Record<string, boolean>>;
    static ɵfac: i0.ɵɵFactoryDeclaration<AccordionComponent, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<AccordionComponent, "c-accordion", ["cAccordionItem"], { "flush": { "alias": "flush"; "required": false; "isSignal": true; }; "alwaysOpen": { "alias": "alwaysOpen"; "required": false; "isSignal": true; }; }, {}, never, ["*"], true, never>;
}

declare class AccordionItemComponent implements OnInit, OnDestroy {
    #private;
    /**
     * Toggle an accordion item programmatically
     * @return boolean
     * @default false
     */
    readonly visibleInput: i0.InputSignalWithTransform<boolean, unknown>;
    readonly itemVisible: i0.WritableSignal<boolean>;
    set visible(value: boolean);
    get visible(): boolean;
    contentId: string;
    get itemContext(): {
        $implicit: boolean;
    };
    readonly contentTemplates: i0.Signal<readonly TemplateIdDirective[]>;
    readonly templates: i0.Signal<Record<string, TemplateRef<any>>>;
    ngOnInit(): void;
    ngOnDestroy(): void;
    toggleItem(): void;
    static ɵfac: i0.ɵɵFactoryDeclaration<AccordionItemComponent, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<AccordionItemComponent, "c-accordion-item", ["cAccordionItem"], { "visibleInput": { "alias": "visible"; "required": false; "isSignal": true; }; }, {}, ["contentTemplates"], ["*", "*"], true, never>;
}

declare class AccordionModule {
    static ɵfac: i0.ɵɵFactoryDeclaration<AccordionModule, never>;
    static ɵmod: i0.ɵɵNgModuleDeclaration<AccordionModule, never, [typeof AccordionButtonDirective, typeof AccordionComponent, typeof AccordionItemComponent], [typeof AccordionComponent, typeof AccordionButtonDirective, typeof AccordionItemComponent]>;
    static ɵinj: i0.ɵɵInjectorDeclaration<AccordionModule>;
}

declare class AlertHeadingDirective {
    static ɵfac: i0.ɵɵFactoryDeclaration<AlertHeadingDirective, never>;
    static ɵdir: i0.ɵɵDirectiveDeclaration<AlertHeadingDirective, "[cAlertHeading]", never, {}, {}, never, never, true, never>;
}

declare class AlertLinkDirective {
    static ɵfac: i0.ɵɵFactoryDeclaration<AlertLinkDirective, never>;
    static ɵdir: i0.ɵɵDirectiveDeclaration<AlertLinkDirective, "[cAlertLink]", never, {}, {}, never, never, true, never>;
}

type AnimateType$1 = 'hide' | 'show';
declare class AlertComponent {
    #private;
    /**
     * Sets the color context of the component to one of CoreUI’s themed colors.
     * @return Colors
     * @default 'primary'
     */
    readonly color: i0.InputSignal<string>;
    /**
     * Default role for alert. [docs]
     * @return string
     * @default 'alert'
     */
    readonly role: i0.InputSignal<string>;
    /**
     * Set the alert variant to a solid.
     * @return string
     */
    readonly variant: i0.InputSignal<"solid" | undefined>;
    /**
     * Optionally adds a close button to alert and allow it to self dismiss.
     * @return boolean
     * @default false
     */
    readonly dismissibleInput: i0.InputSignalWithTransform<boolean, unknown>;
    set dismissible(value: boolean);
    get dismissible(): boolean;
    /**
     * Adds animation for dismissible alert.
     * @return boolean
     */
    readonly fade: i0.InputSignalWithTransform<boolean, unknown>;
    /**
     * Toggle the visibility of alert component.
     * @return boolean
     */
    readonly visibleInput: i0.InputSignalWithTransform<boolean, unknown>;
    set visible(value: boolean);
    get visible(): boolean;
    readonly hide: i0.WritableSignal<boolean>;
    /**
     * Event triggered on the alert dismiss.
     */
    readonly visibleChange: i0.OutputEmitterRef<boolean>;
    readonly contentTemplates: i0.Signal<readonly TemplateIdDirective[]>;
    readonly templates: i0.Signal<Record<string, TemplateRef<any>>>;
    get animateType(): AnimateType$1;
    readonly hostClasses: i0.Signal<Record<string, boolean>>;
    onAnimationStart($event: AnimationEvent): void;
    onAnimationDone($event: AnimationEvent): void;
    onAnimationEvent(event: AnimationEvent): void;
    static ɵfac: i0.ɵɵFactoryDeclaration<AlertComponent, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<AlertComponent, "c-alert", ["cAlert"], { "color": { "alias": "color"; "required": false; "isSignal": true; }; "role": { "alias": "role"; "required": false; "isSignal": true; }; "variant": { "alias": "variant"; "required": false; "isSignal": true; }; "dismissibleInput": { "alias": "dismissible"; "required": false; "isSignal": true; }; "fade": { "alias": "fade"; "required": false; "isSignal": true; }; "visibleInput": { "alias": "visible"; "required": false; "isSignal": true; }; }, { "visibleChange": "visibleChange"; }, ["contentTemplates"], ["*"], true, never>;
}

declare class AlertModule {
    static ɵfac: i0.ɵɵFactoryDeclaration<AlertModule, never>;
    static ɵmod: i0.ɵɵNgModuleDeclaration<AlertModule, never, [typeof AlertComponent, typeof AlertHeadingDirective, typeof AlertLinkDirective], [typeof AlertComponent, typeof AlertHeadingDirective, typeof AlertLinkDirective]>;
    static ɵinj: i0.ɵɵInjectorDeclaration<AlertModule>;
}

declare class TextColorDirective {
    /**
     * Set text-color of element
     * @type TextColors
     */
    readonly color: InputSignal<TextColors>;
    readonly hostClasses: i0.Signal<{
        [x: string]: boolean;
    }>;
    static ɵfac: i0.ɵɵFactoryDeclaration<TextColorDirective, never>;
    static ɵdir: i0.ɵɵDirectiveDeclaration<TextColorDirective, "[cTextColor]", never, { "color": { "alias": "cTextColor"; "required": false; "isSignal": true; }; }, {}, never, never, true, never>;
}

declare class AvatarComponent {
    /**
     * Sets the background color context of the component to one of CoreUI’s themed colors.
     * @type Colors
     */
    readonly color: InputSignal<Colors | undefined>;
    /**
     * Select the shape of the component.
     * @type Shapes
     */
    readonly shape: InputSignal<Shapes | undefined>;
    /**
     * Size the component small, large, or extra large.
     * @default 'md'
     */
    readonly size: InputSignal<Omit<Sizes, 'xxl'>>;
    /**
     * The alt attribute for the img element alternate text.
     * @type string
     */
    readonly alt: InputSignal<string>;
    /**
     * The src attribute for the img element.
     * @type string
     */
    readonly src: InputSignal<string | undefined>;
    /**
     * Sets the color context of the status indicator to one of CoreUI’s themed colors.
     * @type Colors
     */
    readonly status: InputSignal<Colors | undefined>;
    /**
     * Sets the text color of the component to one of CoreUI’s themed colors.
     * via TextColorDirective
     * @type TextColors
     */
    readonly textColor: InputSignal<TextColors | undefined>;
    readonly statusClass: i0.Signal<Record<string, boolean>>;
    readonly hostClasses: i0.Signal<Record<string, boolean>>;
    static ɵfac: i0.ɵɵFactoryDeclaration<AvatarComponent, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<AvatarComponent, "c-avatar", never, { "color": { "alias": "color"; "required": false; "isSignal": true; }; "shape": { "alias": "shape"; "required": false; "isSignal": true; }; "size": { "alias": "size"; "required": false; "isSignal": true; }; "alt": { "alias": "alt"; "required": false; "isSignal": true; }; "src": { "alias": "src"; "required": false; "isSignal": true; }; "status": { "alias": "status"; "required": false; "isSignal": true; }; "textColor": { "alias": "textColor"; "required": false; "isSignal": true; }; }, {}, never, ["*"], true, [{ directive: typeof TextColorDirective; inputs: { "cTextColor": "textColor"; }; outputs: {}; }]>;
}

declare class AvatarModule {
    static ɵfac: i0.ɵɵFactoryDeclaration<AvatarModule, never>;
    static ɵmod: i0.ɵɵNgModuleDeclaration<AvatarModule, never, [typeof AvatarComponent], [typeof AvatarComponent]>;
    static ɵinj: i0.ɵɵInjectorDeclaration<AvatarModule>;
}

declare class TextBgColorDirective {
    /**
     * Set text-bg-color of element
     * @type Colors
     */
    readonly textBgColor: InputSignal<Colors>;
    readonly hostClasses: i0.Signal<Record<string, boolean>>;
    static ɵfac: i0.ɵɵFactoryDeclaration<TextBgColorDirective, never>;
    static ɵdir: i0.ɵɵDirectiveDeclaration<TextBgColorDirective, "[cTextBgColor]", never, { "textBgColor": { "alias": "cTextBgColor"; "required": false; "isSignal": true; }; }, {}, never, never, true, never>;
}

declare class BadgeComponent {
    /**
     * Sets the color context of the component to one of CoreUI’s themed colors.
     * @type Colors
     */
    readonly color: InputSignal<Colors | undefined>;
    /**
     * Position badge in one of the corners of a link or button.
     * @type BadgePositions
     */
    readonly position: InputSignal<BadgePositions | undefined>;
    /**
     * Select the shape of the component.
     * @type Shapes
     */
    readonly shape: InputSignal<Shapes | undefined>;
    /**
     * Size the component small.
     */
    readonly size: InputSignal<'sm' | undefined>;
    /**
     * Sets the text color of the component to one of CoreUI’s themed colors.
     * via TextColorDirective
     * @type TextColors
     */
    readonly textColor: InputSignal<TextColors | undefined>;
    /**
     * Sets the component's color scheme to one of CoreUI's themed colors, ensuring the text color contrast adheres to the WCAG 4.5:1 contrast ratio standard for accessibility.
     * via TextBgColorDirective
     * @type Colors
     * @since 5.0.0
     */
    readonly textBgColor: InputSignal<Colors | undefined>;
    readonly hostClasses: i0.Signal<Record<string, boolean>>;
    static ɵfac: i0.ɵɵFactoryDeclaration<BadgeComponent, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<BadgeComponent, "c-badge", never, { "color": { "alias": "color"; "required": false; "isSignal": true; }; "position": { "alias": "position"; "required": false; "isSignal": true; }; "shape": { "alias": "shape"; "required": false; "isSignal": true; }; "size": { "alias": "size"; "required": false; "isSignal": true; }; "textColor": { "alias": "textColor"; "required": false; "isSignal": true; }; "textBgColor": { "alias": "textBgColor"; "required": false; "isSignal": true; }; }, {}, never, ["*"], true, [{ directive: typeof TextColorDirective; inputs: { "cTextColor": "textColor"; }; outputs: {}; }, { directive: typeof TextBgColorDirective; inputs: { "cTextBgColor": "textBgColor"; }; outputs: {}; }]>;
}

declare class BadgeModule {
    static ɵfac: i0.ɵɵFactoryDeclaration<BadgeModule, never>;
    static ɵmod: i0.ɵɵNgModuleDeclaration<BadgeModule, never, [typeof BadgeComponent], [typeof BadgeComponent]>;
    static ɵinj: i0.ɵɵInjectorDeclaration<BadgeModule>;
}

declare class BackdropService {
    #private;
    readonly backdropClick$: rxjs.Observable<boolean>;
    activeBackdrop: any;
    scrollbarWidth: string;
    setBackdrop(type?: string): any;
    clearBackdrop(backdropElement: any): any;
    hideScrollbar(): void;
    resetScrollbar(): void;
    onClickHandler(): void;
    static ɵfac: i0.ɵɵFactoryDeclaration<BackdropService, never>;
    static ɵprov: i0.ɵɵInjectableDeclaration<BackdropService>;
}

interface IBreadcrumbItem {
    label: string;
    url?: string | any[];
    attributes?: INavAttributes$1;
    linkProps?: INavLinkProps$1;
    class?: string;
    queryParams?: {
        [key: string]: any;
    };
}

declare class BreadcrumbItemComponent {
    #private;
    /**
     * Toggle the active state for the component. [docs]
     * @return boolean
     */
    readonly active: i0.InputSignalWithTransform<boolean | undefined, unknown>;
    /**
     * The `url` prop for the inner `[routerLink]` directive. [docs]
     * @return string
     */
    readonly url: i0.InputSignal<string | any[] | undefined>;
    /**
     * Additional html attributes for link. [docs]
     * @return INavAttributes
     */
    readonly attribs: i0.InputSignal<INavAttributes$1 | undefined>;
    protected readonly _attributes: i0.InputSignal<INavAttributes$1 | undefined>;
    /**
     * Some `NavigationExtras` props for the inner `[routerLink]` directive and `routerLinkActiveOptions`. [docs]
     * @return INavLinkProps
     */
    readonly linkProps: i0.InputSignal<INavLinkProps$1 | undefined>;
    readonly ariaCurrent: i0.Signal<string | null>;
    readonly hostClasses: i0.Signal<Record<string, boolean>>;
    static ɵfac: i0.ɵɵFactoryDeclaration<BreadcrumbItemComponent, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<BreadcrumbItemComponent, "c-breadcrumb-item", ["breadcrumbItem"], { "active": { "alias": "active"; "required": false; "isSignal": true; }; "url": { "alias": "url"; "required": false; "isSignal": true; }; "attribs": { "alias": "attribs"; "required": false; "isSignal": true; }; "_attributes": { "alias": "attributes"; "required": false; "isSignal": true; }; "linkProps": { "alias": "linkProps"; "required": false; "isSignal": true; }; }, {}, never, ["*"], true, never>;
}

declare class BreadcrumbComponent {
    /**
     * Default aria-label for breadcrumb. [docs]
     * @return string
     * @default 'breadcrumb'
     */
    readonly ariaLabel: i0.InputSignal<string>;
    /**
     * Default role for breadcrumb. [docs]
     * @return string
     * @default 'navigation'
     */
    readonly role: i0.InputSignal<string>;
    static ɵfac: i0.ɵɵFactoryDeclaration<BreadcrumbComponent, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<BreadcrumbComponent, "c-breadcrumb", never, { "ariaLabel": { "alias": "ariaLabel"; "required": false; "isSignal": true; }; "role": { "alias": "role"; "required": false; "isSignal": true; }; }, {}, never, ["*"], true, never>;
}

declare class BreadcrumbRouterComponent {
    #private;
    /**
     * Optional array of IBreadcrumbItem to override default BreadcrumbRouter behavior. [docs]
     * @return IBreadcrumbItem[]
     */
    readonly items: i0.InputSignal<IBreadcrumbItem[] | undefined>;
    readonly breadcrumbs: i0.Signal<IBreadcrumbItem[]>;
    static ɵfac: i0.ɵɵFactoryDeclaration<BreadcrumbRouterComponent, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<BreadcrumbRouterComponent, "c-breadcrumb-router, [cBreadcrumbRouter]", never, { "items": { "alias": "items"; "required": false; "isSignal": true; }; }, {}, never, never, true, never>;
}

declare class BreadcrumbRouterService {
    #private;
    outlet: string;
    readonly breadcrumbs$: Observable<IBreadcrumbItem[]>;
    constructor();
    static ɵfac: i0.ɵɵFactoryDeclaration<BreadcrumbRouterService, never>;
    static ɵprov: i0.ɵɵInjectableDeclaration<BreadcrumbRouterService>;
}

declare class BreadcrumbModule {
    static ɵfac: i0.ɵɵFactoryDeclaration<BreadcrumbModule, never>;
    static ɵmod: i0.ɵɵNgModuleDeclaration<BreadcrumbModule, never, [typeof BreadcrumbComponent, typeof BreadcrumbItemComponent, typeof BreadcrumbRouterComponent], [typeof BreadcrumbComponent, typeof BreadcrumbItemComponent, typeof BreadcrumbRouterComponent]>;
    static ɵinj: i0.ɵɵInjectorDeclaration<BreadcrumbModule>;
}

declare class ButtonDirective {
    static ngAcceptInputType_active: BooleanInput;
    static ngAcceptInputType_disabled: BooleanInput;
    /**
     * Toggle the active state for the component. [docs]
     * @type InputSignalWithTransform<boolean, unknown>
     */
    readonly active: InputSignalWithTransform<boolean, unknown>;
    /**
     * Sets the color context of the component to one of CoreUI’s themed colors. [docs]
     * @type InputSignal<Colors>
     */
    readonly color: InputSignal<Colors>;
    /**
     * Toggle the disabled state for the component.
     * @type InputSignalWithTransform<boolean, unknown>
     */
    readonly disabled: InputSignalWithTransform<boolean, unknown>;
    /**
     * Select the shape of the component.
     * @type InputSignal<Shapes>
     */
    readonly shape: InputSignal<Shapes | undefined>;
    /**
     * Size the component small or large.
     * @type InputSignal<'sm' | 'lg' | ''>
     */
    readonly size: InputSignal<'' | 'sm' | 'lg'>;
    /**
     * The tabindex attribute specifies the tab order of an element (when the "tab" button is used for navigating).
     */
    readonly tabindex: InputSignalWithTransform<number | undefined, unknown>;
    /**
     * Specifies the type of button. Always specify the type attribute for the `<button>` element.
     * Different browsers may use different default types for the `<button>` element.
     * @type InputSignal<ButtonType>
     * @default 'button'
     */
    readonly type: InputSignal<ButtonType>;
    /**
     * Set the button variant to an outlined button or a ghost button.
     * @type InputSignal<'ghost' | 'outline' | undefined>
     */
    readonly variant: InputSignal<'ghost' | 'outline' | undefined>;
    readonly hostClasses: i0.Signal<Record<string, boolean>>;
    readonly _disabled: i0.Signal<boolean>;
    readonly ariaDisabled: i0.Signal<true | null>;
    readonly attrDisabled: i0.Signal<"" | null>;
    readonly tabIndex: i0.Signal<number | "-1" | null>;
    readonly isActive: i0.Signal<true | null>;
    static ɵfac: i0.ɵɵFactoryDeclaration<ButtonDirective, never>;
    static ɵdir: i0.ɵɵDirectiveDeclaration<ButtonDirective, "[cButton]", ["cButton"], { "active": { "alias": "active"; "required": false; "isSignal": true; }; "color": { "alias": "color"; "required": false; "isSignal": true; }; "disabled": { "alias": "disabled"; "required": false; "isSignal": true; }; "shape": { "alias": "shape"; "required": false; "isSignal": true; }; "size": { "alias": "size"; "required": false; "isSignal": true; }; "tabindex": { "alias": "tabindex"; "required": false; "isSignal": true; }; "type": { "alias": "type"; "required": false; "isSignal": true; }; "variant": { "alias": "variant"; "required": false; "isSignal": true; }; }, {}, never, never, true, never>;
}

declare class ButtonCloseDirective extends ButtonDirective {
    /**
     * Change the default color to white.
     * @type boolean
     * @deprecated 5.0.0. Use `cButtonClose.dark` instead.
     */
    readonly white: InputSignalWithTransform<boolean, unknown>;
    readonly hostClasses: i0.Signal<Record<string, boolean>>;
    static ɵfac: i0.ɵɵFactoryDeclaration<ButtonCloseDirective, never>;
    static ɵdir: i0.ɵɵDirectiveDeclaration<ButtonCloseDirective, "[cButtonClose]", never, { "white": { "alias": "white"; "required": false; "isSignal": true; }; }, {}, never, never, true, [{ directive: typeof ThemeDirective; inputs: { "dark": "dark"; }; outputs: {}; }]>;
}

declare class ButtonModule {
    static ɵfac: i0.ɵɵFactoryDeclaration<ButtonModule, never>;
    static ɵmod: i0.ɵɵNgModuleDeclaration<ButtonModule, never, [typeof ButtonDirective, typeof ButtonCloseDirective], [typeof ButtonDirective, typeof ButtonCloseDirective]>;
    static ɵinj: i0.ɵɵInjectorDeclaration<ButtonModule>;
}

declare class ButtonGroupComponent {
    /**
     * Size the component small or large.
     * @type { 'sm' | 'lg' }
     */
    readonly size: InputSignal<'sm' | 'lg' | undefined>;
    /**
     * Create a set of buttons that appear vertically stacked rather than horizontally. Split button dropdowns are not supported here.
     * @type boolean
     */
    readonly vertical: InputSignalWithTransform<boolean, unknown>;
    /**
     * Default role attr for ButtonGroup. [docs]
     * @type InputSignal<string>
     * @default 'group'
     */
    readonly role: InputSignal<string>;
    readonly hostClasses: i0.Signal<Record<string, boolean>>;
    static ɵfac: i0.ɵɵFactoryDeclaration<ButtonGroupComponent, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<ButtonGroupComponent, "c-button-group", never, { "size": { "alias": "size"; "required": false; "isSignal": true; }; "vertical": { "alias": "vertical"; "required": false; "isSignal": true; }; "role": { "alias": "role"; "required": false; "isSignal": true; }; }, {}, never, ["*"], true, never>;
}

declare class ButtonToolbarComponent {
    /**
     * Default role attr for ButtonToolbar. [docs]
     * @type InputSignal<string>
     * @default 'toolbar'
     */
    role: InputSignal<string>;
    static ɵfac: i0.ɵɵFactoryDeclaration<ButtonToolbarComponent, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<ButtonToolbarComponent, "c-button-toolbar", never, { "role": { "alias": "role"; "required": false; "isSignal": true; }; }, {}, never, ["*"], true, never>;
}

declare class ButtonGroupModule {
    static ɵfac: i0.ɵɵFactoryDeclaration<ButtonGroupModule, never>;
    static ɵmod: i0.ɵɵNgModuleDeclaration<ButtonGroupModule, never, [typeof ButtonGroupComponent, typeof ButtonToolbarComponent], [typeof ButtonGroupComponent, typeof ButtonToolbarComponent]>;
    static ɵinj: i0.ɵɵInjectorDeclaration<ButtonGroupModule>;
}

declare class CalloutComponent {
    /**
     * Sets the color context of the component to one of CoreUI’s themed colors.
     * @type Colors
     */
    readonly color: i0.InputSignal<string | undefined>;
    readonly hostClasses: i0.Signal<Record<string, boolean>>;
    static ɵfac: i0.ɵɵFactoryDeclaration<CalloutComponent, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<CalloutComponent, "c-callout, [cCallout]", never, { "color": { "alias": "color"; "required": false; "isSignal": true; }; }, {}, never, ["*"], true, never>;
}

declare class CalloutModule {
    static ɵfac: i0.ɵɵFactoryDeclaration<CalloutModule, never>;
    static ɵmod: i0.ɵɵNgModuleDeclaration<CalloutModule, never, [typeof CalloutComponent], [typeof CalloutComponent]>;
    static ɵinj: i0.ɵɵInjectorDeclaration<CalloutModule>;
}

declare class CardComponent {
    /**
     * Sets the color context of the component to one of CoreUI’s themed colors.
     * @type Colors
     */
    readonly color: InputSignal<Colors | undefined>;
    /**
     * Sets the text color context of the component to one of CoreUI’s themed colors.
     * via TextColorDirective
     * @type TextColors
     */
    readonly textColor: InputSignal<TextColors | undefined>;
    /**
     * Sets the component's color scheme to one of CoreUI themed colors, ensuring the text color contrast adheres to the WCAG 4.5:1 contrast ratio standard for accessibility.
     * via TextBgColorDirective
     * @type Colors
     * @since 5.0.0
     */
    readonly textBgColor: InputSignal<Colors | undefined>;
    readonly hostClasses: i0.Signal<Record<string, boolean>>;
    static ɵfac: i0.ɵɵFactoryDeclaration<CardComponent, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<CardComponent, "c-card, [c-card]", never, { "color": { "alias": "color"; "required": false; "isSignal": true; }; "textColor": { "alias": "textColor"; "required": false; "isSignal": true; }; "textBgColor": { "alias": "textBgColor"; "required": false; "isSignal": true; }; }, {}, never, ["*"], true, [{ directive: typeof TextColorDirective; inputs: { "cTextColor": "textColor"; }; outputs: {}; }, { directive: typeof TextBgColorDirective; inputs: { "cTextBgColor": "textBgColor"; }; outputs: {}; }]>;
}

declare class CardBodyComponent {
    static ɵfac: i0.ɵɵFactoryDeclaration<CardBodyComponent, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<CardBodyComponent, "c-card-body, [c-card-body]", never, {}, {}, never, ["*"], true, never>;
}

declare class CardFooterComponent {
    static ɵfac: i0.ɵɵFactoryDeclaration<CardFooterComponent, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<CardFooterComponent, "c-card-footer, [c-card-footer]", never, {}, {}, never, ["*"], true, never>;
}

declare class CardGroupComponent {
    static ɵfac: i0.ɵɵFactoryDeclaration<CardGroupComponent, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<CardGroupComponent, "c-card-group, [c-card-group]", never, {}, {}, never, ["*"], true, never>;
}

declare class CardHeaderComponent {
    static ɵfac: i0.ɵɵFactoryDeclaration<CardHeaderComponent, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<CardHeaderComponent, "c-card-header, [c-card-header]", never, {}, {}, never, ["*"], true, never>;
}

declare class CardHeaderActionsComponent {
    static ɵfac: i0.ɵɵFactoryDeclaration<CardHeaderActionsComponent, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<CardHeaderActionsComponent, "c-card-header-actions, [c-card-header-actions]", never, {}, {}, never, ["*"], true, never>;
}

declare class CardImgDirective {
    /**
     * Optionally orientate the image to the top, bottom, or make it overlaid across the card.
     * @type {'top | 'bottom'}
     */
    readonly orientation: i0.InputSignal<"start" | "end" | "top" | "bottom" | undefined>;
    readonly hostClasses: i0.Signal<Record<string, boolean>>;
    static ɵfac: i0.ɵɵFactoryDeclaration<CardImgDirective, never>;
    static ɵdir: i0.ɵɵDirectiveDeclaration<CardImgDirective, "[cCardImg]", never, { "orientation": { "alias": "cCardImg"; "required": false; "isSignal": true; }; }, {}, never, never, true, never>;
}

declare class CardImgOverlayComponent {
    static ɵfac: i0.ɵɵFactoryDeclaration<CardImgOverlayComponent, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<CardImgOverlayComponent, "c-card-img-overlay", never, {}, {}, never, ["*"], true, never>;
}

declare class CardLinkDirective {
    static ɵfac: i0.ɵɵFactoryDeclaration<CardLinkDirective, never>;
    static ɵdir: i0.ɵɵDirectiveDeclaration<CardLinkDirective, "[cCardLink]", never, {}, {}, never, never, true, never>;
}

declare class CardSubtitleDirective {
    static ɵfac: i0.ɵɵFactoryDeclaration<CardSubtitleDirective, never>;
    static ɵdir: i0.ɵɵDirectiveDeclaration<CardSubtitleDirective, "[cCardSubtitle]", never, {}, {}, never, never, true, never>;
}

declare class CardTextDirective {
    static ɵfac: i0.ɵɵFactoryDeclaration<CardTextDirective, never>;
    static ɵdir: i0.ɵɵDirectiveDeclaration<CardTextDirective, "[cCardText]", never, {}, {}, never, never, true, never>;
}

declare class CardTitleDirective {
    static ɵfac: i0.ɵɵFactoryDeclaration<CardTitleDirective, never>;
    static ɵdir: i0.ɵɵDirectiveDeclaration<CardTitleDirective, "[cCardTitle]", never, {}, {}, never, never, true, never>;
}

declare class CardModule {
    static ɵfac: i0.ɵɵFactoryDeclaration<CardModule, never>;
    static ɵmod: i0.ɵɵNgModuleDeclaration<CardModule, never, [typeof CardComponent, typeof CardBodyComponent, typeof CardFooterComponent, typeof CardGroupComponent, typeof CardHeaderComponent, typeof CardHeaderActionsComponent, typeof CardImgDirective, typeof CardImgOverlayComponent, typeof CardLinkDirective, typeof CardSubtitleDirective, typeof CardTextDirective, typeof CardTitleDirective], [typeof CardComponent, typeof CardBodyComponent, typeof CardFooterComponent, typeof CardGroupComponent, typeof CardHeaderComponent, typeof CardHeaderActionsComponent, typeof CardImgDirective, typeof CardImgOverlayComponent, typeof CardLinkDirective, typeof CardSubtitleDirective, typeof CardTextDirective, typeof CardTitleDirective]>;
    static ɵinj: i0.ɵɵInjectorDeclaration<CardModule>;
}

declare class CarouselComponent implements OnInit, OnDestroy, AfterContentInit {
    #private;
    private config;
    constructor();
    loadConfig(): void;
    /**
     * Index of the active item.
     * @return number
     */
    readonly activeIndexInput: i0.InputSignalWithTransform<number, unknown>;
    readonly activeIndex: i0.WritableSignal<number>;
    /**
     * Carousel automatically starts cycle items.
     * @return boolean
     */
    readonly animateInput: i0.InputSignal<boolean>;
    readonly animate: i0.WritableSignal<boolean>;
    /**
     * Carousel direction. [docs]
     * @return {'next' | 'prev'}
     */
    readonly directionInput: i0.InputSignal<"next" | "prev">;
    readonly direction: i0.WritableSignal<"next" | "prev">;
    /**
     * The amount of time to delay between automatically cycling an item. If false, carousel will not automatically cycle.
     * @return number
     * @default 0
     */
    readonly intervalInput: i0.InputSignalWithTransform<number, unknown>;
    readonly interval: i0.WritableSignal<number>;
    /**
     * Sets which event handlers you’d like provided to your pause prop. You can specify one trigger or an array of them.
     * @return {'hover' | 'focus' | 'click'}
     */
    readonly pause: i0.InputSignal<false | Triggers | Triggers[]>;
    /**
     * Support left/right swipe interactions on touchscreen devices.
     * @return boolean
     * @default true
     */
    readonly touch: i0.InputSignal<boolean>;
    /**
     * Set type of the transition.
     * @return {'slide' | 'crossfade'}
     * @default 'slide'
     */
    readonly transition: i0.InputSignal<"slide" | "crossfade">;
    /**
     * Set whether the carousel should cycle continuously or have hard stops.
     * @return boolean
     * @default true
     */
    readonly wrap: i0.InputSignal<boolean>;
    /**
     * Event emitted on carousel item change. [docs]
     * @return number
     */
    readonly itemChange: i0.OutputEmitterRef<number>;
    private timerId;
    private activeItemInterval;
    private swipeSubscription?;
    ngOnInit(): void;
    ngOnDestroy(): void;
    ngAfterContentInit(): void;
    private setListeners;
    private clearListeners;
    set visible(value: boolean);
    get visible(): boolean;
    setTimer(): void;
    resetTimer(): void;
    private carouselStateSubscribe;
    private intersectionServiceSubscribe;
    private swipeSubscribe;
    static ɵfac: i0.ɵɵFactoryDeclaration<CarouselComponent, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<CarouselComponent, "c-carousel", ["cCarousel"], { "activeIndexInput": { "alias": "activeIndex"; "required": false; "isSignal": true; }; "animateInput": { "alias": "animate"; "required": false; "isSignal": true; }; "directionInput": { "alias": "direction"; "required": false; "isSignal": true; }; "intervalInput": { "alias": "interval"; "required": false; "isSignal": true; }; "pause": { "alias": "pause"; "required": false; "isSignal": true; }; "touch": { "alias": "touch"; "required": false; "isSignal": true; }; "transition": { "alias": "transition"; "required": false; "isSignal": true; }; "wrap": { "alias": "wrap"; "required": false; "isSignal": true; }; }, { "itemChange": "itemChange"; }, never, ["*"], true, [{ directive: typeof ThemeDirective; inputs: { "dark": "dark"; }; outputs: {}; }]>;
}

declare class CarouselCaptionComponent {
    static ɵfac: i0.ɵɵFactoryDeclaration<CarouselCaptionComponent, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<CarouselCaptionComponent, "c-carousel-caption", never, {}, {}, never, ["*"], true, never>;
}

declare class CarouselControlComponent {
    #private;
    /**
     * Carousel control caption. [docs]
     * @return string
     */
    readonly captionInput: i0.InputSignal<string | undefined>;
    readonly caption: i0.WritableSignal<string>;
    /**
     * Carousel control direction.
     * @return {'next' | 'prev'}
     */
    readonly direction: i0.InputSignal<"next" | "prev">;
    /**
     * Carousel control role.
     * @return string
     */
    readonly role: i0.InputSignal<string>;
    readonly hostClasses: i0.Signal<string>;
    readonly carouselControlIconClass: i0.Signal<string>;
    onKeyUp($event: KeyboardEvent): void;
    onClick($event: MouseEvent): void;
    static ɵfac: i0.ɵɵFactoryDeclaration<CarouselControlComponent, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<CarouselControlComponent, "c-carousel-control", ["cCarouselControl"], { "captionInput": { "alias": "caption"; "required": false; "isSignal": true; }; "direction": { "alias": "direction"; "required": false; "isSignal": true; }; "role": { "alias": "role"; "required": false; "isSignal": true; }; }, {}, never, ["*"], true, never>;
}

declare class CarouselIndicatorsComponent implements OnInit {
    #private;
    items: (number | undefined)[];
    active: number;
    readonly contentTemplates: i0.Signal<readonly TemplateIdDirective[]>;
    readonly templates: i0.Signal<Record<string, TemplateRef<any>>>;
    ngOnInit(): void;
    onClick(index: number): void;
    static ɵfac: i0.ɵɵFactoryDeclaration<CarouselIndicatorsComponent, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<CarouselIndicatorsComponent, "c-carousel-indicators", ["cCarouselIndicators"], {}, {}, ["contentTemplates"], never, true, never>;
}

declare class CarouselItemComponent {
    #private;
    index?: number;
    /**
     * @ignore
     */
    readonly activeInput: i0.InputSignalWithTransform<boolean, unknown>;
    readonly active: i0.WritableSignal<boolean>;
    /**
     * Time delay before cycling to next item. If -1, uses carousel interval value.
     * @return number
     * @default -1
     */
    readonly interval: i0.InputSignal<number>;
    /**
     * Carousel item role.
     * @return string
     * @default 'group'
     */
    readonly role: i0.InputSignal<string>;
    constructor();
    static ɵfac: i0.ɵɵFactoryDeclaration<CarouselItemComponent, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<CarouselItemComponent, "c-carousel-item", ["cCarouselItem"], { "activeInput": { "alias": "active"; "required": false; "isSignal": true; }; "interval": { "alias": "interval"; "required": false; "isSignal": true; }; "role": { "alias": "role"; "required": false; "isSignal": true; }; }, {}, never, ["*"], true, never>;
}

declare class CarouselInnerComponent implements AfterContentInit, AfterContentChecked {
    #private;
    readonly activeIndex: i0.WritableSignal<number | undefined>;
    readonly animate: i0.WritableSignal<boolean>;
    readonly interval: i0.WritableSignal<number>;
    readonly slide: i0.WritableSignal<{
        left: boolean;
    }>;
    readonly transition: i0.WritableSignal<string>;
    readonly slideType: i0.Signal<{
        left: boolean;
        type: string;
    }>;
    readonly ariaLive: i0.Signal<"off" | "polite">;
    readonly contentItems: i0.Signal<readonly CarouselItemComponent[]>;
    ngAfterContentInit(): void;
    ngAfterContentChecked(): void;
    setItems(): void;
    static ɵfac: i0.ɵɵFactoryDeclaration<CarouselInnerComponent, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<CarouselInnerComponent, "c-carousel-inner", never, {}, {}, ["contentItems"], ["*"], true, never>;
}

declare class CarouselConfig {
    activeIndex: number;
    animate: boolean;
    direction: 'next' | 'prev';
    interval?: number;
    static ɵfac: i0.ɵɵFactoryDeclaration<CarouselConfig, never>;
    static ɵprov: i0.ɵɵInjectableDeclaration<CarouselConfig>;
}

declare class CarouselModule {
    static forRoot(): ModuleWithProviders<CarouselModule>;
    static ɵfac: i0.ɵɵFactoryDeclaration<CarouselModule, never>;
    static ɵmod: i0.ɵɵNgModuleDeclaration<CarouselModule, never, [typeof CarouselComponent, typeof CarouselCaptionComponent, typeof CarouselControlComponent, typeof CarouselIndicatorsComponent, typeof CarouselInnerComponent, typeof CarouselItemComponent], [typeof CarouselComponent, typeof CarouselCaptionComponent, typeof CarouselControlComponent, typeof CarouselIndicatorsComponent, typeof CarouselInnerComponent, typeof CarouselItemComponent]>;
    static ɵinj: i0.ɵɵInjectorDeclaration<CarouselModule>;
}

declare class CollapseDirective implements OnDestroy {
    #private;
    constructor();
    /**
     * @ignore
     */
    readonly animateInput: i0.InputSignalWithTransform<boolean, unknown>;
    readonly animate: i0.WritableSignal<boolean>;
    /**
     * Set horizontal collapsing to transition the width instead of height.
     * @type boolean
     * @default false
     */
    readonly horizontal: i0.InputSignalWithTransform<boolean, unknown>;
    /**
     * Toggle the visibility of collapsible element.
     * @type boolean
     * @default false
     */
    readonly visibleInput: i0.InputSignalWithTransform<boolean, unknown>;
    readonly visibleChange: i0.OutputEmitterRef<boolean>;
    readonly visible: i0.WritableSignal<boolean>;
    /**
     * Add `navbar` prop for grouping and hiding navbar contents by a parent breakpoint.
     * @type boolean
     * @default false
     */
    readonly navbar: i0.InputSignalWithTransform<boolean, unknown>;
    /**
     * @ignore
     */
    readonly duration: i0.InputSignal<string>;
    /**
     * @ignore
     */
    readonly transition: i0.InputSignal<string>;
    /**
     * Event emitted on visibility change. [docs]
     * @type string
     */
    readonly collapseChange: i0.OutputEmitterRef<string>;
    readonly hostClasses: i0.Signal<Record<string, boolean>>;
    ngOnDestroy(): void;
    toggle(visible?: boolean): void;
    destroyPlayer(): void;
    createPlayer(visible?: boolean): void;
    setMaxSize(): void;
    static ɵfac: i0.ɵɵFactoryDeclaration<CollapseDirective, never>;
    static ɵdir: i0.ɵɵDirectiveDeclaration<CollapseDirective, "[cCollapse]", ["cCollapse"], { "animateInput": { "alias": "animate"; "required": false; "isSignal": true; }; "horizontal": { "alias": "horizontal"; "required": false; "isSignal": true; }; "visibleInput": { "alias": "visible"; "required": false; "isSignal": true; }; "navbar": { "alias": "navbar"; "required": false; "isSignal": true; }; "duration": { "alias": "duration"; "required": false; "isSignal": true; }; "transition": { "alias": "transition"; "required": false; "isSignal": true; }; }, { "visibleChange": "visibleChange"; "collapseChange": "collapseChange"; }, never, never, true, never>;
}

declare class CollapseModule {
    static forRoot(): ModuleWithProviders<CollapseModule>;
    static ɵfac: i0.ɵɵFactoryDeclaration<CollapseModule, never>;
    static ɵmod: i0.ɵɵNgModuleDeclaration<CollapseModule, never, [typeof CollapseDirective], [typeof CollapseDirective]>;
    static ɵinj: i0.ɵɵInjectorDeclaration<CollapseModule>;
}

declare class DropdownDividerDirective {
    static ɵfac: i0.ɵɵFactoryDeclaration<DropdownDividerDirective, never>;
    static ɵdir: i0.ɵɵDirectiveDeclaration<DropdownDividerDirective, "[cDropdownDivider]", never, {}, {}, never, never, true, never>;
}

declare class DropdownHeaderDirective {
    static ɵfac: i0.ɵɵFactoryDeclaration<DropdownHeaderDirective, never>;
    static ɵdir: i0.ɵɵDirectiveDeclaration<DropdownHeaderDirective, "[cDropdownHeader]", never, {}, {}, never, never, true, never>;
}

declare class DropdownMenuDirective implements OnInit, AfterContentInit {
    #private;
    readonly elementRef: ElementRef;
    /**
     * Set alignment of dropdown menu.
     * @return 'start' | 'end'
     */
    readonly alignment: i0.InputSignal<string | undefined>;
    /**
     * Toggle the visibility of dropdown menu component.
     * @return boolean
     */
    readonly visibleInput: i0.InputSignalWithTransform<boolean, unknown>;
    readonly visible: i0.WritableSignal<boolean>;
    readonly hostClasses: i0.Signal<Record<string, boolean>>;
    readonly hostStyles: i0.Signal<Record<string, any>>;
    onKeyDown($event: KeyboardEvent): void;
    onKeyUp($event: KeyboardEvent): void;
    readonly dropdownItemsContent: i0.Signal<readonly DropdownItemDirective[]>;
    readonly items$: rxjs.Observable<readonly DropdownItemDirective[]>;
    ngAfterContentInit(): void;
    ngOnInit(): void;
    private focusKeyManagerInit;
    static ɵfac: i0.ɵɵFactoryDeclaration<DropdownMenuDirective, never>;
    static ɵdir: i0.ɵɵDirectiveDeclaration<DropdownMenuDirective, "[cDropdownMenu]", ["cDropdownMenu"], { "alignment": { "alias": "alignment"; "required": false; "isSignal": true; }; "visibleInput": { "alias": "visible"; "required": false; "isSignal": true; }; }, {}, ["dropdownItemsContent"], never, true, [{ directive: typeof ThemeDirective; inputs: { "dark": "dark"; }; outputs: {}; }]>;
}

interface IDropdownState {
    visible?: boolean | 'toggle';
    dropdown?: any;
}
declare class DropdownService {
    private dropdownState;
    dropdownState$: rxjs.Observable<any>;
    toggle(state: IDropdownState): void;
    static ɵfac: i0.ɵɵFactoryDeclaration<DropdownService, never>;
    static ɵprov: i0.ɵɵInjectableDeclaration<DropdownService>;
}

declare abstract class DropdownToken {
}
declare class DropdownToggleDirective implements AfterViewInit {
    #private;
    readonly elementRef: ElementRef<any>;
    dropdown: DropdownToken | null;
    /**
     * Reference to dropdown component.
     * @return DropdownComponent | undefined
     * @default undefined
     */
    readonly dropdownComponent: i0.InputSignal<DropdownComponent | undefined>;
    /**
     * Disables the toggler.
     * @return boolean
     * @default false
     */
    readonly disabled: i0.InputSignalWithTransform<boolean, unknown>;
    /**
     * Enables pseudo element caret on toggler.
     * @return boolean
     */
    readonly caret: i0.InputSignal<boolean>;
    /**
     * Create split button dropdowns with virtually the same markup as single button dropdowns,
     * but with the addition of `.dropdown-toggle-split` class for proper spacing around the dropdown caret.
     * @return boolean
     * @default false
     */
    readonly split: i0.InputSignalWithTransform<boolean, unknown>;
    readonly hostClasses: i0.Signal<Record<string, boolean>>;
    get ariaExpanded(): boolean;
    onClick($event: MouseEvent): void;
    ngAfterViewInit(): void;
    static ɵfac: i0.ɵɵFactoryDeclaration<DropdownToggleDirective, never>;
    static ɵdir: i0.ɵɵDirectiveDeclaration<DropdownToggleDirective, "[cDropdownToggle]", ["cDropdownToggle"], { "dropdownComponent": { "alias": "dropdownComponent"; "required": false; "isSignal": true; }; "disabled": { "alias": "disabled"; "required": false; "isSignal": true; }; "caret": { "alias": "caret"; "required": false; "isSignal": true; }; "split": { "alias": "split"; "required": false; "isSignal": true; }; }, {}, never, never, true, never>;
}
declare class DropdownComponent implements OnDestroy, OnInit {
    #private;
    readonly dropdownService: DropdownService;
    constructor();
    /**
     * Set alignment of dropdown menu.
     * @return {'start' | 'end' | { xs: 'start' | 'end' } | { sm: 'start' | 'end' } | { md: 'start' | 'end' } | { lg: 'start' | 'end' } | { xl: 'start' | 'end'} | { xxl: 'start' | 'end'}}
     */
    readonly alignment: i0.InputSignal<string | undefined>;
    /**
     * Automatically close dropdown when clicking outside the dropdown menu.
     */
    readonly autoClose: i0.InputSignal<boolean | "inside" | "outside">;
    /**
     * Sets a specified  direction and location of the dropdown menu.
     * @return 'dropup' | 'dropend' | 'dropstart'
     */
    readonly direction: i0.InputSignal<"center" | "dropup" | "dropup-center" | "dropend" | "dropstart" | undefined>;
    /**
     * Describes the placement of your component after Popper.js has applied all the modifiers
     * that may have flipped or altered the originally provided placement property.
     * @return Placement
     */
    readonly placement: i0.InputSignal<Placement>;
    /**
     * If you want to disable dynamic positioning set this property to `false`.
     * @return boolean
     * @default true
     */
    readonly popper: i0.InputSignalWithTransform<boolean, unknown>;
    /**
     * Optional popper Options object, placement prop takes precedence over
     * @return Partial<Options>
     */
    readonly popperOptionsInput: i0.InputSignal<Partial<Options>>;
    set popperOptions(value: Partial<Options>);
    get popperOptions(): Partial<Options>;
    /**
     * Set the dropdown variant to a btn-group, dropdown, input-group, and nav-item.
     */
    readonly variant: i0.InputSignal<"btn-group" | "dropdown" | "input-group" | "nav-item" | undefined>;
    /**
     * Toggle the visibility of dropdown menu component.
     * @return boolean
     * @default false
     */
    readonly visibleInput: i0.InputSignalWithTransform<boolean, unknown>;
    readonly visible: i0.WritableSignal<boolean>;
    readonly visibleChange: i0.OutputEmitterRef<boolean>;
    dropdownContext: {
        $implicit: boolean;
    };
    readonly _toggler: i0.Signal<DropdownToggleDirective | undefined>;
    readonly _menu: i0.Signal<DropdownMenuDirective | undefined>;
    readonly _menuElementRef: i0.Signal<ElementRef<any> | undefined>;
    activeTrap: boolean;
    private popperInstance;
    private listeners;
    readonly hostClasses: i0.Signal<Record<string, boolean>>;
    readonly hostStyle: i0.Signal<{
        display: string;
    } | {
        display?: undefined;
    }>;
    private clickedTarget;
    onHostClick($event: MouseEvent): void;
    dropdownStateSubscribe(): void;
    toggleDropdown(): void;
    onClick(event: any): void;
    ngOnInit(): void;
    ngOnDestroy(): void;
    setVisibleState(value: boolean): void;
    createPopperInstance(): void;
    destroyPopperInstance(): void;
    private setListeners;
    private clearListeners;
    static ɵfac: i0.ɵɵFactoryDeclaration<DropdownComponent, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<DropdownComponent, "c-dropdown", ["cDropdown"], { "alignment": { "alias": "alignment"; "required": false; "isSignal": true; }; "autoClose": { "alias": "autoClose"; "required": false; "isSignal": true; }; "direction": { "alias": "direction"; "required": false; "isSignal": true; }; "placement": { "alias": "placement"; "required": false; "isSignal": true; }; "popper": { "alias": "popper"; "required": false; "isSignal": true; }; "popperOptionsInput": { "alias": "popperOptions"; "required": false; "isSignal": true; }; "variant": { "alias": "variant"; "required": false; "isSignal": true; }; "visibleInput": { "alias": "visible"; "required": false; "isSignal": true; }; }, { "visibleChange": "visibleChange"; }, ["_toggler", "_menu", "_menuElementRef"], ["*"], true, [{ directive: typeof ThemeDirective; inputs: { "dark": "dark"; }; outputs: {}; }]>;
}

declare class DropdownItemDirective implements FocusableOption {
    #private;
    dropdown?: DropdownComponent | null | undefined;
    /**
     * Set active state to a dropdown-item.
     * @return boolean
     * @default undefined
     */
    readonly active: i0.InputSignal<boolean | undefined>;
    /**
     * Configure dropdown-item close dropdown behavior.
     * @return boolean
     * @default true
     */
    readonly autoClose: i0.InputSignal<boolean>;
    /**
     * Disables a dropdown-item.
     * @return boolean
     * @default undefined
     */
    readonly disabledInput: i0.InputSignalWithTransform<boolean, unknown>;
    set disabled(value: boolean);
    get disabled(): boolean;
    readonly role: i0.InputSignal<string>;
    readonly tabIndexInput: i0.InputSignal<string | number | null>;
    readonly tabIndex: i0.WritableSignal<string | number | null>;
    focus(origin?: FocusOrigin | undefined): void;
    getLabel?(): string;
    readonly ariaCurrent: i0.Signal<"true" | null>;
    readonly hostClasses: i0.Signal<Record<string, boolean>>;
    onClick($event: MouseEvent): void;
    onKeyUp($event: KeyboardEvent): void;
    private handleInteraction;
    static ɵfac: i0.ɵɵFactoryDeclaration<DropdownItemDirective, never>;
    static ɵdir: i0.ɵɵDirectiveDeclaration<DropdownItemDirective, "[cDropdownItem]", ["cDropdownItem"], { "active": { "alias": "active"; "required": false; "isSignal": true; }; "autoClose": { "alias": "autoClose"; "required": false; "isSignal": true; }; "disabledInput": { "alias": "disabled"; "required": false; "isSignal": true; }; "role": { "alias": "role"; "required": false; "isSignal": true; }; "tabIndexInput": { "alias": "tabIndex"; "required": false; "isSignal": true; }; }, {}, never, never, true, never>;
}

declare class DropdownItemPlainDirective {
    static ɵfac: i0.ɵɵFactoryDeclaration<DropdownItemPlainDirective, never>;
    static ɵdir: i0.ɵɵDirectiveDeclaration<DropdownItemPlainDirective, "[cDropdownItemPlain]", never, {}, {}, never, never, true, never>;
}

declare class DropdownCloseDirective implements AfterViewInit {
    #private;
    dropdown?: DropdownComponent | null | undefined;
    /**
     * Disables a dropdown-close directive.
     * @return boolean
     * @default false
     */
    readonly disabledInput: i0.InputSignalWithTransform<boolean, unknown>;
    readonly disabled: i0.WritableSignal<true | null>;
    readonly dropdownComponent: i0.InputSignal<DropdownComponent | undefined>;
    ngAfterViewInit(): void;
    readonly tabIndexInput: i0.InputSignal<string | number | null>;
    readonly tabIndex: i0.WritableSignal<string | number | null>;
    onClick($event: MouseEvent): void;
    onKeyUp($event: KeyboardEvent): void;
    private handleToggle;
    static ɵfac: i0.ɵɵFactoryDeclaration<DropdownCloseDirective, never>;
    static ɵdir: i0.ɵɵDirectiveDeclaration<DropdownCloseDirective, "[cDropdownClose]", ["cDropdownClose"], { "disabledInput": { "alias": "disabled"; "required": false; "isSignal": true; }; "dropdownComponent": { "alias": "dropdownComponent"; "required": false; "isSignal": true; }; "tabIndexInput": { "alias": "tabIndex"; "required": false; "isSignal": true; }; }, {}, never, never, true, never>;
}

declare class DropdownModule {
    static ɵfac: i0.ɵɵFactoryDeclaration<DropdownModule, never>;
    static ɵmod: i0.ɵɵNgModuleDeclaration<DropdownModule, never, [typeof DropdownComponent, typeof DropdownCloseDirective, typeof DropdownDividerDirective, typeof DropdownHeaderDirective, typeof DropdownItemDirective, typeof DropdownItemPlainDirective, typeof DropdownMenuDirective, typeof DropdownToggleDirective], [typeof DropdownComponent, typeof DropdownCloseDirective, typeof DropdownDividerDirective, typeof DropdownHeaderDirective, typeof DropdownItemDirective, typeof DropdownItemPlainDirective, typeof DropdownMenuDirective, typeof DropdownToggleDirective]>;
    static ɵinj: i0.ɵɵInjectorDeclaration<DropdownModule>;
}

declare class FooterComponent {
    /**
     * Place footer in non-static positions. [docs]
     * @type Positions
     */
    readonly position: InputSignal<Positions | undefined>;
    /**
     * Default role for footer. [docs]
     * @type string
     * @default 'contentinfo'
     */
    readonly role: InputSignal<string>;
    readonly hostClasses: i0.Signal<Record<string, boolean>>;
    static ɵfac: i0.ɵɵFactoryDeclaration<FooterComponent, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<FooterComponent, "c-footer, [cFooter]", never, { "position": { "alias": "position"; "required": false; "isSignal": true; }; "role": { "alias": "role"; "required": false; "isSignal": true; }; }, {}, never, ["*"], true, never>;
}

declare class FooterModule {
    static ɵfac: i0.ɵɵFactoryDeclaration<FooterModule, never>;
    static ɵmod: i0.ɵɵNgModuleDeclaration<FooterModule, never, [typeof FooterComponent], [typeof FooterComponent]>;
    static ɵinj: i0.ɵɵInjectorDeclaration<FooterModule>;
}

declare class FormDirective {
    /**
     * Mark a form as validated. If you set it `true`, all validation styles will be applied to the form. [docs]
     * @return boolean
     * @default false
     */
    readonly validated: i0.InputSignalWithTransform<boolean, unknown>;
    static ɵfac: i0.ɵɵFactoryDeclaration<FormDirective, never>;
    static ɵdir: i0.ɵɵDirectiveDeclaration<FormDirective, "form[cForm]", never, { "validated": { "alias": "validated"; "required": false; "isSignal": true; }; }, {}, never, never, true, never>;
}

declare class FormCheckLabelDirective {
    static ɵfac: i0.ɵɵFactoryDeclaration<FormCheckLabelDirective, never>;
    static ɵdir: i0.ɵɵDirectiveDeclaration<FormCheckLabelDirective, "label[cFormCheckLabel]", never, {}, {}, never, never, true, never>;
}

declare class FormCheckComponent {
    static ngAcceptInputType_inline: BooleanInput$1;
    static ngAcceptInputType_reverse: BooleanInput$1;
    static ngAcceptInputType_switch: BooleanInput$1;
    /**
     * Group checkboxes or radios on the same horizontal row.
     * @default false
     */
    readonly inline: i0.InputSignalWithTransform<boolean, unknown>;
    /**
     * Put checkboxes or radios on the opposite side.
     * @default false
     * @since 4.4.7
     */
    readonly reverse: i0.InputSignalWithTransform<boolean, unknown>;
    /**
     * Size the component large or extra large. Works only with `[switch]="true"` [docs]
     * @default undefined
     */
    readonly sizing: i0.InputSignal<string | undefined>;
    /**
     * Render a toggle switch on for checkbox.
     * @returns boolean
     * @default false
     */
    readonly switch: i0.InputSignalWithTransform<boolean, unknown>;
    readonly formCheckLabel: i0.Signal<FormCheckLabelDirective | undefined>;
    readonly hostClasses: i0.Signal<Record<string, boolean>>;
    static ɵfac: i0.ɵɵFactoryDeclaration<FormCheckComponent, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<FormCheckComponent, "c-form-check", ["cFormCheck"], { "inline": { "alias": "inline"; "required": false; "isSignal": true; }; "reverse": { "alias": "reverse"; "required": false; "isSignal": true; }; "sizing": { "alias": "sizing"; "required": false; "isSignal": true; }; "switch": { "alias": "switch"; "required": false; "isSignal": true; }; }, {}, ["formCheckLabel"], ["*"], true, never>;
}

declare class FormControlDirective implements OnInit {
    #private;
    /**
     * Size the component small or large.
     * @default undefined
     */
    readonly sizing: i0.InputSignal<string | undefined>;
    /**
     * Set component validation state to valid.
     * @default undefined
     */
    readonly valid: i0.InputSignal<boolean | undefined>;
    /**
     * Specifies the type of input element.
     */
    readonly type: i0.InputSignal<Omit<InputType, "checkbox" | "radio">>;
    /**
     * Render the component styled as plain text. Removes the default form field styling and preserve the correct margin and padding. Recommend to use alongside `readonly`
     * @default false
     */
    readonly plaintext: i0.InputSignalWithTransform<boolean, unknown>;
    readonly hostClasses: i0.Signal<Record<string, boolean>>;
    get hostTag(): string;
    ngOnInit(): void;
    static ɵfac: i0.ɵɵFactoryDeclaration<FormControlDirective, never>;
    static ɵdir: i0.ɵɵDirectiveDeclaration<FormControlDirective, "input[cFormControl], textarea[cFormControl]", never, { "sizing": { "alias": "sizing"; "required": false; "isSignal": true; }; "valid": { "alias": "valid"; "required": false; "isSignal": true; }; "type": { "alias": "type"; "required": false; "isSignal": true; }; "plaintext": { "alias": "plaintext"; "required": false; "isSignal": true; }; }, {}, never, never, true, never>;
}

declare class FormCheckInputDirective {
    #private;
    static ngAcceptInputType_indeterminate: BooleanInput$1;
    /**
     * Specifies the type of component.
     * @default 'checkbox'
     */
    readonly type: i0.InputSignal<"checkbox" | "radio">;
    /**
     * Set component indeterminate state.
     * @default false
     */
    readonly indeterminateInput: i0.InputSignalWithTransform<boolean, unknown>;
    get indeterminate(): boolean;
    /**
     * Set component validation state to valid.
     * @default undefined
     */
    readonly valid: i0.InputSignal<boolean | undefined>;
    readonly hostClasses: i0.Signal<Record<string, boolean>>;
    get checked(): boolean;
    static ɵfac: i0.ɵɵFactoryDeclaration<FormCheckInputDirective, never>;
    static ɵdir: i0.ɵɵDirectiveDeclaration<FormCheckInputDirective, "input[cFormCheckInput]", never, { "type": { "alias": "type"; "required": false; "isSignal": true; }; "indeterminateInput": { "alias": "indeterminate"; "required": false; "isSignal": true; }; "valid": { "alias": "valid"; "required": false; "isSignal": true; }; }, {}, never, never, true, never>;
}

declare class FormFeedbackComponent {
    /**
     * If your form layout allows it, you can display validation feedback in a styled tooltip.
     * @default false
     */
    readonly tooltip: i0.InputSignalWithTransform<boolean, unknown>;
    /**
     * Set component validation state to valid.
     * @default undefined
     */
    readonly valid: i0.InputSignal<boolean | undefined>;
    readonly hostClasses: i0.Signal<Record<string, boolean>>;
    static ɵfac: i0.ɵɵFactoryDeclaration<FormFeedbackComponent, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<FormFeedbackComponent, "c-form-feedback", never, { "tooltip": { "alias": "tooltip"; "required": false; "isSignal": true; }; "valid": { "alias": "valid"; "required": false; "isSignal": true; }; }, {}, never, ["*"], true, never>;
}

declare class FormFloatingDirective {
    /**
     * Enable floating labels
     * @dafault boolean
     */
    readonly floating: i0.InputSignalWithTransform<boolean, unknown>;
    static ɵfac: i0.ɵɵFactoryDeclaration<FormFloatingDirective, never>;
    static ɵdir: i0.ɵɵDirectiveDeclaration<FormFloatingDirective, "[cFormFloating]", never, { "floating": { "alias": "cFormFloating"; "required": false; "isSignal": true; }; }, {}, never, never, true, never>;
}

declare class FormLabelDirective {
    /**
     * For horizontal forms set labels to 'col' and make them vertically centered with their associated form controls.
     * @default ''
     */
    readonly col: i0.InputSignal<"" | "col">;
    /**
     * Size the label small or large.
     * @default ''
     */
    readonly sizing: i0.InputSignal<string | undefined>;
    readonly hostClasses: i0.Signal<Record<string, boolean>>;
    static ɵfac: i0.ɵɵFactoryDeclaration<FormLabelDirective, never>;
    static ɵdir: i0.ɵɵDirectiveDeclaration<FormLabelDirective, "[cLabel]", never, { "col": { "alias": "cLabel"; "required": false; "isSignal": true; }; "sizing": { "alias": "sizing"; "required": false; "isSignal": true; }; }, {}, never, never, true, never>;
}

declare class FormSelectDirective {
    /**
     * Size the component small or large.
     * @default undefined
     */
    readonly sizing: i0.InputSignal<string | undefined>;
    /**
     * Set component validation state to valid.
     * @default undefined
     */
    readonly valid: i0.InputSignal<boolean | undefined>;
    readonly hostClasses: i0.Signal<Record<string, boolean>>;
    static ɵfac: i0.ɵɵFactoryDeclaration<FormSelectDirective, never>;
    static ɵdir: i0.ɵɵDirectiveDeclaration<FormSelectDirective, "select[cSelect]", never, { "sizing": { "alias": "sizing"; "required": false; "isSignal": true; }; "valid": { "alias": "valid"; "required": false; "isSignal": true; }; }, {}, never, never, true, never>;
}

declare class FormTextDirective {
    static ɵfac: i0.ɵɵFactoryDeclaration<FormTextDirective, never>;
    static ɵdir: i0.ɵɵDirectiveDeclaration<FormTextDirective, "[cFormText]", never, {}, {}, never, never, true, never>;
}

declare class InputGroupComponent {
    /**
     * Size the component small or large.
     */
    readonly sizing: i0.InputSignal<string | undefined>;
    readonly hostClasses: i0.Signal<Record<string, boolean>>;
    static ɵfac: i0.ɵɵFactoryDeclaration<InputGroupComponent, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<InputGroupComponent, "c-input-group", never, { "sizing": { "alias": "sizing"; "required": false; "isSignal": true; }; }, {}, never, ["*"], true, never>;
}

declare class InputGroupTextDirective {
    static ɵfac: i0.ɵɵFactoryDeclaration<InputGroupTextDirective, never>;
    static ɵdir: i0.ɵɵDirectiveDeclaration<InputGroupTextDirective, "[cInputGroupText]", never, {}, {}, never, never, true, never>;
}

declare class FormModule {
    static ɵfac: i0.ɵɵFactoryDeclaration<FormModule, never>;
    static ɵmod: i0.ɵɵNgModuleDeclaration<FormModule, never, [typeof FormDirective, typeof FormCheckComponent, typeof FormCheckLabelDirective, typeof FormCheckInputDirective, typeof FormControlDirective, typeof FormFeedbackComponent, typeof FormFloatingDirective, typeof FormLabelDirective, typeof FormSelectDirective, typeof FormTextDirective, typeof InputGroupComponent, typeof InputGroupTextDirective], [typeof FormDirective, typeof FormCheckComponent, typeof FormCheckLabelDirective, typeof FormCheckInputDirective, typeof FormControlDirective, typeof FormFeedbackComponent, typeof FormFloatingDirective, typeof FormLabelDirective, typeof FormSelectDirective, typeof FormTextDirective, typeof InputGroupComponent, typeof InputGroupTextDirective]>;
    static ɵinj: i0.ɵɵInjectorDeclaration<FormModule>;
}

declare class ContainerComponent {
    /**
     * Set container 100% wide until a breakpoint.
     */
    readonly breakpoint: i0.InputSignal<string>;
    /**
     * Set container 100% wide, spanning the entire width of the viewport.
     * @return boolean
     */
    readonly fluid: i0.InputSignalWithTransform<boolean, unknown>;
    readonly hostClasses: i0.Signal<Record<string, boolean>>;
    static ɵfac: i0.ɵɵFactoryDeclaration<ContainerComponent, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<ContainerComponent, "c-container, [cContainer]", never, { "breakpoint": { "alias": "breakpoint"; "required": false; "isSignal": true; }; "fluid": { "alias": "fluid"; "required": false; "isSignal": true; }; }, {}, never, ["*"], true, never>;
}

type ColOrder = (number | 'first' | 'last');

type ColOffsetType = number | {
    xs?: number;
    sm?: number;
    md?: number;
    lg?: number;
    xl?: number;
    xxl?: number;
};
type ColOrderType = ColOrder | {
    xs?: ColOrder;
    sm?: ColOrder;
    md?: ColOrder;
    lg?: ColOrder;
    xl?: ColOrder;
    xxl?: ColOrder;
};
declare class ColDirective {
    static ngAcceptInputType_cCol: BooleanInput$1 | NumberInput$1;
    static ngAcceptInputType_xs: BooleanInput$1 | NumberInput$1;
    static ngAcceptInputType_sm: BooleanInput$1 | NumberInput$1;
    static ngAcceptInputType_md: BooleanInput$1 | NumberInput$1;
    static ngAcceptInputType_lg: BooleanInput$1 | NumberInput$1;
    static ngAcceptInputType_xl: BooleanInput$1 | NumberInput$1;
    static ngAcceptInputType_xxl: BooleanInput$1 | NumberInput$1;
    /**
     * The number of columns/offset/order on extra small devices (<576px).
     * @return { 'auto' | number |  boolean }
     */
    readonly cCol: i0.InputSignalWithTransform<number | boolean | "auto", string | number | boolean | null | undefined>;
    readonly xs: i0.InputSignalWithTransform<number | boolean | "auto", string | number | boolean | null | undefined>;
    /**
     * The number of columns/offset/order on small devices (<768px).
     * @return { 'auto' | number |  boolean }
     */
    readonly sm: i0.InputSignalWithTransform<number | boolean | "auto", string | number | boolean | null | undefined>;
    /**
     * The number of columns/offset/order on medium devices (<992px).
     * @return { 'auto' | number |  boolean }
     */
    readonly md: i0.InputSignalWithTransform<number | boolean | "auto", string | number | boolean | null | undefined>;
    /**
     * The number of columns/offset/order on large devices (<1200px).
     * @return { 'auto' | number |  boolean }
     */
    readonly lg: i0.InputSignalWithTransform<number | boolean | "auto", string | number | boolean | null | undefined>;
    /**
     * The number of columns/offset/order on X-Large devices (<1400px).
     * @return { 'auto' | number |  boolean }
     */
    readonly xl: i0.InputSignalWithTransform<number | boolean | "auto", string | number | boolean | null | undefined>;
    /**
     * The number of columns/offset/order on XX-Large devices (≥1400px).
     * @return { 'auto' | number |  boolean }
     */
    readonly xxl: i0.InputSignalWithTransform<number | boolean | "auto", string | number | boolean | null | undefined>;
    readonly breakpoints: i0.Signal<Record<string, any>>;
    readonly offset: i0.InputSignal<ColOffsetType | undefined>;
    readonly order: i0.InputSignal<ColOrderType | undefined>;
    readonly hostClasses: i0.Signal<Record<string, boolean>>;
    coerceInput(value: BooleanInput$1 | NumberInput$1): number | boolean | "auto";
    static ɵfac: i0.ɵɵFactoryDeclaration<ColDirective, never>;
    static ɵdir: i0.ɵɵDirectiveDeclaration<ColDirective, "[cCol]", never, { "cCol": { "alias": "cCol"; "required": false; "isSignal": true; }; "xs": { "alias": "xs"; "required": false; "isSignal": true; }; "sm": { "alias": "sm"; "required": false; "isSignal": true; }; "md": { "alias": "md"; "required": false; "isSignal": true; }; "lg": { "alias": "lg"; "required": false; "isSignal": true; }; "xl": { "alias": "xl"; "required": false; "isSignal": true; }; "xxl": { "alias": "xxl"; "required": false; "isSignal": true; }; "offset": { "alias": "offset"; "required": false; "isSignal": true; }; "order": { "alias": "order"; "required": false; "isSignal": true; }; }, {}, never, never, true, never>;
}

declare class ColComponent extends ColDirective {
    static ɵfac: i0.ɵɵFactoryDeclaration<ColComponent, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<ColComponent, "c-col", never, {}, {}, never, ["*"], true, never>;
}

type NumberOfColumns = number | 'auto';

declare class RowDirective {
    /**
     * The number of columns/offset/order on extra small devices (<576px).
     * @return { cols: 'auto' | number }
     */
    readonly xs: i0.InputSignal<NumberOfColumns | undefined>;
    /**
     * The number of columns/offset/order on small devices (<768px).
     * @return { cols: 'auto' | number }
     */
    readonly sm: i0.InputSignal<NumberOfColumns | undefined>;
    /**
     * The number of columns/offset/order on medium devices (<992px).
     * @return { cols: 'auto' | number }
     */
    readonly md: i0.InputSignal<NumberOfColumns | undefined>;
    /**
     * The number of columns/offset/order on large devices (<1200px).
     * @return { cols: 'auto' | number }
     */
    readonly lg: i0.InputSignal<NumberOfColumns | undefined>;
    /**
     * The number of columns/offset/order on X-Large devices (<1400px).
     * @return { cols: 'auto' | number }
     */
    readonly xl: i0.InputSignal<NumberOfColumns | undefined>;
    /**
     * The number of columns/offset/order on XX-Large devices (≥1400px).
     * @return { cols: 'auto' | number }
     */
    readonly xxl: i0.InputSignal<NumberOfColumns | undefined>;
    readonly hostClasses: i0.Signal<Record<string, boolean>>;
    static ɵfac: i0.ɵɵFactoryDeclaration<RowDirective, never>;
    static ɵdir: i0.ɵɵDirectiveDeclaration<RowDirective, "[cRow]", never, { "xs": { "alias": "xs"; "required": false; "isSignal": true; }; "sm": { "alias": "sm"; "required": false; "isSignal": true; }; "md": { "alias": "md"; "required": false; "isSignal": true; }; "lg": { "alias": "lg"; "required": false; "isSignal": true; }; "xl": { "alias": "xl"; "required": false; "isSignal": true; }; "xxl": { "alias": "xxl"; "required": false; "isSignal": true; }; }, {}, never, never, true, never>;
}

declare class RowComponent extends RowDirective {
    static ɵfac: i0.ɵɵFactoryDeclaration<RowComponent, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<RowComponent, "c-row", never, {}, {}, never, ["*"], true, never>;
}

interface IGutter {
    gutter?: InputSignal<IGutterObject | GutterBreakpoints | Gutters>;
}
type Gutters = 0 | 1 | 2 | 3 | 4 | 5 | number;
interface IGutterObject {
    g?: Gutters;
    gx?: Gutters;
    gy?: Gutters;
}
type GutterBreakpoints = {
    [key in BreakpointInfix]?: IGutterObject;
};

declare class GutterDirective implements IGutter {
    /**
     * Define padding between columns to space and align content responsively in the Bootstrap grid system.
     */
    readonly gutter: i0.InputSignal<number | IGutterObject | GutterBreakpoints>;
    readonly hostClasses: i0.Signal<Record<string, boolean>>;
    private static getGutterClasses;
    static ɵfac: i0.ɵɵFactoryDeclaration<GutterDirective, never>;
    static ɵdir: i0.ɵɵDirectiveDeclaration<GutterDirective, "[gutter]", ["gutter"], { "gutter": { "alias": "gutter"; "required": false; "isSignal": true; }; }, {}, never, never, true, never>;
}

declare class GridModule {
    static ɵfac: i0.ɵɵFactoryDeclaration<GridModule, never>;
    static ɵmod: i0.ɵɵNgModuleDeclaration<GridModule, never, [typeof ColComponent, typeof ColDirective, typeof ContainerComponent, typeof GutterDirective, typeof RowComponent, typeof RowDirective], [typeof ColComponent, typeof ColDirective, typeof ContainerComponent, typeof GutterDirective, typeof RowComponent, typeof RowDirective]>;
    static ɵinj: i0.ɵɵInjectorDeclaration<GridModule>;
}

type Container = boolean | 'sm' | 'md' | 'lg' | 'xl' | 'xxl' | 'fluid';
declare class HeaderComponent {
    /**
     * Defines optional container wrapping children elements.
     */
    readonly container: InputSignal<Container | undefined>;
    /**
     * Place header in non-static positions.
     */
    readonly position: InputSignal<Positions | undefined>;
    /**
     * Default role for header. [docs]
     * @type string
     * @default 'banner'
     */
    readonly role: InputSignal<string>;
    readonly hostClasses: i0.Signal<Record<string, boolean>>;
    readonly headerClasses: i0.Signal<Record<string, boolean>>;
    readonly containerClasses: i0.Signal<Record<string, boolean>>;
    static ɵfac: i0.ɵɵFactoryDeclaration<HeaderComponent, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<HeaderComponent, "c-header, [c-header]", ["cHeader"], { "container": { "alias": "container"; "required": false; "isSignal": true; }; "position": { "alias": "position"; "required": false; "isSignal": true; }; "role": { "alias": "role"; "required": false; "isSignal": true; }; }, {}, never, ["*", "*"], true, never>;
}

declare class HeaderBrandComponent {
    /**
     * Default role for header-brand. [docs]
     * @return string
     * @default 'button'
     */
    readonly role: i0.InputSignal<string>;
    static ɵfac: i0.ɵɵFactoryDeclaration<HeaderBrandComponent, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<HeaderBrandComponent, "c-header-brand", ["cHeaderBrand"], { "role": { "alias": "role"; "required": false; "isSignal": true; }; }, {}, never, ["*"], true, never>;
}

declare class HeaderDividerComponent {
    static ɵfac: i0.ɵɵFactoryDeclaration<HeaderDividerComponent, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<HeaderDividerComponent, "c-header-divider, [cHeaderDivider]", never, {}, {}, never, never, true, never>;
}

declare class HeaderNavComponent {
    /**
     * Default role for header-nav. [docs]
     * @return string
     * @default 'navigation'
     */
    readonly role: i0.InputSignal<string>;
    static ɵfac: i0.ɵɵFactoryDeclaration<HeaderNavComponent, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<HeaderNavComponent, "c-header-nav", ["cHeaderNav"], { "role": { "alias": "role"; "required": false; "isSignal": true; }; }, {}, never, ["*"], true, never>;
}

declare class HeaderTextComponent {
    static ɵfac: i0.ɵɵFactoryDeclaration<HeaderTextComponent, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<HeaderTextComponent, "c-header-text, [cHeaderText]", never, {}, {}, never, ["*"], true, never>;
}

declare class HeaderTogglerDirective implements AfterContentInit {
    #private;
    /**
     * Default type for header-toggler button. [docs]
     * @return string
     * @default 'button'
     */
    readonly type: i0.InputSignal<string>;
    /**
     * Default aria-label attr for header-toggler. [docs]
     * @type string
     * @default 'Toggle navigation'
     */
    readonly ariaLabel: i0.InputSignal<string>;
    addDefaultIcon(): void;
    ngAfterContentInit(): void;
    static ɵfac: i0.ɵɵFactoryDeclaration<HeaderTogglerDirective, never>;
    static ɵdir: i0.ɵɵDirectiveDeclaration<HeaderTogglerDirective, "[cHeaderToggler]", ["cHeaderToggler"], { "type": { "alias": "type"; "required": false; "isSignal": true; }; "ariaLabel": { "alias": "ariaLabel"; "required": false; "isSignal": true; }; }, {}, never, never, true, never>;
}

declare class HeaderModule {
    static ɵfac: i0.ɵɵFactoryDeclaration<HeaderModule, never>;
    static ɵmod: i0.ɵɵNgModuleDeclaration<HeaderModule, never, [typeof HeaderComponent, typeof HeaderBrandComponent, typeof HeaderDividerComponent, typeof HeaderNavComponent, typeof HeaderTextComponent, typeof HeaderTogglerDirective], [typeof HeaderComponent, typeof HeaderBrandComponent, typeof HeaderDividerComponent, typeof HeaderNavComponent, typeof HeaderTextComponent, typeof HeaderTogglerDirective]>;
    static ɵinj: i0.ɵɵInjectorDeclaration<HeaderModule>;
}

declare class ImgDirective {
    /**
     * Set the horizontal aligment.
     * @type {'' | 'start' | 'end' | 'center'}
     */
    readonly align: InputSignal<'' | 'start' | 'end' | 'center'>;
    /**
     * Make image responsive.
     * @type boolean
     */
    readonly fluid: InputSignalWithTransform<boolean, unknown>;
    /**
     * Make image rounded.
     * @type boolean
     */
    readonly rounded: InputSignalWithTransform<boolean, unknown>;
    /**
     * Give an image a rounded 1px border appearance.
     * @type boolean
     */
    readonly thumbnail: InputSignalWithTransform<boolean, unknown>;
    /**
     * Color for image placeholder.
     */
    readonly placeholderColor: InputSignal<string>;
    readonly hostStyles: i0.Signal<{
        backgroundColor: string;
    }>;
    readonly hostClasses: i0.Signal<Record<string, boolean>>;
    static ɵfac: i0.ɵɵFactoryDeclaration<ImgDirective, never>;
    static ɵdir: i0.ɵɵDirectiveDeclaration<ImgDirective, "[cImg]", never, { "align": { "alias": "align"; "required": false; "isSignal": true; }; "fluid": { "alias": "fluid"; "required": false; "isSignal": true; }; "rounded": { "alias": "rounded"; "required": false; "isSignal": true; }; "thumbnail": { "alias": "thumbnail"; "required": false; "isSignal": true; }; "placeholderColor": { "alias": "placeholderColor"; "required": false; "isSignal": true; }; }, {}, never, never, true, never>;
}

declare class ImgModule {
    static ɵfac: i0.ɵɵFactoryDeclaration<ImgModule, never>;
    static ɵmod: i0.ɵɵNgModuleDeclaration<ImgModule, never, [typeof ImgDirective], [typeof ImgDirective]>;
    static ɵinj: i0.ɵɵInjectorDeclaration<ImgModule>;
}

declare class ListGroupDirective {
    static ngAcceptInputType_flush: BooleanInput;
    /**
     * Remove some borders and rounded corners to render list group items edge-to-edge in a parent component (e.g., `<CCard>`).
     * @type boolean
     */
    readonly flush: InputSignalWithTransform<boolean, unknown>;
    /**
     * Specify horizontal layout type.
     */
    readonly horizontal: i0.InputSignal<string | boolean | undefined>;
    readonly hostClasses: i0.Signal<Record<string, boolean>>;
    static ɵfac: i0.ɵɵFactoryDeclaration<ListGroupDirective, never>;
    static ɵdir: i0.ɵɵDirectiveDeclaration<ListGroupDirective, "[cListGroup]", never, { "flush": { "alias": "flush"; "required": false; "isSignal": true; }; "horizontal": { "alias": "horizontal"; "required": false; "isSignal": true; }; }, {}, never, never, true, never>;
}

declare class ListGroupItemDirective {
    static ngAcceptInputType_active: BooleanInput;
    static ngAcceptInputType_disabled: BooleanInput;
    readonly hostElement: ElementRef<any>;
    /**
     * Toggle the active state for the component.
     * @type InputSignalWithTransform<boolean, unknown>
     */
    readonly active: InputSignalWithTransform<boolean, unknown>;
    /**
     * Sets the color context of the component to one of CoreUI’s themed colors.
     * @type InputSignal<boolean | undefined>
     */
    readonly color: InputSignal<Colors | undefined>;
    /**
     * Set disabled attr for the host element. [docs]
     * @type boolean
     */
    readonly disabled: InputSignalWithTransform<boolean, unknown>;
    /**
     * The tabindex attribute specifies the tab order of an element (when the "tab" button is used for navigating).
     */
    readonly tabindex: InputSignalWithTransform<number | undefined, unknown>;
    readonly hostClasses: i0.Signal<Record<string, boolean>>;
    readonly _disabled: i0.Signal<boolean>;
    readonly ariaDisabled: i0.Signal<true | null>;
    readonly attrDisabled: i0.Signal<"" | null>;
    readonly tabIndex: i0.Signal<number | "-1" | null>;
    readonly ariaCurrent: i0.Signal<true | null>;
    static ɵfac: i0.ɵɵFactoryDeclaration<ListGroupItemDirective, never>;
    static ɵdir: i0.ɵɵDirectiveDeclaration<ListGroupItemDirective, "[cListGroupItem], c-list-group-item", ["cListGroupItem"], { "active": { "alias": "active"; "required": false; "isSignal": true; }; "color": { "alias": "color"; "required": false; "isSignal": true; }; "disabled": { "alias": "disabled"; "required": false; "isSignal": true; }; "tabindex": { "alias": "tabindex"; "required": false; "isSignal": true; }; }, {}, never, never, true, never>;
}

declare class ListGroupModule {
    static ɵfac: i0.ɵɵFactoryDeclaration<ListGroupModule, never>;
    static ɵmod: i0.ɵɵNgModuleDeclaration<ListGroupModule, never, [typeof ListGroupDirective, typeof ListGroupItemDirective], [typeof ListGroupDirective, typeof ListGroupItemDirective]>;
    static ɵinj: i0.ɵɵInjectorDeclaration<ListGroupModule>;
}

declare class NavLinkDirective {
    #private;
    static ngAcceptInputType_disabled: BooleanInput;
    /**
     * Sets .nav-link class to the host. [docs]
     * @default true
     */
    readonly cNavLink: i0.InputSignalWithTransform<boolean, unknown>;
    /**
     * Toggle the active state for the component. [docs]
     * @default undefined
     */
    readonly active: i0.InputSignal<boolean | undefined>;
    /**
     * Set disabled attr for the host element. [docs]
     * @default false
     */
    readonly disabled: i0.InputSignalWithTransform<boolean, unknown>;
    /**
     * The tabindex attribute specifies the tab order of an element (when the "tab" button is used for navigating).
     */
    readonly tabindex: i0.InputSignalWithTransform<number | undefined, unknown>;
    readonly ariaCurrent: i0.Signal<"page" | null>;
    ariaDisabled: boolean | null;
    attrDisabled: boolean | string | null;
    attrTabindex: number | null;
    styleCursor: 'pointer' | null;
    readonly hostClasses: i0.Signal<Record<string, boolean>>;
    static ɵfac: i0.ɵɵFactoryDeclaration<NavLinkDirective, never>;
    static ɵdir: i0.ɵɵDirectiveDeclaration<NavLinkDirective, "[cNavLink]", never, { "cNavLink": { "alias": "cNavLink"; "required": false; "isSignal": true; }; "active": { "alias": "active"; "required": false; "isSignal": true; }; "disabled": { "alias": "disabled"; "required": false; "isSignal": true; }; "tabindex": { "alias": "tabindex"; "required": false; "isSignal": true; }; }, {}, never, never, true, never>;
}

declare class NavItemComponent {
    static ɵfac: i0.ɵɵFactoryDeclaration<NavItemComponent, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<NavItemComponent, "c-nav-item", never, {}, {}, never, ["*"], true, never>;
}

declare class NavComponent {
    /**
     * Specify a layout type for component.
     * @default undefined
     */
    readonly layout: i0.InputSignal<"fill" | "justified" | undefined>;
    /**
     * Set the nav variant to tabs or pills.
     * @default undefined
     */
    readonly variant: i0.InputSignal<"" | "tabs" | "pills" | "underline" | "underline-border" | undefined>;
    readonly hostClasses: i0.Signal<Record<string, boolean>>;
    static ɵfac: i0.ɵɵFactoryDeclaration<NavComponent, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<NavComponent, "c-nav", never, { "layout": { "alias": "layout"; "required": false; "isSignal": true; }; "variant": { "alias": "variant"; "required": false; "isSignal": true; }; }, {}, never, ["*"], true, never>;
}

declare class NavModule {
    static ɵfac: i0.ɵɵFactoryDeclaration<NavModule, never>;
    static ɵmod: i0.ɵɵNgModuleDeclaration<NavModule, never, [typeof NavComponent, typeof NavItemComponent, typeof NavLinkDirective], [typeof NavComponent, typeof NavItemComponent, typeof NavLinkDirective]>;
    static ɵinj: i0.ɵɵInjectorDeclaration<NavModule>;
}

declare class NavbarComponent implements AfterContentInit, OnDestroy {
    #private;
    /**
     * Sets the color context of the component to one of CoreUI’s themed colors.
     * @type Colors
     */
    readonly color: i0.InputSignal<string | undefined>;
    /**
     * Defines optional container wrapping children elements.
     */
    readonly container: i0.InputSignal<boolean | "sm" | "md" | "lg" | "xl" | "xxl" | "fluid" | undefined>;
    /**
     * Defines the responsive breakpoint to determine when content collapses.
     */
    readonly expand: i0.InputSignal<boolean | "sm" | "md" | "lg" | "xl" | "xxl" | undefined>;
    /**
     * Place component in non-static positions.
     */
    readonly placement: i0.InputSignal<"fixed-top" | "fixed-bottom" | "sticky-top" | undefined>;
    readonly role: i0.InputSignal<string>;
    readonly collapse: i0.Signal<CollapseDirective | undefined>;
    readonly hostClasses: i0.Signal<Record<string, boolean>>;
    readonly containerClass: i0.Signal<string>;
    readonly computedStyle: i0.WritableSignal<string>;
    readonly breakpoint: i0.Signal<string | false>;
    ngAfterContentInit(): void;
    ngOnDestroy(): void;
    static ɵfac: i0.ɵɵFactoryDeclaration<NavbarComponent, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<NavbarComponent, "c-navbar", never, { "color": { "alias": "color"; "required": false; "isSignal": true; }; "container": { "alias": "container"; "required": false; "isSignal": true; }; "expand": { "alias": "expand"; "required": false; "isSignal": true; }; "placement": { "alias": "placement"; "required": false; "isSignal": true; }; "role": { "alias": "role"; "required": false; "isSignal": true; }; }, {}, ["collapse"], ["*", "*"], true, [{ directive: typeof ThemeDirective; inputs: { "colorScheme": "colorScheme"; }; outputs: {}; }]>;
}

declare class NavbarBrandDirective {
    readonly role: i0.InputSignal<string>;
    static ɵfac: i0.ɵɵFactoryDeclaration<NavbarBrandDirective, never>;
    static ɵdir: i0.ɵɵDirectiveDeclaration<NavbarBrandDirective, "[cNavbarBrand]", never, { "role": { "alias": "role"; "required": false; "isSignal": true; }; }, {}, never, never, true, never>;
}

declare class NavbarNavComponent {
    /**
     * Enable vertical scrolling of a collapsed navbar toggleable contents.
     * @type boolean
     */
    readonly scroll: i0.InputSignalWithTransform<boolean, unknown>;
    readonly hostClasses: i0.Signal<Record<string, boolean>>;
    static ɵfac: i0.ɵɵFactoryDeclaration<NavbarNavComponent, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<NavbarNavComponent, "c-navbar-nav", never, { "scroll": { "alias": "scroll"; "required": false; "isSignal": true; }; }, {}, never, ["*"], true, never>;
}

declare class NavbarTextComponent {
    static ɵfac: i0.ɵɵFactoryDeclaration<NavbarTextComponent, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<NavbarTextComponent, "c-navbar-text", never, {}, {}, never, ["*"], true, never>;
}

declare class NavbarTogglerDirective {
    #private;
    constructor();
    /**
     * Reference to navbar collapse element (via # template variable) . [docs]
     * @type string
     * @default 'button'
     */
    readonly collapseRef: i0.InputSignal<CollapseDirective | undefined>;
    /**
     * Default type for navbar-toggler. [docs]
     * @type string
     * @default 'button'
     */
    readonly type: i0.InputSignal<string>;
    /**
     * Default aria-label attr for navbar-toggler. [docs]
     * @type string
     * @default 'Toggle navigation'
     */
    readonly ariaLabel: i0.InputSignal<string>;
    handleClick($event: MouseEvent): void;
    addDefaultIcon(): void;
    static ɵfac: i0.ɵɵFactoryDeclaration<NavbarTogglerDirective, never>;
    static ɵdir: i0.ɵɵDirectiveDeclaration<NavbarTogglerDirective, "[cNavbarToggler]", never, { "collapseRef": { "alias": "cNavbarToggler"; "required": false; "isSignal": true; }; "type": { "alias": "type"; "required": false; "isSignal": true; }; "ariaLabel": { "alias": "ariaLabel"; "required": false; "isSignal": true; }; }, {}, never, never, true, never>;
}

declare class NavbarModule {
    static ɵfac: i0.ɵɵFactoryDeclaration<NavbarModule, never>;
    static ɵmod: i0.ɵɵNgModuleDeclaration<NavbarModule, never, [typeof NavbarBrandDirective, typeof NavbarComponent, typeof NavbarNavComponent, typeof NavbarTextComponent, typeof NavbarTogglerDirective], [typeof NavbarBrandDirective, typeof NavbarComponent, typeof NavbarNavComponent, typeof NavbarTextComponent, typeof NavbarTogglerDirective]>;
    static ɵinj: i0.ɵɵInjectorDeclaration<NavbarModule>;
}

declare class ModalBodyComponent {
    static ɵfac: i0.ɵɵFactoryDeclaration<ModalBodyComponent, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<ModalBodyComponent, "c-modal-body", never, {}, {}, never, ["*"], true, never>;
}

declare class ModalContentComponent {
    static ɵfac: i0.ɵɵFactoryDeclaration<ModalContentComponent, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<ModalContentComponent, "c-modal-content", never, {}, {}, never, ["*"], true, never>;
}

declare class ModalDialogComponent {
    /**
     * Align the modal in the center or top of the screen.
     * @default undefined
     */
    readonly alignment: i0.InputSignal<"top" | "center" | undefined>;
    /**
     * Set modal to covers the entire user viewport.
     * @return {boolean | 'sm' | 'md' | 'lg' | 'xl' | 'xxl'}
     */
    readonly fullscreen: i0.InputSignal<boolean | "sm" | "md" | "lg" | "xl" | "xxl" | undefined>;
    /**
     * Does the modal dialog itself scroll, or does the whole dialog scroll within the window.
     * @default false
     * @return {boolean}
     */
    readonly scrollable: i0.InputSignalWithTransform<boolean, unknown>;
    /**
     * Size the component small, large, or extra large.
     * @default undefined
     * @return {'sm' | 'lg' | 'xl'}
     */
    readonly size: i0.InputSignal<"sm" | "lg" | "xl" | undefined>;
    readonly hostClasses: i0.Signal<Record<string, boolean>>;
    static ɵfac: i0.ɵɵFactoryDeclaration<ModalDialogComponent, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<ModalDialogComponent, "c-modal-dialog", never, { "alignment": { "alias": "alignment"; "required": false; "isSignal": true; }; "fullscreen": { "alias": "fullscreen"; "required": false; "isSignal": true; }; "scrollable": { "alias": "scrollable"; "required": false; "isSignal": true; }; "size": { "alias": "size"; "required": false; "isSignal": true; }; }, {}, never, ["*"], true, never>;
}

declare class ModalToggleDirective {
    #private;
    /**
     * Html id attr of modal to dismiss.
     * @default undefined
     */
    readonly toggle: i0.InputSignal<string | undefined>;
    dismiss($event: Event): void;
    static ɵfac: i0.ɵɵFactoryDeclaration<ModalToggleDirective, never>;
    static ɵdir: i0.ɵɵDirectiveDeclaration<ModalToggleDirective, "[cModalToggle]", never, { "toggle": { "alias": "cModalToggle"; "required": false; "isSignal": true; }; }, {}, never, never, true, never>;
}

declare class ModalFooterComponent {
    static ɵfac: i0.ɵɵFactoryDeclaration<ModalFooterComponent, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<ModalFooterComponent, "c-modal-footer", never, {}, {}, never, ["*"], true, never>;
}

declare class ModalHeaderComponent {
    static ɵfac: i0.ɵɵFactoryDeclaration<ModalHeaderComponent, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<ModalHeaderComponent, "c-modal-header", never, {}, {}, never, ["*"], true, never>;
}

declare class ModalTitleDirective {
    static ɵfac: i0.ɵɵFactoryDeclaration<ModalTitleDirective, never>;
    static ɵdir: i0.ɵɵDirectiveDeclaration<ModalTitleDirective, "[cModalTitle]", never, {}, {}, never, never, true, never>;
}

declare class ModalComponent implements OnInit, OnDestroy, AfterViewInit {
    #private;
    /**
     * Align the modal in the center or top of the screen.
     * @return {'top' | 'center'}
     * @default 'top'
     */
    readonly alignment: i0.InputSignal<"top" | "center">;
    /**
     * Apply a backdrop on body while modal is open.
     * @return boolean | 'static'
     * @default true
     */
    readonly backdrop: i0.InputSignal<boolean | "static">;
    /**
     * Set modal to cover the entire user viewport.
     * @return {boolean | 'sm' | 'md' | 'lg' | 'xl' | 'xxl'}
     * @default undefined
     */
    readonly fullscreen: i0.InputSignal<boolean | "sm" | "md" | "lg" | "xl" | "xxl" | undefined>;
    /**
     * Closes the modal when escape key is pressed.
     * @return boolean
     * @default true
     */
    readonly keyboard: i0.InputSignalWithTransform<boolean, unknown>;
    readonly attrId: i0.InputSignal<string | undefined>;
    get id(): string | undefined;
    /**
     * Size the component small, large, or extra large.
     * @return {'sm' | 'lg' | 'xl'}
     * @default undefined
     */
    readonly size: i0.InputSignal<"sm" | "lg" | "xl" | undefined>;
    /**
     * Remove animation to create modal that simply appear rather than fade in to view.
     */
    readonly transition: i0.InputSignalWithTransform<boolean, unknown>;
    /**
     * Default role for modal
     * @return string
     * @default 'dialog'
     */
    readonly role: i0.InputSignal<string>;
    /**
     * Set aria-modal html attr for modal
     * @type boolean
     * @default null
     */
    readonly ariaModalInput: i0.InputSignalWithTransform<boolean, unknown>;
    readonly ariaModal: i0.Signal<true | null>;
    /**
     * Create a scrollable modal that allows scrolling the modal body.
     * @return boolean
     * @default false
     */
    readonly scrollable: i0.InputSignalWithTransform<boolean, unknown>;
    /**
     * Toggle the visibility of modal component.
     * @return boolean
     * @default false
     */
    readonly visibleInput: i0.InputSignalWithTransform<boolean, unknown>;
    set visible(value: boolean);
    get visible(): boolean;
    /**
     * Event triggered on modal dismiss.
     * @return boolean
     */
    readonly visibleChange: i0.OutputEmitterRef<boolean>;
    readonly modalContentRef: i0.Signal<ElementRef<any> | undefined>;
    readonly hostClasses: i0.Signal<Record<string, boolean>>;
    get ariaHidden(): boolean | null;
    readonly animateTrigger: i0.Signal<"hidden" | "visible">;
    get show(): boolean;
    set show(value: boolean);
    animateStart(event: AnimationEvent): void;
    animateDone(event: AnimationEvent): void;
    onKeyUpHandler(event: KeyboardEvent): void;
    private mouseDownTarget;
    onMouseDownHandler($event: MouseEvent): void;
    onClickHandler($event: MouseEvent): void;
    ngOnInit(): void;
    ngAfterViewInit(): void;
    ngOnDestroy(): void;
    private stateToggleSubscribe;
    private setBackdrop;
    private setBodyStyles;
    private setStaticBackdrop;
    static ɵfac: i0.ɵɵFactoryDeclaration<ModalComponent, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<ModalComponent, "c-modal", ["cModal"], { "alignment": { "alias": "alignment"; "required": false; "isSignal": true; }; "backdrop": { "alias": "backdrop"; "required": false; "isSignal": true; }; "fullscreen": { "alias": "fullscreen"; "required": false; "isSignal": true; }; "keyboard": { "alias": "keyboard"; "required": false; "isSignal": true; }; "attrId": { "alias": "id"; "required": false; "isSignal": true; }; "size": { "alias": "size"; "required": false; "isSignal": true; }; "transition": { "alias": "transition"; "required": false; "isSignal": true; }; "role": { "alias": "role"; "required": false; "isSignal": true; }; "ariaModalInput": { "alias": "ariaModal"; "required": false; "isSignal": true; }; "scrollable": { "alias": "scrollable"; "required": false; "isSignal": true; }; "visibleInput": { "alias": "visible"; "required": false; "isSignal": true; }; }, { "visibleChange": "visibleChange"; }, never, ["*"], true, never>;
}

interface IModalAction {
    show?: boolean | 'toggle';
    modal?: ModalComponent;
    id?: string;
}
declare class ModalService {
    #private;
    readonly modalState$: rxjs.Observable<any>;
    toggle(action: IModalAction): void;
    static ɵfac: i0.ɵɵFactoryDeclaration<ModalService, never>;
    static ɵprov: i0.ɵɵInjectableDeclaration<ModalService>;
}

declare class ModalModule {
    static ɵfac: i0.ɵɵFactoryDeclaration<ModalModule, never>;
    static ɵmod: i0.ɵɵNgModuleDeclaration<ModalModule, never, [typeof ModalBodyComponent, typeof ModalComponent, typeof ModalContentComponent, typeof ModalDialogComponent, typeof ModalFooterComponent, typeof ModalHeaderComponent, typeof ModalTitleDirective, typeof ModalToggleDirective], [typeof ModalBodyComponent, typeof ModalComponent, typeof ModalContentComponent, typeof ModalDialogComponent, typeof ModalFooterComponent, typeof ModalHeaderComponent, typeof ModalTitleDirective, typeof ModalToggleDirective]>;
    static ɵinj: i0.ɵɵInjectorDeclaration<ModalModule>;
}

declare class OffcanvasComponent implements OnInit, OnDestroy {
    #private;
    /**
     * Apply a backdrop on body while offcanvas is open.
     * @return boolean | 'static'
     * @default true
     */
    readonly backdrop: i0.InputSignal<boolean | "static">;
    /**
     * Closes the offcanvas when escape key is pressed [docs]
     * @return boolean
     * @default true
     */
    readonly keyboard: i0.InputSignalWithTransform<boolean, unknown>;
    /**
     * Components placement, there’s no default placement.
     * @return {'start' | 'end' | 'top' | 'bottom'}
     * @default 'start'
     */
    readonly placement: i0.InputSignal<string>;
    /**
     * Responsive offcanvas property hides content outside the viewport from a specified breakpoint and down.
     * @return boolean | 'sm' | 'md' | 'lg' | 'xl' | 'xxl';
     * @default true
     * @since 4.3.10
     */
    readonly responsive: i0.InputSignal<boolean | "sm" | "md" | "lg" | "xl" | "xxl" | undefined>;
    readonly id: i0.InputSignal<string>;
    /**
     * Default role for offcanvas. [docs]
     * @return string
     * @default 'dialog'
     */
    readonly role: i0.InputSignal<string>;
    /**
     * Set aria-modal html attr for offcanvas. [docs]
     * @return boolean
     * @default true
     */
    readonly ariaModal: i0.InputSignalWithTransform<boolean, unknown>;
    /**
     * Allow body scrolling while offcanvas is visible.
     * @return boolean
     * @default false
     */
    readonly scroll: i0.InputSignalWithTransform<boolean, unknown>;
    /**
     * Toggle the visibility of offcanvas component.
     * @return boolean
     * @default false
     */
    readonly visibleInput: i0.InputSignalWithTransform<boolean, unknown>;
    readonly visible: i0.WritableSignal<boolean>;
    readonly visibleEffect: i0.EffectRef;
    /**
     * Event triggered on visible change.
     * @return <boolean>
     */
    readonly visibleChange: i0.OutputEmitterRef<boolean>;
    readonly hostClasses: i0.Signal<Record<string, boolean>>;
    readonly ariaHidden: i0.Signal<true | null>;
    get tabIndex(): string | null;
    get show(): boolean;
    set show(value: boolean);
    get responsiveBreakpoint(): string | false;
    animateStart(event: AnimationEvent): void;
    animateDone(event: AnimationEvent): void;
    onKeyDownHandler(event: KeyboardEvent): void;
    ngOnInit(): void;
    ngOnDestroy(): void;
    setFocus(): void;
    private stateToggleSubscribe;
    private backdropClickSubscribe;
    protected setBackdrop(setBackdrop: boolean | 'static'): void;
    private layoutChangeSubscribe;
    static ɵfac: i0.ɵɵFactoryDeclaration<OffcanvasComponent, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<OffcanvasComponent, "c-offcanvas", ["cOffcanvas"], { "backdrop": { "alias": "backdrop"; "required": false; "isSignal": true; }; "keyboard": { "alias": "keyboard"; "required": false; "isSignal": true; }; "placement": { "alias": "placement"; "required": false; "isSignal": true; }; "responsive": { "alias": "responsive"; "required": false; "isSignal": true; }; "id": { "alias": "id"; "required": false; "isSignal": true; }; "role": { "alias": "role"; "required": false; "isSignal": true; }; "ariaModal": { "alias": "ariaModal"; "required": false; "isSignal": true; }; "scroll": { "alias": "scroll"; "required": false; "isSignal": true; }; "visibleInput": { "alias": "visible"; "required": false; "isSignal": true; }; }, { "visibleChange": "visibleChange"; }, never, ["*"], true, [{ directive: typeof ThemeDirective; inputs: { "dark": "dark"; }; outputs: {}; }]>;
}

declare class OffcanvasBodyComponent {
    static ɵfac: i0.ɵɵFactoryDeclaration<OffcanvasBodyComponent, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<OffcanvasBodyComponent, "c-offcanvas-body", never, {}, {}, never, ["*"], true, never>;
}

declare class OffcanvasHeaderComponent {
    static ɵfac: i0.ɵɵFactoryDeclaration<OffcanvasHeaderComponent, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<OffcanvasHeaderComponent, "c-offcanvas-header", never, {}, {}, never, ["*"], true, never>;
}

declare class OffcanvasTitleDirective {
    static ɵfac: i0.ɵɵFactoryDeclaration<OffcanvasTitleDirective, never>;
    static ɵdir: i0.ɵɵDirectiveDeclaration<OffcanvasTitleDirective, "[cOffcanvasTitle]", never, {}, {}, never, never, true, never>;
}

declare class OffcanvasToggleDirective {
    #private;
    /**
     * Html id attr of offcanvas to toggle.
     * @return string
     */
    readonly id: i0.InputSignal<string | undefined>;
    protected toggleOpen($event: MouseEvent): void;
    static ɵfac: i0.ɵɵFactoryDeclaration<OffcanvasToggleDirective, never>;
    static ɵdir: i0.ɵɵDirectiveDeclaration<OffcanvasToggleDirective, "[cOffcanvasToggle]", never, { "id": { "alias": "cOffcanvasToggle"; "required": false; "isSignal": true; }; }, {}, never, never, true, never>;
}

interface IOffcanvasAction {
    show?: boolean | 'toggle';
    offcanvas?: OffcanvasComponent;
    id?: string;
}
declare class OffcanvasService {
    private offcanvasState;
    offcanvasState$: rxjs.Observable<any>;
    toggle(action: IOffcanvasAction): void;
    static ɵfac: i0.ɵɵFactoryDeclaration<OffcanvasService, never>;
    static ɵprov: i0.ɵɵInjectableDeclaration<OffcanvasService>;
}

declare class OffcanvasModule {
    static ɵfac: i0.ɵɵFactoryDeclaration<OffcanvasModule, never>;
    static ɵmod: i0.ɵɵNgModuleDeclaration<OffcanvasModule, never, [typeof OffcanvasBodyComponent, typeof OffcanvasComponent, typeof OffcanvasHeaderComponent, typeof OffcanvasTitleDirective, typeof OffcanvasToggleDirective], [typeof OffcanvasBodyComponent, typeof OffcanvasComponent, typeof OffcanvasHeaderComponent, typeof OffcanvasTitleDirective, typeof OffcanvasToggleDirective]>;
    static ɵinj: i0.ɵɵInjectorDeclaration<OffcanvasModule>;
}

declare class PageLinkDirective {
    static ɵfac: i0.ɵɵFactoryDeclaration<PageLinkDirective, never>;
    static ɵdir: i0.ɵɵDirectiveDeclaration<PageLinkDirective, "[cPageLink]", never, {}, {}, never, never, true, never>;
}

declare class PageItemDirective {
    #private;
    /**
     * Toggle the active state for the component.
     * @return boolean
     */
    readonly active: i0.InputSignal<boolean | undefined>;
    /**
     * Toggle the disabled state for the component.
     * @return boolean
     */
    readonly disabled: i0.InputSignal<boolean | undefined>;
    readonly ariaCurrent: i0.Signal<"page" | null>;
    readonly hostClasses: i0.Signal<Record<string, boolean>>;
    readonly pageLinkElementRef: i0.Signal<ElementRef<any> | undefined>;
    readonly pageLinkElementRefEffect: i0.EffectRef;
    static ɵfac: i0.ɵɵFactoryDeclaration<PageItemDirective, never>;
    static ɵdir: i0.ɵɵDirectiveDeclaration<PageItemDirective, "[cPageItem]", never, { "active": { "alias": "active"; "required": false; "isSignal": true; }; "disabled": { "alias": "disabled"; "required": false; "isSignal": true; }; }, {}, ["pageLinkElementRef"], never, true, never>;
}

declare class PageItemComponent extends PageItemDirective {
    static ɵfac: i0.ɵɵFactoryDeclaration<PageItemComponent, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<PageItemComponent, "c-page-item", never, {}, {}, never, ["*"], true, never>;
}

declare class PaginationComponent {
    /**
     * Set the alignment of pagination components.
     * @values 'start', 'center', 'end'
     */
    readonly align: i0.InputSignal<"" | "start" | "end" | "center">;
    /**
     * Size the component small or large.
     * @values 'sm', 'lg'
     */
    readonly size: i0.InputSignal<"sm" | "lg" | undefined>;
    /**
     * Default role for pagination. [docs]
     * @return string
     * @default 'navigation'
     */
    readonly role: i0.InputSignal<string>;
    readonly paginationClass: i0.Signal<Record<string, boolean>>;
    static ɵfac: i0.ɵɵFactoryDeclaration<PaginationComponent, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<PaginationComponent, "c-pagination", never, { "align": { "alias": "align"; "required": false; "isSignal": true; }; "size": { "alias": "size"; "required": false; "isSignal": true; }; "role": { "alias": "role"; "required": false; "isSignal": true; }; }, {}, never, ["*"], true, never>;
}

declare class PaginationModule {
    static ɵfac: i0.ɵɵFactoryDeclaration<PaginationModule, never>;
    static ɵmod: i0.ɵɵNgModuleDeclaration<PaginationModule, never, [typeof PageItemComponent, typeof PageItemDirective, typeof PageLinkDirective, typeof PaginationComponent], [typeof PageItemComponent, typeof PageItemDirective, typeof PageLinkDirective, typeof PaginationComponent]>;
    static ɵinj: i0.ɵɵInjectorDeclaration<PaginationModule>;
}

declare class PlaceholderDirective {
    /**
     * placeholder toggler
     * @type boolean
     * @default false
     */
    readonly visible: InputSignalWithTransform<boolean, unknown>;
    /**
     * Size the placeholder xs, small, large.
     */
    readonly size: i0.InputSignal<"xs" | "sm" | "lg" | undefined>;
    readonly ariaHidden: i0.Signal<true | null>;
    readonly hostClasses: i0.Signal<Record<string, boolean>>;
    static ɵfac: i0.ɵɵFactoryDeclaration<PlaceholderDirective, never>;
    static ɵdir: i0.ɵɵDirectiveDeclaration<PlaceholderDirective, "[cPlaceholder]", ["cPlaceholder"], { "visible": { "alias": "cPlaceholder"; "required": false; "isSignal": true; }; "size": { "alias": "cPlaceholderSize"; "required": false; "isSignal": true; }; }, {}, never, never, true, never>;
}

declare class PlaceholderAnimationDirective {
    /**
     * Animation type for placeholder
     * @type 'glow' | 'wave'
     * @default undefined
     */
    readonly animation: InputSignal<'glow' | 'wave' | undefined>;
    readonly placeholder: i0.Signal<PlaceholderDirective | undefined>;
    readonly hostClasses: i0.Signal<Record<string, boolean>>;
    static ɵfac: i0.ɵɵFactoryDeclaration<PlaceholderAnimationDirective, never>;
    static ɵdir: i0.ɵɵDirectiveDeclaration<PlaceholderAnimationDirective, "[cPlaceholderAnimation]", never, { "animation": { "alias": "cPlaceholderAnimation"; "required": false; "isSignal": true; }; }, {}, ["placeholder"], never, true, never>;
}

declare class PlaceholderModule {
    static ɵfac: i0.ɵɵFactoryDeclaration<PlaceholderModule, never>;
    static ɵmod: i0.ɵɵNgModuleDeclaration<PlaceholderModule, never, [typeof PlaceholderDirective, typeof PlaceholderAnimationDirective], [typeof PlaceholderDirective, typeof PlaceholderAnimationDirective]>;
    static ɵinj: i0.ɵɵInjectorDeclaration<PlaceholderModule>;
}

declare class PopoverComponent implements OnDestroy {
    #private;
    readonly renderer: Renderer2;
    /**
     * Content of popover
     * @return {string | TemplateRef}
     */
    readonly content: i0.InputSignal<string | TemplateRef<any>>;
    /**
     * Toggle the visibility of popover component.
     * @return boolean
     */
    readonly visible: i0.InputSignalWithTransform<boolean, unknown>;
    readonly id: i0.InputSignal<string | undefined>;
    readonly role: i0.InputSignal<string>;
    readonly viewContainerRef: i0.Signal<ViewContainerRef | undefined>;
    private textNode;
    readonly hostClasses: i0.Signal<Record<string, boolean>>;
    ngOnDestroy(): void;
    private clear;
    private updateView;
    static ɵfac: i0.ɵɵFactoryDeclaration<PopoverComponent, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<PopoverComponent, "c-popover", never, { "content": { "alias": "content"; "required": false; "isSignal": true; }; "visible": { "alias": "visible"; "required": false; "isSignal": true; }; "id": { "alias": "id"; "required": false; "isSignal": true; }; "role": { "alias": "role"; "required": false; "isSignal": true; }; }, {}, never, never, true, never>;
}

declare class PopoverDirective implements OnDestroy, OnInit, AfterViewInit {
    #private;
    /**
     * Content of popover
     * @return {string | TemplateRef}
     */
    readonly content: i0.InputSignal<string | TemplateRef<any> | undefined>;
    /**
     * Optional popper Options object, takes precedence over cPopoverPlacement prop
     * @return Partial<Options>
     */
    readonly popperOptions: i0.InputSignal<Partial<Options>>;
    readonly popperOptionsComputed: i0.Signal<{
        placement: _popperjs_core.Placement;
        modifiers?: Partial<_popperjs_core.Modifier<any, any>>[] | undefined;
        strategy?: _popperjs_core.PositioningStrategy | undefined;
        onFirstUpdate?: ((arg0: Partial<_popperjs_core.State>) => void) | undefined;
    }>;
    /**
     * Describes the placement of your component after Popper.js has applied all the modifiers that may have flipped or altered the originally provided placement property.
     * @return: 'top' | 'bottom' | 'left' | 'right'
     * @default: 'top'
     */
    readonly placement: i0.InputSignal<"top" | "bottom" | "right" | "left">;
    /**
     * ElementRefDirective for positioning the tooltip on reference element
     * @return: ElementRefDirective
     * @default: undefined
     */
    readonly reference: i0.InputSignal<ElementRefDirective | undefined>;
    readonly referenceRef: i0.Signal<ElementRef<any>>;
    /**
     * Sets which event handlers you’d like provided to your toggle prop. You can specify one trigger or an array of them.
     * @return: Triggers | Triggers[]
     */
    readonly trigger: i0.InputSignal<Triggers | Triggers[]>;
    /**
     * Toggle the visibility of popover component.
     * @return boolean
     */
    readonly visible: i0.ModelSignal<boolean>;
    get ariaDescribedBy(): string | null;
    private tooltip;
    private tooltipId;
    private tooltipRef;
    private popperInstance;
    private _popperOptions;
    ngAfterViewInit(): void;
    ngOnDestroy(): void;
    ngOnInit(): void;
    private setListeners;
    private clearListeners;
    private intersectionServiceSubscribe;
    private getUID;
    private createTooltipElement;
    private destroyTooltipElement;
    private addTooltipElement;
    private removeTooltipElement;
    static ɵfac: i0.ɵɵFactoryDeclaration<PopoverDirective, never>;
    static ɵdir: i0.ɵɵDirectiveDeclaration<PopoverDirective, "[cPopover]", ["cPopover"], { "content": { "alias": "cPopover"; "required": false; "isSignal": true; }; "popperOptions": { "alias": "cPopoverOptions"; "required": false; "isSignal": true; }; "placement": { "alias": "cPopoverPlacement"; "required": false; "isSignal": true; }; "reference": { "alias": "cTooltipRef"; "required": false; "isSignal": true; }; "trigger": { "alias": "cPopoverTrigger"; "required": false; "isSignal": true; }; "visible": { "alias": "cPopoverVisible"; "required": false; "isSignal": true; }; }, { "visible": "cPopoverVisibleChange"; }, never, never, true, never>;
}

declare class PopoverModule {
    static ɵfac: i0.ɵɵFactoryDeclaration<PopoverModule, never>;
    static ɵmod: i0.ɵɵNgModuleDeclaration<PopoverModule, never, [typeof PopoverDirective, typeof PopoverComponent], [typeof PopoverDirective, typeof PopoverComponent]>;
    static ɵinj: i0.ɵɵInjectorDeclaration<PopoverModule>;
}

interface IProgress {
    height: number;
    thin: boolean;
    white: boolean;
}
interface IProgressBar extends IProgressBarStacked {
    animated?: boolean;
    color?: Colors;
    max?: number;
    precision: number;
    value?: number;
    variant?: 'striped';
    width?: number;
}
interface IProgressBarStacked {
    stacked?: boolean;
}

declare class ProgressBarDirective {
    #private;
    /**
     * Use to animate the stripes right to left via CSS3 animations.
     * @return boolean
     */
    readonly animated: i0.InputSignalWithTransform<boolean | undefined, unknown>;
    /**
     * Sets the color context of the component to one of CoreUI’s themed colors.
     * @values 'primary', 'secondary', 'success', 'danger', 'warning', 'info', 'dark', 'light'
     */
    readonly color: i0.InputSignal<string | undefined>;
    readonly precision: i0.InputSignalWithTransform<number, unknown>;
    /**
     * The percent value the ProgressBar.
     * @return number
     * @default 0
     */
    readonly value: i0.InputSignalWithTransform<number, unknown>;
    /**
     * Set the progress bar variant to optional striped.
     * @values 'striped'
     * @default undefined
     */
    readonly variant: i0.InputSignal<"striped" | undefined>;
    /**
     * The max value of the ProgressBar.
     * @return number
     * @default 100
     */
    readonly max: i0.InputSignalWithTransform<number, unknown>;
    /**
     * Set default html role attribute.
     * @return string
     */
    readonly role: i0.InputSignal<string>;
    static ɵfac: i0.ɵɵFactoryDeclaration<ProgressBarDirective, never>;
    static ɵdir: i0.ɵɵDirectiveDeclaration<ProgressBarDirective, "[cProgressBar]", ["cProgressBar"], { "animated": { "alias": "animated"; "required": false; "isSignal": true; }; "color": { "alias": "color"; "required": false; "isSignal": true; }; "precision": { "alias": "precision"; "required": false; "isSignal": true; }; "value": { "alias": "value"; "required": false; "isSignal": true; }; "variant": { "alias": "variant"; "required": false; "isSignal": true; }; "max": { "alias": "max"; "required": false; "isSignal": true; }; "role": { "alias": "role"; "required": false; "isSignal": true; }; }, {}, never, never, true, never>;
}

declare class ProgressBarComponent {
    #private;
    readonly hostClasses: i0.Signal<Record<string, boolean>>;
    static ɵfac: i0.ɵɵFactoryDeclaration<ProgressBarComponent, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<ProgressBarComponent, "c-progress-bar", never, {}, {}, never, ["*"], true, [{ directive: typeof ProgressBarDirective; inputs: { "animated": "animated"; "color": "color"; "max": "max"; "role": "role"; "value": "value"; "variant": "variant"; }; outputs: {}; }]>;
}

declare class ProgressComponent {
    #private;
    protected readonly progressBarDirective: ProgressBarDirective | null;
    constructor();
    readonly stacked: i0.WritableSignal<boolean>;
    readonly percent: i0.Signal<number>;
    readonly barValue: i0.WritableSignal<number | undefined>;
    readonly contentProgressBars: i0.Signal<readonly ProgressBarComponent[]>;
    /**
     * Sets the height of the component. If you set that value the inner `<CProgressBar>` will automatically resize accordingly.
     * @return number
     */
    readonly height: i0.InputSignalWithTransform<number, unknown>;
    /**
     * Displays thin progress.
     * @return boolean
     */
    readonly thin: i0.InputSignalWithTransform<boolean, unknown>;
    /**
     * Change the default color to white.
     * @return boolean
     */
    readonly white: i0.InputSignalWithTransform<boolean, unknown>;
    readonly hostClasses: i0.Signal<Record<string, boolean>>;
    readonly hostStyle: i0.Signal<any>;
    static ɵfac: i0.ɵɵFactoryDeclaration<ProgressComponent, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<ProgressComponent, "c-progress", ["cProgress"], { "height": { "alias": "height"; "required": false; "isSignal": true; }; "thin": { "alias": "thin"; "required": false; "isSignal": true; }; "white": { "alias": "white"; "required": false; "isSignal": true; }; }, {}, ["contentProgressBars"], ["*"], true, [{ directive: typeof ProgressBarDirective; inputs: { "animated": "animated"; "color": "color"; "max": "max"; "role": "role"; "value": "value"; "variant": "variant"; }; outputs: {}; }]>;
}

declare class ProgressStackedComponent {
    readonly stacked: i0.InputSignal<boolean>;
    static ɵfac: i0.ɵɵFactoryDeclaration<ProgressStackedComponent, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<ProgressStackedComponent, "c-progress-stacked", ["cProgressStacked"], { "stacked": { "alias": "stacked"; "required": false; "isSignal": true; }; }, {}, never, ["*"], true, never>;
}

declare class ProgressModule {
    static ɵfac: i0.ɵɵFactoryDeclaration<ProgressModule, never>;
    static ɵmod: i0.ɵɵNgModuleDeclaration<ProgressModule, never, [typeof ProgressComponent, typeof ProgressBarComponent, typeof ProgressBarDirective, typeof ProgressStackedComponent], [typeof ProgressComponent, typeof ProgressBarComponent, typeof ProgressBarDirective, typeof ProgressStackedComponent]>;
    static ɵinj: i0.ɵɵInjectorDeclaration<ProgressModule>;
}

interface IIntersectionObserverInit {
    root?: Element | null;
    rootMargin?: string;
    threshold?: number | number[];
}
declare class IntersectionService implements OnDestroy {
    #private;
    platformId: Object;
    readonly intersecting$: rxjs.Observable<any>;
    private defaultObserverOptions;
    hostElementRefs: Map<ElementRef, IntersectionObserver | null>;
    createIntersectionObserver(hostElement: ElementRef, observerOptions?: IIntersectionObserverInit): void;
    unobserve(elementRef: ElementRef): void;
    ngOnDestroy(): void;
    static ɵfac: i0.ɵɵFactoryDeclaration<IntersectionService, never>;
    static ɵprov: i0.ɵɵInjectableDeclaration<IntersectionService>;
}

interface IListenersConfig {
    hostElement: ElementRef;
    trigger?: Triggers | Triggers[];
    callbackOn?: () => void;
    callbackOff?: () => void;
    callbackToggle?: () => void;
}
declare class ListenersService {
    readonly renderer: Renderer2;
    private listeners;
    setListeners({ hostElement, trigger, callbackOn, callbackOff, callbackToggle, }: IListenersConfig): void;
    clearListeners(): void;
    static ɵfac: i0.ɵɵFactoryDeclaration<ListenersService, never>;
    static ɵprov: i0.ɵɵInjectableDeclaration<ListenersService>;
}

declare class ClassToggleService {
    #private;
    constructor();
    toggle(selector: any, className: string): void;
    static ɵfac: i0.ɵɵFactoryDeclaration<ClassToggleService, never>;
    static ɵprov: i0.ɵɵInjectableDeclaration<ClassToggleService>;
}

declare class LocalStorageService {
    #private;
    private platformId;
    private document;
    constructor();
    readonly data$: rxjs.Observable<{
        key: string;
        data: any;
    } | null>;
    setItem(key: string, data: any): void;
    getItem(key: string): any;
    removeItem(key: string): void;
    clear(): void;
    static ɵfac: i0.ɵɵFactoryDeclaration<LocalStorageService, never>;
    static ɵprov: i0.ɵɵInjectableDeclaration<LocalStorageService>;
}

declare class InMemoryStorageService implements Storage {
    #private;
    setItem(key: string, data: any): void;
    getItem(key: string): any;
    removeItem(key: string): void;
    clear(): void;
    get length(): number;
    key(index: number): string;
    static ɵfac: i0.ɵɵFactoryDeclaration<InMemoryStorageService, never>;
    static ɵprov: i0.ɵɵInjectableDeclaration<InMemoryStorageService>;
}

type ColorMode = 'light' | 'dark' | 'auto' | string | undefined;
declare class ColorModeService {
    #private;
    readonly eventName: WritableSignal<string>;
    readonly localStorageItemName: WritableSignal<string | undefined>;
    readonly localStorageItemName$: rxjs.Observable<string | undefined>;
    readonly colorMode: WritableSignal<ColorMode>;
    constructor();
    getStoredTheme(localStorageItemName: string): any;
    setStoredTheme(localStorageItemName: string, colorMode: string): void;
    removeStoredTheme(localStorageItemName: string): void;
    getDefaultScheme(localStorageItemName: string | undefined): any;
    getPrefersColorScheme(): "dark" | "light" | undefined;
    getDatasetTheme(): ColorMode;
    static ɵfac: i0.ɵɵFactoryDeclaration<ColorModeService, never>;
    static ɵprov: i0.ɵɵInjectableDeclaration<ColorModeService>;
}

declare class UIDService {
    #private;
    getUID(prefix?: string): string;
    static ɵfac: i0.ɵɵFactoryDeclaration<UIDService, never>;
    static ɵprov: i0.ɵɵInjectableDeclaration<UIDService>;
}

declare class RtlService {
    #private;
    isRTL(element?: HTMLElement | null): boolean;
    static ɵfac: i0.ɵɵFactoryDeclaration<RtlService, never>;
    static ɵprov: i0.ɵɵInjectableDeclaration<RtlService>;
}

interface ISidebarAction {
    unfoldable?: boolean | 'toggle';
    visible?: boolean | 'toggle';
    toggle?: 'visible' | 'unfoldable';
    narrow?: boolean;
    mobile?: boolean;
    sidebar?: SidebarComponent;
    id?: string;
}
declare class SidebarService {
    private sidebarState;
    sidebarState$: rxjs.Observable<ISidebarAction>;
    toggle(action: ISidebarAction): void;
    static ɵfac: i0.ɵɵFactoryDeclaration<SidebarService, never>;
    static ɵprov: i0.ɵɵInjectableDeclaration<SidebarService>;
}

declare class SidebarComponent implements OnChanges, OnDestroy, OnInit {
    #private;
    readonly state: i0.WritableSignal<ISidebarAction>;
    /**
     * Sets if the color of text should be colored for a light or dark background.
     * @return 'dark' | 'light'
     */
    readonly colorScheme: i0.InputSignal<"dark" | "light" | undefined>;
    /**
     * Sets html attribute id.
     * @return string
     */
    readonly id: i0.InputSignal<string | undefined>;
    /**
     * Make sidebar narrow.
     * @return boolean
     * @default false
     */
    readonly narrowInput: i0.InputSignalWithTransform<boolean, unknown>;
    set narrow(value: boolean);
    get narrow(): boolean;
    /**
     * Set sidebar to overlaid variant.
     * @return boolean
     * @default false
     */
    readonly overlaid: i0.InputSignalWithTransform<boolean, unknown>;
    /**
     * Components placement, there’s no default placement.
     * @return 'start' | 'end'
     */
    readonly placement: i0.InputSignal<"start" | "end" | undefined>;
    /**
     * Place sidebar in non-static positions.
     * @return 'fixed' | 'sticky'
     * @default 'fixed'
     */
    readonly position: i0.InputSignal<"fixed" | "sticky">;
    /**
     * Size the component small, large, or extra large.
     * @return 'sm' | 'lg' | 'xl'
     */
    readonly size: i0.InputSignal<"sm" | "lg" | "xl" | undefined>;
    /**
     * Expand narrowed sidebar on hover.
     * @type boolean
     * @default false
     */
    readonly unfoldableInput: i0.InputSignalWithTransform<boolean, unknown>;
    readonly unfoldable: i0.WritableSignal<boolean>;
    /**
     * Toggle the visibility of sidebar component.
     * @type boolean
     * @default false
     */
    readonly visibleInput: i0.InputSignalWithTransform<boolean, unknown>;
    set visible(value: boolean);
    get visible(): boolean;
    /**
     * Event emitted on visibility change.
     * @return boolean
     */
    readonly visibleChange: i0.OutputEmitterRef<boolean>;
    set sidebarState(value: ISidebarAction);
    get sidebarState(): ISidebarAction;
    get getMobileBreakpoint(): string;
    constructor();
    readonly hostClasses: i0.Signal<{
        [x: string]: boolean | "toggle" | undefined;
        sidebar: boolean;
        'sidebar-fixed': boolean;
        'sidebar-narrow': boolean;
        'sidebar-narrow-unfoldable': boolean;
        'sidebar-overlaid': boolean;
        show: boolean | "toggle" | undefined;
        hide: boolean;
    }>;
    ngOnInit(): void;
    ngOnDestroy(): void;
    ngOnChanges(changes: SimpleChanges): void;
    setInitialState(): void;
    private stateToggleSubscribe;
    layoutChangeSubscribe(subscribe?: boolean): void;
    static ɵfac: i0.ɵɵFactoryDeclaration<SidebarComponent, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<SidebarComponent, "c-sidebar", ["cSidebar"], { "colorScheme": { "alias": "colorScheme"; "required": false; "isSignal": true; }; "id": { "alias": "id"; "required": false; "isSignal": true; }; "narrowInput": { "alias": "narrow"; "required": false; "isSignal": true; }; "overlaid": { "alias": "overlaid"; "required": false; "isSignal": true; }; "placement": { "alias": "placement"; "required": false; "isSignal": true; }; "position": { "alias": "position"; "required": false; "isSignal": true; }; "size": { "alias": "size"; "required": false; "isSignal": true; }; "unfoldableInput": { "alias": "unfoldable"; "required": false; "isSignal": true; }; "visibleInput": { "alias": "visible"; "required": false; "isSignal": true; }; }, { "visibleChange": "visibleChange"; }, never, ["*"], true, never>;
}

declare class SidebarBrandComponent {
    readonly brandFull: i0.InputSignal<any>;
    readonly brandNarrow: i0.InputSignal<any>;
    readonly routerLink: i0.InputSignal<string | any[] | UrlTree | null | undefined>;
    readonly brandImg: i0.Signal<boolean>;
    static ɵfac: i0.ɵɵFactoryDeclaration<SidebarBrandComponent, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<SidebarBrandComponent, "c-sidebar-brand", never, { "brandFull": { "alias": "brandFull"; "required": false; "isSignal": true; }; "brandNarrow": { "alias": "brandNarrow"; "required": false; "isSignal": true; }; "routerLink": { "alias": "routerLink"; "required": false; "isSignal": true; }; }, {}, never, ["*"], true, never>;
}

/**
 * Allows the sidebar to be toggled/folded via click on host element.
 */
declare class SidebarToggleDirective {
    #private;
    /**
     * Id of sidebar for toggle action.
     * @return string
     */
    readonly id: i0.InputSignal<string | undefined>;
    /**
     * Sidebar property name for toggle action.
     *
     * @return 'visible' | 'unfoldable'
     * @default 'visible'
     */
    readonly toggle: i0.InputSignal<"visible" | "unfoldable">;
    toggleOpen($event: any): void;
    static ɵfac: i0.ɵɵFactoryDeclaration<SidebarToggleDirective, never>;
    static ɵdir: i0.ɵɵDirectiveDeclaration<SidebarToggleDirective, "[cSidebarToggle]", ["cSidebarToggle"], { "id": { "alias": "cSidebarToggle"; "required": false; "isSignal": true; }; "toggle": { "alias": "toggle"; "required": false; "isSignal": true; }; }, {}, never, never, true, never>;
}

declare class SidebarTogglerDirective {
    readonly role: i0.InputSignal<string>;
    get getStyles(): any;
    static ɵfac: i0.ɵɵFactoryDeclaration<SidebarTogglerDirective, never>;
    static ɵdir: i0.ɵɵDirectiveDeclaration<SidebarTogglerDirective, "[cSidebarToggler]", never, { "role": { "alias": "role"; "required": false; "isSignal": true; }; }, {}, never, never, true, [{ directive: typeof SidebarToggleDirective; inputs: { "cSidebarToggle": "cSidebarToggler"; "toggle": "toggle"; }; outputs: {}; }]>;
}

declare class SidebarHeaderComponent {
    static ɵfac: i0.ɵɵFactoryDeclaration<SidebarHeaderComponent, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<SidebarHeaderComponent, "c-sidebar-header", never, {}, {}, never, ["*"], true, never>;
}

declare class SidebarFooterComponent {
    static ɵfac: i0.ɵɵFactoryDeclaration<SidebarFooterComponent, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<SidebarFooterComponent, "c-sidebar-footer", never, {}, {}, never, ["*"], true, never>;
}

interface INavAttributes {
    [propName: string]: any;
}
interface INavWrapper {
    attributes: INavAttributes;
    element: string;
}
interface INavBadge {
    text: string;
    color: string;
    size?: string;
    class?: string;
}
interface INavLabel {
    class?: string;
    variant: string;
}
interface INavLinkProps {
    queryParams?: {
        [k: string]: any;
    };
    fragment?: string;
    queryParamsHandling?: 'merge' | 'preserve' | '' | null;
    preserveFragment?: boolean;
    skipLocationChange?: boolean;
    replaceUrl?: boolean;
    state?: {
        [k: string]: any;
    };
    routerLinkActiveOptions?: {
        exact: boolean;
    } | IsActiveMatchOptions;
    routerLinkActive?: string | string[];
    ariaCurrentWhenActive?: 'page' | 'step' | 'location' | 'date' | 'time' | true | false;
}
interface INavData {
    name?: string;
    url?: string | any[];
    href?: string;
    icon?: string;
    iconComponent?: any;
    badge?: INavBadge;
    title?: boolean;
    children?: INavData[];
    variant?: string;
    attributes?: INavAttributes;
    divider?: boolean;
    class?: string;
    label?: INavLabel;
    wrapper?: INavWrapper;
    linkProps?: INavLinkProps;
}

declare class SidebarNavHelper {
    itemType(item: INavData): string;
    isActive(router: any, item: INavData): boolean;
    hasBadge: (item: INavData) => boolean;
    hasIcon: (item: INavData) => boolean;
    hasIconComponent: (item: INavData) => boolean;
    getIconClass(item: INavData): any;
    static ɵfac: i0.ɵɵFactoryDeclaration<SidebarNavHelper, never>;
    static ɵprov: i0.ɵɵInjectableDeclaration<SidebarNavHelper>;
}

declare class SidebarNavGroupComponent implements OnInit, OnDestroy {
    #private;
    readonly helper: SidebarNavHelper;
    constructor();
    item: any;
    dropdownMode: 'path' | 'none' | 'close';
    show?: boolean;
    compact?: boolean;
    get hostClasses(): any;
    sidebarNav: ElementRef;
    navigationEndObservable: Observable<NavigationEnd>;
    navSubscription: Subscription;
    navGroupSubscription: Subscription;
    open: boolean;
    navItems: INavData[];
    display: any;
    ngOnInit(): void;
    samePath(url: string): boolean;
    openGroup(open: boolean): void;
    toggleGroup($event: any): void;
    ngOnDestroy(): void;
    onAnimationStart($event: AnimationEvent): void;
    onAnimationDone($event: AnimationEvent): void;
    static ɵfac: i0.ɵɵFactoryDeclaration<SidebarNavGroupComponent, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<SidebarNavGroupComponent, "c-sidebar-nav-group", never, { "item": { "alias": "item"; "required": false; }; "dropdownMode": { "alias": "dropdownMode"; "required": false; }; "show": { "alias": "show"; "required": false; }; "compact": { "alias": "compact"; "required": false; }; }, {}, never, never, true, never>;
    static ngAcceptInputType_compact: unknown;
}
declare class SidebarNavComponent implements OnChanges {
    #private;
    readonly sidebar: SidebarComponent | null;
    readonly helper: SidebarNavHelper;
    readonly router: Router;
    navItems?: INavData[];
    dropdownMode: 'path' | 'none' | 'close';
    groupItems?: boolean;
    compact?: boolean;
    get hostClasses(): any;
    role: string;
    navItemsArray: INavData[];
    ngOnChanges(changes: SimpleChanges): void;
    hideMobile(): void;
    static ɵfac: i0.ɵɵFactoryDeclaration<SidebarNavComponent, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<SidebarNavComponent, "c-sidebar-nav", never, { "navItems": { "alias": "navItems"; "required": false; }; "dropdownMode": { "alias": "dropdownMode"; "required": false; }; "groupItems": { "alias": "groupItems"; "required": false; }; "compact": { "alias": "compact"; "required": false; }; "role": { "alias": "role"; "required": false; }; }, {}, never, ["*"], true, never>;
    static ngAcceptInputType_groupItems: unknown;
    static ngAcceptInputType_compact: unknown;
}

declare class SidebarNavDividerComponent {
    readonly item: i0.InputSignal<INavData | undefined>;
    static ɵfac: i0.ɵɵFactoryDeclaration<SidebarNavDividerComponent, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<SidebarNavDividerComponent, "c-sidebar-nav-divider", never, { "item": { "alias": "item"; "required": false; "isSignal": true; }; }, {}, never, never, true, never>;
}

declare class SidebarNavLinkContentComponent {
    readonly helper: SidebarNavHelper;
    readonly item: i0.InputSignal<INavData>;
    static ɵfac: i0.ɵɵFactoryDeclaration<SidebarNavLinkContentComponent, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<SidebarNavLinkContentComponent, "c-sidebar-nav-link-content", never, { "item": { "alias": "item"; "required": false; "isSignal": true; }; }, {}, never, never, true, never>;
}
declare class SidebarNavLinkComponent implements OnInit, OnDestroy {
    readonly router: Router;
    readonly item: i0.InputSignal<INavData | undefined>;
    readonly linkClick: i0.OutputEmitterRef<void>;
    linkType: string;
    href: string;
    linkActive: boolean;
    private url;
    private navigationEndObservable;
    private navSubscription;
    constructor();
    ngOnInit(): void;
    ngOnDestroy(): void;
    getLinkType(): string;
    isDisabled(): boolean;
    isExternalLink(): boolean;
    linkClicked(): void;
    static ɵfac: i0.ɵɵFactoryDeclaration<SidebarNavLinkComponent, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<SidebarNavLinkComponent, "c-sidebar-nav-link", never, { "item": { "alias": "item"; "required": false; "isSignal": true; }; }, { "linkClick": "linkClick"; }, never, never, true, never>;
}

declare class SidebarNavTitleComponent {
    #private;
    readonly item: i0.InputSignal<INavData | undefined>;
    private addAttribs;
    private setStyle;
    private addClass;
    private setAttrib;
    static ɵfac: i0.ɵɵFactoryDeclaration<SidebarNavTitleComponent, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<SidebarNavTitleComponent, "c-sidebar-nav-title", never, { "item": { "alias": "item"; "required": false; "isSignal": true; }; }, {}, never, never, true, never>;
}

declare class SidebarNavLabelComponent {
    readonly helper: SidebarNavHelper;
    readonly item: i0.InputSignal<INavData>;
    readonly itemClass: i0.Signal<Record<string, boolean>>;
    readonly labelIconClass: i0.Signal<Record<string, boolean>>;
    static ɵfac: i0.ɵɵFactoryDeclaration<SidebarNavLabelComponent, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<SidebarNavLabelComponent, "c-sidebar-nav-label", never, { "item": { "alias": "item"; "required": false; "isSignal": true; }; }, {}, never, never, true, never>;
}

declare class SidebarNavIconPipe implements PipeTransform {
    transform(item: any, args?: any): any;
    static ɵfac: i0.ɵɵFactoryDeclaration<SidebarNavIconPipe, never>;
    static ɵpipe: i0.ɵɵPipeDeclaration<SidebarNavIconPipe, "cSidebarNavIcon", true>;
}

declare class SidebarNavBadgePipe implements PipeTransform {
    transform(item: any, args?: any): any;
    static ɵfac: i0.ɵɵFactoryDeclaration<SidebarNavBadgePipe, never>;
    static ɵpipe: i0.ɵɵPipeDeclaration<SidebarNavBadgePipe, "cSidebarNavBadge", true>;
}

declare class SidebarNavItemClassPipe implements PipeTransform {
    readonly helper: SidebarNavHelper;
    transform(item: any, args?: any[]): any;
    static ɵfac: i0.ɵɵFactoryDeclaration<SidebarNavItemClassPipe, never>;
    static ɵpipe: i0.ɵɵPipeDeclaration<SidebarNavItemClassPipe, "cSidebarNavItemClass", true>;
}

declare class SidebarNavLinkPipe implements PipeTransform {
    transform(item: any): any;
    static ɵfac: i0.ɵɵFactoryDeclaration<SidebarNavLinkPipe, never>;
    static ɵpipe: i0.ɵɵPipeDeclaration<SidebarNavLinkPipe, "cSidebarNavLink", true>;
}

declare class SidebarModule {
    static ɵfac: i0.ɵɵFactoryDeclaration<SidebarModule, never>;
    static ɵmod: i0.ɵɵNgModuleDeclaration<SidebarModule, never, [typeof SidebarComponent, typeof SidebarBrandComponent, typeof SidebarFooterComponent, typeof SidebarHeaderComponent, typeof SidebarNavComponent, typeof SidebarNavBadgePipe, typeof SidebarNavDividerComponent, typeof SidebarNavGroupComponent, typeof SidebarNavIconPipe, typeof SidebarNavItemClassPipe, typeof SidebarNavLabelComponent, typeof SidebarNavLinkComponent, typeof SidebarNavLinkContentComponent, typeof SidebarNavLinkPipe, typeof SidebarNavTitleComponent, typeof SidebarToggleDirective, typeof SidebarTogglerDirective], [typeof SidebarComponent, typeof SidebarToggleDirective, typeof SidebarTogglerDirective, typeof SidebarBrandComponent, typeof SidebarNavComponent, typeof SidebarHeaderComponent, typeof SidebarFooterComponent]>;
    static ɵinj: i0.ɵɵInjectorDeclaration<SidebarModule>;
}

declare class SpinnerComponent {
    /**
     * Sets the color context of the component to one of CoreUI’s themed colors.
     * @type Colors
     */
    readonly color: i0.InputSignal<string | undefined>;
    /**
     * Label for accessibility.
     * @type string
     * @default 'Loading...'
     */
    readonly label: i0.InputSignal<string>;
    /**
     * Size the component small.
     * @type string
     * @values 'sm'
     */
    readonly size: i0.InputSignal<"sm" | undefined>;
    /**
     * Set the button variant to an outlined button or a ghost button.
     * @values 'border' | 'grow'
     * @default 'border'
     */
    readonly variant: i0.InputSignal<"border" | "grow">;
    /**
     * Default role attr for Spinner. [docs]
     * @type string
     * @default 'status'
     */
    readonly role: i0.InputSignal<string>;
    readonly hostClasses: i0.Signal<Record<string, boolean>>;
    static ɵfac: i0.ɵɵFactoryDeclaration<SpinnerComponent, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<SpinnerComponent, "c-spinner", never, { "color": { "alias": "color"; "required": false; "isSignal": true; }; "label": { "alias": "label"; "required": false; "isSignal": true; }; "size": { "alias": "size"; "required": false; "isSignal": true; }; "variant": { "alias": "variant"; "required": false; "isSignal": true; }; "role": { "alias": "role"; "required": false; "isSignal": true; }; }, {}, never, ["*"], true, never>;
}

declare class SpinnerModule {
    static ɵfac: i0.ɵɵFactoryDeclaration<SpinnerModule, never>;
    static ɵmod: i0.ɵɵNgModuleDeclaration<SpinnerModule, never, [typeof SpinnerComponent], [typeof SpinnerComponent]>;
    static ɵinj: i0.ɵɵInjectorDeclaration<SpinnerModule>;
}

declare class TableColorDirective {
    /**
     * Use contextual color for tables, table rows or individual cells.
     * @return Colors
     */
    readonly color: i0.InputSignal<string | undefined>;
    readonly hostClasses: i0.Signal<Record<string, boolean>>;
    static ɵfac: i0.ɵɵFactoryDeclaration<TableColorDirective, never>;
    static ɵdir: i0.ɵɵDirectiveDeclaration<TableColorDirective, "[cTableColor]", ["cTableColor"], { "color": { "alias": "cTableColor"; "required": false; "isSignal": true; }; }, {}, never, never, true, never>;
}

declare class TableActiveDirective {
    /**
     * Highlight a table row or cell
     * @return boolean
     */
    readonly active: i0.InputSignalWithTransform<boolean, unknown>;
    static ɵfac: i0.ɵɵFactoryDeclaration<TableActiveDirective, never>;
    static ɵdir: i0.ɵɵDirectiveDeclaration<TableActiveDirective, "[cTableActive]", ["cTableActive"], { "active": { "alias": "cTableActive"; "required": false; "isSignal": true; }; }, {}, never, never, true, never>;
}

declare class TableDirective {
    #private;
    static ngAcceptInputType_bordered: BooleanInput$1;
    static ngAcceptInputType_borderless: BooleanInput$1;
    static ngAcceptInputType_hover: BooleanInput$1;
    static ngAcceptInputType_small: BooleanInput$1;
    static ngAcceptInputType_striped: BooleanInput$1;
    static ngAcceptInputType_stripedColumns: BooleanInput$1;
    /**
     * Set the vertical alignment.
     * @return string
     * @values 'bottom' | 'middle' | 'top'
     */
    readonly align: i0.InputSignal<"top" | "middle" | "bottom" | undefined>;
    /**
     * Sets the border color of the component to one of CoreUI’s themed colors.
     * @return Colors
     */
    readonly borderColor: i0.InputSignal<string | undefined>;
    /**
     * Add borders on all sides of the table and cells.
     * @return boolean
     */
    readonly bordered: i0.InputSignalWithTransform<boolean, unknown>;
    /**
     * Remove borders on all sides of the table and cells.
     * @return boolean
     */
    readonly borderless: i0.InputSignalWithTransform<boolean, unknown>;
    /**
     * Put the `<caption>` on the top of the table.
     * @return 'top'
     * @values 'top'
     */
    readonly caption: i0.InputSignal<"top" | undefined>;
    /**
     * Sets the color context of the component to one of CoreUI’s themed colors.
     * @return Colors
     */
    readonly color: i0.InputSignal<string | undefined>;
    /**
     * Enable a hover state on table rows within table body.
     * @return boolean
     */
    readonly hover: i0.InputSignalWithTransform<boolean, unknown>;
    /**
     * Make table responsive across all viewports or pick a maximum breakpoint with which to have a responsive table up to.
     * @values: {boolean | 'sm' | 'md' | 'lg' | 'xl' | 'xxl'}
     */
    readonly responsive: i0.InputSignal<boolean | Omit<string, "xs"> | undefined>;
    /**
     * Make table more compact by cutting all cell `padding` in half.
     * @return boolean
     */
    readonly small: i0.InputSignalWithTransform<boolean, unknown>;
    /**
     * Add zebra-striping to any table row within the table body.
     * @return boolean
     */
    readonly striped: i0.InputSignalWithTransform<boolean, unknown>;
    /**
     * Add zebra-striping to any table column.
     * @return boolean
     * @since 4.2.4
     */
    readonly stripedColumns: i0.InputSignalWithTransform<boolean, unknown>;
    readonly hostClasses: i0.Signal<Record<string, boolean>>;
    static ɵfac: i0.ɵɵFactoryDeclaration<TableDirective, never>;
    static ɵdir: i0.ɵɵDirectiveDeclaration<TableDirective, "table[cTable]", ["cTable"], { "align": { "alias": "align"; "required": false; "isSignal": true; }; "borderColor": { "alias": "borderColor"; "required": false; "isSignal": true; }; "bordered": { "alias": "bordered"; "required": false; "isSignal": true; }; "borderless": { "alias": "borderless"; "required": false; "isSignal": true; }; "caption": { "alias": "caption"; "required": false; "isSignal": true; }; "color": { "alias": "color"; "required": false; "isSignal": true; }; "hover": { "alias": "hover"; "required": false; "isSignal": true; }; "responsive": { "alias": "responsive"; "required": false; "isSignal": true; }; "small": { "alias": "small"; "required": false; "isSignal": true; }; "striped": { "alias": "striped"; "required": false; "isSignal": true; }; "stripedColumns": { "alias": "stripedColumns"; "required": false; "isSignal": true; }; }, {}, never, never, true, never>;
}

declare class TableModule {
    static ɵfac: i0.ɵɵFactoryDeclaration<TableModule, never>;
    static ɵmod: i0.ɵɵNgModuleDeclaration<TableModule, never, [typeof TableDirective, typeof TableColorDirective, typeof TableActiveDirective], [typeof TableDirective, typeof TableColorDirective, typeof TableActiveDirective]>;
    static ɵinj: i0.ɵɵInjectorDeclaration<TableModule>;
}

declare class TabContentComponent implements AfterContentChecked, AfterContentInit, OnChanges, OnDestroy {
    #private;
    /**
     * Set active tabPane index
     * @type number
     */
    set activeTabPaneIdx(value: number);
    get activeTabPaneIdx(): number;
    /**
     * Event emitted on the active tab pane index change.
     */
    readonly activeTabPaneIdxChange: i0.OutputEmitterRef<number>;
    panes: QueryList<TabPaneComponent>;
    ngAfterContentInit(): void;
    ngAfterContentChecked(): void;
    ngOnChanges(changes: SimpleChanges): void;
    ngOnDestroy(): void;
    subscribeTabService(subscribe?: boolean): void;
    refreshTabPaneActive(idx: number): void;
    static ɵfac: i0.ɵɵFactoryDeclaration<TabContentComponent, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<TabContentComponent, "c-tab-content", ["cTabContent"], { "activeTabPaneIdx": { "alias": "activeTabPaneIdx"; "required": false; }; }, { "activeTabPaneIdxChange": "activeTabPaneIdxChange"; }, ["panes"], ["*"], true, never>;
    static ngAcceptInputType_activeTabPaneIdx: unknown;
}

declare class TabPaneComponent implements OnDestroy {
    #private;
    constructor();
    tabPaneIdx: number;
    tabContent: TabContentComponent;
    set active(value: boolean);
    get active(): boolean;
    get hostClasses(): {
        'tab-pane': boolean;
        fade: boolean;
        show: boolean;
        active: boolean;
    };
    role: string;
    ngOnDestroy(): void;
    subscribeTabService(subscribe?: boolean): void;
    static ɵfac: i0.ɵɵFactoryDeclaration<TabPaneComponent, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<TabPaneComponent, "c-tab-pane", ["cTabPane"], { "role": { "alias": "role"; "required": false; }; }, {}, never, ["*"], true, never>;
}

declare class TabContentRefDirective implements OnChanges, OnDestroy {
    #private;
    constructor();
    /**
     * Template Ref
     * @type TemplateRef
     */
    tabContentRef: any;
    /**
     * Set active state of tab content
     * @type boolean
     * @default false
     */
    set active(value: boolean);
    get active(): boolean;
    /**
     * Set disabled state of tab content
     * @type boolean
     */
    set disabled(value: boolean);
    get disabled(): boolean;
    /**
     * c-tab-pane index respectively
     * @type number
     */
    tabPaneIdx: number;
    get hostClasses(): {
        active: boolean;
        disabled: boolean;
    };
    get isDisabled(): boolean | null;
    get attrDisabled(): "" | null;
    private get ariaSelected();
    role: string;
    get getTabindex(): string | null;
    ngOnChanges(changes: SimpleChanges): void;
    toggleOpen($event: any): void;
    setActiveTabPane(): void;
    ngOnDestroy(): void;
    subscribeTabService(subscribe?: boolean): void;
    static ɵfac: i0.ɵɵFactoryDeclaration<TabContentRefDirective, never>;
    static ɵdir: i0.ɵɵDirectiveDeclaration<TabContentRefDirective, "[cTabContent]", never, { "tabContentRef": { "alias": "cTabContent"; "required": false; }; "active": { "alias": "active"; "required": false; }; "disabled": { "alias": "disabled"; "required": false; }; "tabPaneIdx": { "alias": "tabPaneIdx"; "required": false; }; "role": { "alias": "role"; "required": false; }; }, {}, never, never, true, never>;
    static ngAcceptInputType_active: unknown;
    static ngAcceptInputType_disabled: unknown;
    static ngAcceptInputType_tabPaneIdx: unknown;
}

interface ITabContentState {
    activeIdx: number;
    tabContent: TabContentComponent;
}
declare class TabService {
    private activeTabPaneIdx;
    activeTabPaneIdx$: rxjs.Observable<ITabContentState>;
    setActiveTabIdx(tabContentState: ITabContentState): void;
    static ɵfac: i0.ɵɵFactoryDeclaration<TabService, never>;
    static ɵprov: i0.ɵɵInjectableDeclaration<TabService>;
}

declare class TabsModule {
    static ɵfac: i0.ɵɵFactoryDeclaration<TabsModule, never>;
    static ɵmod: i0.ɵɵNgModuleDeclaration<TabsModule, never, [typeof TabContentComponent, typeof TabContentRefDirective, typeof TabPaneComponent], [typeof TabContentComponent, typeof TabPaneComponent, typeof TabContentRefDirective]>;
    static ɵinj: i0.ɵɵInjectorDeclaration<TabsModule>;
}

declare class TabsService {
    readonly activeItem: i0.WritableSignal<any>;
    readonly activeItemKey: i0.WritableSignal<string | number | undefined>;
    readonly id: i0.WritableSignal<string | number | undefined>;
    static ɵfac: i0.ɵɵFactoryDeclaration<TabsService, never>;
    static ɵprov: i0.ɵɵInjectableDeclaration<TabsService>;
}

declare class TabsComponent {
    #private;
    readonly tabsService: TabsService;
    /**
     * The active item key.
     * @type <string | number | undefined>
     */
    readonly activeItemKey: ModelSignal<string | number | undefined>;
    /**
     * The id attribute
     * @type string
     */
    tabsId: string;
    readonly id: i0.InputSignal<string>;
    static ɵfac: i0.ɵɵFactoryDeclaration<TabsComponent, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<TabsComponent, "c-tabs", ["cTabs"], { "activeItemKey": { "alias": "activeItemKey"; "required": false; "isSignal": true; }; "id": { "alias": "id"; "required": false; "isSignal": true; }; }, { "activeItemKey": "activeItemKeyChange"; }, never, ["*"], true, never>;
}

declare class TabDirective implements FocusableOption, OnInit {
    #private;
    /**
     * Disabled attribute
     * @return boolean
     * @default false
     */
    readonly disabledInput: i0.InputSignalWithTransform<boolean, unknown>;
    readonly attrDisabled: i0.Signal<true | null>;
    set disabled(value: boolean);
    get disabled(): boolean;
    /**
     * Item key.
     * @type string | number
     * @required
     */
    readonly itemKey: InputSignal<string | number>;
    /**
     * Element id attribute
     * @type string
     * @default undefined
     */
    readonly id: InputSignal<string | undefined>;
    /**
     * aria-controls attribute
     * @type string
     * @default undefined
     */
    readonly ariaControls: InputSignal<string | undefined>;
    readonly isActive: i0.WritableSignal<boolean>;
    readonly hostClasses: i0.Signal<Record<string, boolean>>;
    readonly propId: i0.Signal<string>;
    readonly attrAriaControls: i0.Signal<string>;
    focus(origin?: FocusOrigin): void;
    ngOnInit(): void;
    static ɵfac: i0.ɵɵFactoryDeclaration<TabDirective, never>;
    static ɵdir: i0.ɵɵDirectiveDeclaration<TabDirective, "button[cTab]", ["cTab"], { "disabledInput": { "alias": "disabled"; "required": false; "isSignal": true; }; "itemKey": { "alias": "itemKey"; "required": true; "isSignal": true; }; "id": { "alias": "id"; "required": false; "isSignal": true; }; "ariaControls": { "alias": "aria-controls"; "required": false; "isSignal": true; }; }, {}, never, never, true, never>;
}

declare class TabsListComponent {
    #private;
    readonly tabsService: TabsService;
    constructor();
    /**
     * Specify a layout type for component.
     * @type 'fill' | 'justified' | undefined
     * @default undefined
     */
    readonly layout: InputSignal<'fill' | 'justified' | undefined>;
    /**
     * Set the variant to tabs, pills or underline.
     * @type 'pills' | 'tabs' | 'underline' | 'underline-border' | undefined
     * @default undefined
     */
    readonly variant: InputSignal<'pills' | 'tabs' | 'underline' | 'underline-border' | undefined>;
    /**
     * Set the role to tab list.
     * @default 'tablist'
     */
    readonly role: InputSignal<string>;
    readonly hostClasses: i0.Signal<Record<string, boolean>>;
    readonly tabs: i0.Signal<readonly TabDirective[]>;
    onKeyDown($event: any): void;
    static ɵfac: i0.ɵɵFactoryDeclaration<TabsListComponent, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<TabsListComponent, "c-tabs-list", ["cTabsList"], { "layout": { "alias": "layout"; "required": false; "isSignal": true; }; "variant": { "alias": "variant"; "required": false; "isSignal": true; }; "role": { "alias": "role"; "required": false; "isSignal": true; }; }, {}, ["tabs"], ["*"], true, never>;
}

declare class TabsContentComponent {
    static ɵfac: i0.ɵɵFactoryDeclaration<TabsContentComponent, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<TabsContentComponent, "c-tabs-content", ["cTabsContent"], {}, {}, never, ["*"], true, never>;
}

type VisibleChangeEvent = {
    itemKey: string | number;
    visible: boolean;
};
declare class TabPanelComponent {
    readonly tabsService: TabsService;
    /**
     * aria-labelledby attribute
     * @type string
     * @default undefined
     */
    readonly ariaLabelledBy: InputSignal<string | undefined>;
    /**
     * Element id attribute
     * @type string
     * @default undefined
     */
    readonly id: InputSignal<string | undefined>;
    /**
     * Item key.
     * @type string | number
     * @required
     */
    readonly itemKey: InputSignal<string | number>;
    /**
     * Element role.
     * @type string
     * @default 'tabpanel'
     */
    readonly role: InputSignal<string>;
    /**
     * tabindex attribute.
     * @type number
     * @default 0
     */
    readonly tabindex: InputSignalWithTransform<number, unknown>;
    /**
     * Enable fade in transition.
     * @type boolean
     * @default true
     */
    readonly transition: InputSignal<boolean>;
    /**
     * visible change output
     * @type OutputEmitterRef<VisibleChangeEvent>
     */
    readonly visibleChange: OutputEmitterRef<VisibleChangeEvent>;
    readonly show: i0.WritableSignal<boolean>;
    readonly visible: i0.Signal<boolean>;
    readonly propId: i0.Signal<string>;
    readonly attrAriaLabelledBy: i0.Signal<string>;
    readonly hostClasses: i0.Signal<Record<string, boolean>>;
    onAnimationDone($event: AnimationEvent): void;
    static ɵfac: i0.ɵɵFactoryDeclaration<TabPanelComponent, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<TabPanelComponent, "c-tab-panel", ["cTabPanel"], { "ariaLabelledBy": { "alias": "aria-labelledby"; "required": false; "isSignal": true; }; "id": { "alias": "id"; "required": false; "isSignal": true; }; "itemKey": { "alias": "itemKey"; "required": true; "isSignal": true; }; "role": { "alias": "role"; "required": false; "isSignal": true; }; "tabindex": { "alias": "tabindex"; "required": false; "isSignal": true; }; "transition": { "alias": "transition"; "required": false; "isSignal": true; }; }, { "visibleChange": "visibleChange"; }, never, ["*"], true, never>;
}

declare class Tabs2Module {
    static ɵfac: i0.ɵɵFactoryDeclaration<Tabs2Module, never>;
    static ɵmod: i0.ɵɵNgModuleDeclaration<Tabs2Module, never, [typeof TabsComponent, typeof TabsListComponent, typeof TabDirective, typeof TabsContentComponent, typeof TabPanelComponent], [typeof TabsComponent, typeof TabsListComponent, typeof TabDirective, typeof TabsContentComponent, typeof TabPanelComponent]>;
    static ɵinj: i0.ɵɵInjectorDeclaration<Tabs2Module>;
}

declare class ToasterHostDirective {
    readonly viewContainerRef: ViewContainerRef;
    static ɵfac: i0.ɵɵFactoryDeclaration<ToasterHostDirective, never>;
    static ɵdir: i0.ɵɵDirectiveDeclaration<ToasterHostDirective, "[cToasterHost]", ["cToasterHost"], {}, {}, never, never, true, never>;
}

declare enum ToasterPlacement {
    Static = "static",
    TopStart = "top-start",
    TopCenter = "top-center",
    TopEnd = "top-end",
    MiddleStart = "middle-start",
    MiddleCenter = "middle-center",
    MiddleEnd = "middle-end",
    BottomStart = "bottom-start",
    BottomCenter = "bottom-center",
    BottomEnd = "bottom-end"
}
type TToasterPlacement = ToasterPlacement.Static | ToasterPlacement.TopStart | ToasterPlacement.TopCenter | ToasterPlacement.TopEnd | ToasterPlacement.MiddleStart | ToasterPlacement.MiddleCenter | ToasterPlacement.MiddleEnd | ToasterPlacement.BottomStart | ToasterPlacement.BottomCenter | ToasterPlacement.BottomEnd | string;
declare class ToasterComponent implements OnInit {
    #private;
    placements: ToasterPlacement[];
    toastsDynamic: ComponentRef<any>[];
    /**
     * Toaster placement
     * @return TToasterPlacement
     */
    readonly placementInput: i0.InputSignal<string>;
    get placement(): string;
    /**
     * Toaster position
     * @return (string | 'absolute' | 'fixed' | 'static')
     */
    readonly position: i0.InputSignal<string>;
    readonly toasterHost: i0.Signal<ToasterHostDirective>;
    readonly contentToasts: i0.Signal<readonly ViewContainerRef[]>;
    readonly hostClasses: i0.Signal<Record<string, boolean>>;
    ngOnInit(): void;
    addToast(toast: any, props: any, options?: {
        index?: number;
        injector?: Injector;
        ngModuleRef?: NgModuleRef<unknown>;
        projectableNodes?: Node[][];
    }): ComponentRef<any>;
    removeToast(state: IToasterAction): void;
    private stateToasterSubscribe;
    static ɵfac: i0.ɵɵFactoryDeclaration<ToasterComponent, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<ToasterComponent, "c-toaster", ["cToaster"], { "placementInput": { "alias": "placement"; "required": false; "isSignal": true; }; "position": { "alias": "position"; "required": false; "isSignal": true; }; }, {}, ["contentToasts"], ["*"], true, never>;
}

interface IToasterAction {
    placement?: TToasterPlacement;
    toast?: ToastComponent;
    show?: boolean;
}
declare class ToasterService {
    #private;
    readonly toasterState$: rxjs.Observable<IToasterAction>;
    setState(state: IToasterAction): void;
    static ɵfac: i0.ɵɵFactoryDeclaration<ToasterService, never>;
    static ɵprov: i0.ɵɵInjectableDeclaration<ToasterService>;
}

type AnimateType = 'hide' | 'show';
declare class ToastComponent implements OnInit, OnDestroy {
    #private;
    readonly changeDetectorRef: ChangeDetectorRef;
    readonly hostElement: ElementRef<any>;
    readonly renderer: Renderer2;
    readonly toasterService: ToasterService;
    readonly dynamic: i0.InputSignal<boolean | undefined>;
    readonly placementInput: i0.InputSignal<string | undefined>;
    get placement(): string | undefined;
    /**
     * Auto hide the toast.
     * @return boolean
     */
    readonly autohide: i0.InputSignal<boolean>;
    /**
     * Sets the color context of the component to one of CoreUI’s themed colors.
     * @return Colors
     */
    readonly color: i0.InputSignal<string>;
    /**
     * Delay hiding the toast (ms).
     * @return number
     */
    readonly delay: i0.InputSignalWithTransform<number, unknown>;
    /**
     * Apply fade transition to the toast.
     * @return boolean
     */
    readonly fade: i0.InputSignal<boolean>;
    /**
     * Toggle the visibility of component.
     * @return boolean
     */
    readonly visibleInput: i0.InputSignalWithTransform<boolean, unknown>;
    set visible(value: boolean);
    get visible(): boolean;
    /**
     * @ignore
     */
    readonly index: i0.InputSignalWithTransform<number, unknown>;
    /**
     * Event emitted on visibility change. [docs]
     * @return <boolean>
     */
    readonly visibleChange: i0.OutputEmitterRef<boolean>;
    /**
     * Event emitted on timer tick. [docs]
     * @return number
     */
    readonly timer: i0.OutputEmitterRef<number>;
    private timerId;
    private clockId;
    private clockTimerId;
    private _clock;
    get clock(): number;
    set clock(value: number);
    readonly animationDisabled: i0.Signal<boolean>;
    get animateType(): AnimateType;
    readonly hostClasses: i0.Signal<Record<string, boolean>>;
    ngOnInit(): void;
    ngOnDestroy(): void;
    setTimer(): void;
    clearTimer(): void;
    onClose(): void;
    setClock(): void;
    clearClock(): void;
    static ɵfac: i0.ɵɵFactoryDeclaration<ToastComponent, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<ToastComponent, "c-toast", ["cToast"], { "dynamic": { "alias": "dynamic"; "required": false; "isSignal": true; }; "placementInput": { "alias": "placement"; "required": false; "isSignal": true; }; "autohide": { "alias": "autohide"; "required": false; "isSignal": true; }; "color": { "alias": "color"; "required": false; "isSignal": true; }; "delay": { "alias": "delay"; "required": false; "isSignal": true; }; "fade": { "alias": "fade"; "required": false; "isSignal": true; }; "visibleInput": { "alias": "visible"; "required": false; "isSignal": true; }; "index": { "alias": "index"; "required": false; "isSignal": true; }; }, { "visibleChange": "visibleChange"; "timer": "timer"; }, never, ["*"], true, never>;
}

declare class ToastBodyComponent {
    readonly toast?: ToastComponent | null | undefined;
    static ɵfac: i0.ɵɵFactoryDeclaration<ToastBodyComponent, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<ToastBodyComponent, "c-toast-body", ["cToastBody"], {}, {}, never, ["*"], true, never>;
}

declare class ToastHeaderComponent {
    #private;
    readonly toast: i0.WritableSignal<ToastComponent | undefined>;
    /**
     * Add close button to a toast header
     * @return boolean
     */
    readonly closeButton: i0.InputSignal<boolean>;
    static ɵfac: i0.ɵɵFactoryDeclaration<ToastHeaderComponent, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<ToastHeaderComponent, "c-toast-header", ["cToastHeader"], { "closeButton": { "alias": "closeButton"; "required": false; "isSignal": true; }; }, {}, never, ["*"], true, never>;
}

declare class ToastCloseDirective {
    #private;
    readonly cToastClose: i0.InputSignal<ToastComponent | undefined>;
    toggleOpen($event: MouseEvent): void;
    static ɵfac: i0.ɵɵFactoryDeclaration<ToastCloseDirective, never>;
    static ɵdir: i0.ɵɵDirectiveDeclaration<ToastCloseDirective, "[cToastClose]", ["cToastClose"], { "cToastClose": { "alias": "cToastClose"; "required": false; "isSignal": true; }; }, {}, never, never, true, never>;
}

declare class ToastModule {
    static ɵfac: i0.ɵɵFactoryDeclaration<ToastModule, never>;
    static ɵmod: i0.ɵɵNgModuleDeclaration<ToastModule, never, [typeof ToastBodyComponent, typeof ToastComponent, typeof ToastCloseDirective, typeof ToastHeaderComponent, typeof ToasterComponent, typeof ToasterHostDirective], [typeof ToastBodyComponent, typeof ToastComponent, typeof ToastCloseDirective, typeof ToastHeaderComponent, typeof ToasterComponent, typeof ToasterHostDirective]>;
    static ɵinj: i0.ɵɵInjectorDeclaration<ToastModule>;
}

declare class TooltipComponent implements OnDestroy {
    #private;
    readonly renderer: Renderer2;
    /**
     * Content of tooltip
     * @type {string | TemplateRef}
     */
    readonly content: i0.InputSignal<string | TemplateRef<any>>;
    /**
     * Toggle the visibility of popover component.
     * @type boolean
     */
    readonly visible: i0.InputSignalWithTransform<boolean, unknown>;
    readonly id: i0.InputSignal<string | undefined>;
    readonly role: i0.InputSignal<string>;
    readonly viewContainerRef: i0.Signal<ViewContainerRef | undefined>;
    private textNode;
    readonly hostClasses: i0.Signal<Record<string, boolean>>;
    ngOnDestroy(): void;
    private clear;
    private updateView;
    static ɵfac: i0.ɵɵFactoryDeclaration<TooltipComponent, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<TooltipComponent, "c-tooltip", never, { "content": { "alias": "content"; "required": false; "isSignal": true; }; "visible": { "alias": "visible"; "required": false; "isSignal": true; }; "id": { "alias": "id"; "required": false; "isSignal": true; }; "role": { "alias": "role"; "required": false; "isSignal": true; }; }, {}, never, never, true, never>;
}

declare class TooltipDirective implements OnDestroy, OnInit, AfterViewInit {
    #private;
    /**
     * Content of tooltip
     * @return {string | TemplateRef}
     */
    readonly content: i0.InputSignal<string | TemplateRef<any> | undefined>;
    /**
     * Optional popper Options object, takes precedence over cPopoverPlacement prop
     * @return Partial<Options>
     */
    readonly popperOptions: i0.InputSignal<Partial<Options>>;
    readonly popperOptionsComputed: i0.Signal<{
        placement: _popperjs_core.Placement;
        modifiers?: Partial<_popperjs_core.Modifier<any, any>>[] | undefined;
        strategy?: _popperjs_core.PositioningStrategy | undefined;
        onFirstUpdate?: ((arg0: Partial<_popperjs_core.State>) => void) | undefined;
    }>;
    /**
     * Describes the placement of your component after Popper.js has applied all the modifiers that may have flipped or altered the originally provided placement property.
     * @return: 'top' | 'bottom' | 'left' | 'right'
     * @default: 'top'
     */
    readonly placement: i0.InputSignal<"top" | "bottom" | "right" | "left">;
    /**
     * ElementRefDirective for positioning the tooltip on reference element
     * @return: ElementRefDirective
     * @default: undefined
     */
    readonly reference: i0.InputSignal<ElementRefDirective | undefined>;
    readonly referenceRef: i0.Signal<ElementRef<any>>;
    /**
     * Sets which event handlers you’d like provided to your toggle prop. You can specify one trigger or an array of them.
     * @return: 'Triggers | Triggers[]
     */
    readonly trigger: i0.InputSignal<Triggers | Triggers[]>;
    /**
     * Toggle the visibility of tooltip component.
     * @return boolean
     */
    readonly visible: i0.ModelSignal<boolean>;
    get ariaDescribedBy(): string | null;
    private tooltip;
    private tooltipId;
    private tooltipRef;
    private popperInstance;
    private _popperOptions;
    ngAfterViewInit(): void;
    ngOnDestroy(): void;
    ngOnInit(): void;
    private setListeners;
    private clearListeners;
    private intersectionServiceSubscribe;
    private getUID;
    private createTooltipElement;
    private destroyTooltipElement;
    private addTooltipElement;
    private removeTooltipElement;
    static ɵfac: i0.ɵɵFactoryDeclaration<TooltipDirective, never>;
    static ɵdir: i0.ɵɵDirectiveDeclaration<TooltipDirective, "[cTooltip]", ["cTooltip"], { "content": { "alias": "cTooltip"; "required": false; "isSignal": true; }; "popperOptions": { "alias": "cTooltipOptions"; "required": false; "isSignal": true; }; "placement": { "alias": "cTooltipPlacement"; "required": false; "isSignal": true; }; "reference": { "alias": "cTooltipRef"; "required": false; "isSignal": true; }; "trigger": { "alias": "cTooltipTrigger"; "required": false; "isSignal": true; }; "visible": { "alias": "cTooltipVisible"; "required": false; "isSignal": true; }; }, { "visible": "cTooltipVisibleChange"; }, never, never, true, never>;
}

declare class TooltipModule {
    static ɵfac: i0.ɵɵFactoryDeclaration<TooltipModule, never>;
    static ɵmod: i0.ɵɵNgModuleDeclaration<TooltipModule, never, [typeof TooltipComponent, typeof TooltipDirective], [typeof TooltipComponent, typeof TooltipDirective]>;
    static ɵinj: i0.ɵɵInjectorDeclaration<TooltipModule>;
}

declare class AlignDirective {
    /**
     * Set vertical alignment of inline, inline-block, inline-table, and table cell elements
     * @return Alignment
     */
    readonly align: i0.InputSignal<Alignment | undefined>;
    readonly hostClasses: i0.Signal<Record<string, boolean>>;
    static ɵfac: i0.ɵɵFactoryDeclaration<AlignDirective, never>;
    static ɵdir: i0.ɵɵDirectiveDeclaration<AlignDirective, "[cAlign]", ["cAlign"], { "align": { "alias": "cAlign"; "required": false; "isSignal": true; }; }, {}, never, never, true, never>;
}

declare class BgColorDirective {
    /**
     * Set the background of an element to any contextual class
     */
    readonly cBgColor: i0.InputSignal<string>;
    /**
     * Add linear gradient as background image to the backgrounds.
     * @return boolean
     */
    readonly gradient: i0.InputSignal<boolean | undefined>;
    readonly hostClasses: i0.Signal<Record<string, boolean>>;
    static ɵfac: i0.ɵɵFactoryDeclaration<BgColorDirective, never>;
    static ɵdir: i0.ɵɵDirectiveDeclaration<BgColorDirective, "[cBgColor]", ["cBgColor"], { "cBgColor": { "alias": "cBgColor"; "required": false; "isSignal": true; }; "gradient": { "alias": "gradient"; "required": false; "isSignal": true; }; }, {}, never, never, true, never>;
}

type Border = boolean | BorderWidth | BorderColor | IBorderElement | IBorder;
interface IBorder {
    top?: BorderWidth | BorderColor | IBorderElement | boolean;
    end?: BorderWidth | BorderColor | IBorderElement | boolean;
    bottom?: BorderWidth | BorderColor | IBorderElement | boolean;
    start?: BorderWidth | BorderColor | IBorderElement | boolean;
    color?: BorderColor;
}
type BorderColor = Colors | 'white';
type BorderWidth = 0 | 1 | 2 | 3 | 4 | 5 | number;
interface IBorderElement {
    color?: BorderColor;
    width?: BorderWidth;
}

declare class BorderDirective {
    /**
     * Add or remove an element’s borders
     * @return Border
     */
    readonly cBorder: i0.InputSignal<Border>;
    readonly hostClasses: i0.Signal<Record<string, boolean>>;
    static ɵfac: i0.ɵɵFactoryDeclaration<BorderDirective, never>;
    static ɵdir: i0.ɵɵDirectiveDeclaration<BorderDirective, "[cBorder]", ["cBorder"], { "cBorder": { "alias": "cBorder"; "required": false; "isSignal": true; }; }, {}, never, never, true, never>;
}

type Rounded = boolean | RoundedSize | RoundedElement | IRoundedCorner;
interface IRoundedCorner {
    top?: boolean;
    end?: boolean;
    bottom?: boolean;
    start?: boolean;
    circle?: boolean;
    pill?: boolean;
    size?: RoundedSize;
}
type RoundedSize = 0 | 1 | 2 | 3 | number;
type RoundedElement = 'top' | 'end' | 'bottom' | 'start' | 'circle' | 'pill';

declare class RoundedDirective {
    /**
     * Set border radius variant and radius size
     * @type Rounded
     */
    readonly cRounded: i0.InputSignal<Rounded>;
    readonly hostClasses: i0.Signal<Record<string, boolean>>;
    static ɵfac: i0.ɵɵFactoryDeclaration<RoundedDirective, never>;
    static ɵdir: i0.ɵɵDirectiveDeclaration<RoundedDirective, "[cRounded]", ["cRounded"], { "cRounded": { "alias": "cRounded"; "required": false; "isSignal": true; }; }, {}, never, never, true, never>;
}

declare class ShadowOnScrollDirective {
    #private;
    constructor();
    readonly cShadowOnScroll: i0.InputSignal<boolean | "sm" | "lg" | "none">;
    static ɵfac: i0.ɵɵFactoryDeclaration<ShadowOnScrollDirective, never>;
    static ɵdir: i0.ɵɵDirectiveDeclaration<ShadowOnScrollDirective, "[cShadowOnScroll]", ["cShadowOnScroll"], { "cShadowOnScroll": { "alias": "cShadowOnScroll"; "required": false; "isSignal": true; }; }, {}, never, never, true, never>;
}

declare class UtilitiesModule {
    static ɵfac: i0.ɵɵFactoryDeclaration<UtilitiesModule, never>;
    static ɵmod: i0.ɵɵNgModuleDeclaration<UtilitiesModule, never, [typeof AlignDirective, typeof BgColorDirective, typeof BorderDirective, typeof RoundedDirective, typeof ShadowOnScrollDirective, typeof TextColorDirective, typeof TextBgColorDirective], [typeof AlignDirective, typeof BgColorDirective, typeof BorderDirective, typeof RoundedDirective, typeof ShadowOnScrollDirective, typeof TextColorDirective, typeof TextBgColorDirective]>;
    static ɵinj: i0.ɵɵInjectorDeclaration<UtilitiesModule>;
}

declare class WidgetStatAComponent extends CardComponent {
    #private;
    /**
     * Sets the color context of the component to one of CoreUI’s themed colors.
     * @type Colors
     */
    /**
     * Title of the widget to display
     * @type string
     */
    readonly title: InputSignal<string | undefined>;
    /**
     * Value for your widget to display
     * @type string
     */
    readonly value: InputSignal<string | undefined>;
    templates: Record<string, TemplateRef<any>>;
    readonly contentTemplates: i0.Signal<readonly TemplateIdDirective[]>;
    readonly hostClasses: i0.Signal<Record<string, boolean>>;
    get bodyClasses(): {
        'pb-0': boolean;
        'd-flex': boolean;
        'justify-content-between': boolean;
        'align-items-start': boolean;
    };
    static ɵfac: i0.ɵɵFactoryDeclaration<WidgetStatAComponent, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<WidgetStatAComponent, "c-widget-stat-a", ["cWidgetStatA"], { "title": { "alias": "title"; "required": false; "isSignal": true; }; "value": { "alias": "value"; "required": false; "isSignal": true; }; }, {}, ["contentTemplates"], [".chart-wrapper", "*"], true, never>;
}

declare class WidgetStatBComponent extends CardComponent {
    constructor();
    /**
     * Sets the color context of the component to one of CoreUI themed colors.
     * @type Colors
     */
    /**
     * Sets the text-color context of the component to one of CoreUI themed colors.
     * via TextColorDirective
     * @type TextColors
     */
    /**
     * Title of the widget to display
     * @type string
     */
    readonly title: InputSignal<string | undefined>;
    /**
     * Helper text for your widget.
     * @type string
     */
    readonly text: InputSignal<string | undefined>;
    /**
     * Value for your widget to display
     * @type string
     */
    readonly value: InputSignal<string | undefined>;
    /**
     * Invert colors from their default dark shade.
     * @type boolean
     */
    readonly inverse: InputSignalWithTransform<boolean, unknown>;
    readonly hostClasses: i0.Signal<Record<string, boolean>>;
    static ɵfac: i0.ɵɵFactoryDeclaration<WidgetStatBComponent, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<WidgetStatBComponent, "c-widget-stat-b", ["cWidgetStatB"], { "title": { "alias": "title"; "required": false; "isSignal": true; }; "text": { "alias": "text"; "required": false; "isSignal": true; }; "value": { "alias": "value"; "required": false; "isSignal": true; }; "inverse": { "alias": "inverse"; "required": false; "isSignal": true; }; }, {}, never, ["*"], true, never>;
}

declare class WidgetStatCComponent extends CardComponent {
    #private;
    constructor();
    /**
     * Icon for your component.
     * @type string
     */
    readonly icon: i0.InputSignal<string | undefined>;
    /**
     * Title of the widget to display
     * @type string
     */
    readonly title: i0.InputSignal<string | undefined>;
    /**
     * Value for your widget to display
     * @type string|number
     */
    readonly value: i0.InputSignal<string | number | undefined>;
    /**
     * Invert colors from their default dark shade.
     * @type boolean
     */
    readonly inverse: i0.InputSignalWithTransform<boolean, unknown>;
    templates: Record<string, TemplateRef<any>>;
    readonly contentTemplates: i0.Signal<readonly TemplateIdDirective[]>;
    readonly hostExtendedClass: i0.Signal<Record<string, boolean>>;
    readonly titleClasses: i0.Signal<Record<string, boolean>>;
    readonly valueClasses: i0.Signal<Record<string, boolean>>;
    readonly iconClasses: i0.Signal<Record<string, boolean>>;
    static ɵfac: i0.ɵɵFactoryDeclaration<WidgetStatCComponent, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<WidgetStatCComponent, "c-widget-stat-c", ["cWidgetStatC"], { "icon": { "alias": "icon"; "required": false; "isSignal": true; }; "title": { "alias": "title"; "required": false; "isSignal": true; }; "value": { "alias": "value"; "required": false; "isSignal": true; }; "inverse": { "alias": "inverse"; "required": false; "isSignal": true; }; }, {}, ["contentTemplates"], ["*"], true, never>;
}

type WidgetStatDValue = {
    title?: string;
    value?: number | string;
};
declare class WidgetStatDComponent extends CardComponent {
    /**
     * Sets the color context of the component to one of CoreUI’s themed colors.
     * @type Colors
     */
    /**
     * Values and subtitles for your component.
     * @type WidgetStatDValue
     */
    readonly values: i0.InputSignal<WidgetStatDValue[] | undefined>;
    readonly headerClasses: i0.Signal<Record<string, boolean>>;
    static ɵfac: i0.ɵɵFactoryDeclaration<WidgetStatDComponent, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<WidgetStatDComponent, "c-widget-stat-d", ["cWidgetStatD"], { "values": { "alias": "values"; "required": false; "isSignal": true; }; }, {}, never, ["*"], true, never>;
}

declare class WidgetStatEComponent extends CardComponent {
    constructor();
    /**
     * Title of the widget to display
     * @type string
     */
    readonly title: i0.InputSignal<string | undefined>;
    /**
     * Value for your widget to display
     * @type string | number
     */
    readonly value: i0.InputSignal<string | number | undefined>;
    readonly titleClasses: i0.Signal<Record<string, boolean>>;
    static ɵfac: i0.ɵɵFactoryDeclaration<WidgetStatEComponent, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<WidgetStatEComponent, "c-widget-stat-e", ["cWidgetStatE"], { "title": { "alias": "title"; "required": false; "isSignal": true; }; "value": { "alias": "value"; "required": false; "isSignal": true; }; }, {}, never, ["*"], true, never>;
}

declare class WidgetStatFComponent extends CardComponent {
    #private;
    /**
     * Sets the color context of the component to one of CoreUI’s themed colors.
     * @type Colors
     */
    /**
     * Sets the text-color context of the component to one of CoreUI’s themed colors.
     * @type Colors
     */
    /**
     * Footer for your widget
     * @type string
     */
    readonly footer: i0.InputSignal<string | undefined>;
    /**
     * Icon for your widget
     * @type string
     */
    readonly icon: i0.InputSignal<string | undefined>;
    /**
     * Set padding of your component.
     * @type boolean
     */
    readonly padding: i0.InputSignalWithTransform<boolean, unknown>;
    /**
     * Title of the widget to display
     * @type string
     */
    readonly title: i0.InputSignal<string | undefined>;
    /**
     * Value for your widget to display
     * @type string
     */
    readonly value: i0.InputSignal<string | number | undefined>;
    templates: Record<string, TemplateRef<any>>;
    readonly contentTemplates: i0.Signal<readonly TemplateIdDirective[]>;
    readonly cardBodyClasses: i0.Signal<Record<string, boolean>>;
    readonly iconClasses: i0.Signal<Record<string, boolean>>;
    readonly titleClasses: i0.Signal<Record<string, boolean>>;
    readonly valueClasses: i0.Signal<Record<string, boolean>>;
    static ɵfac: i0.ɵɵFactoryDeclaration<WidgetStatFComponent, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<WidgetStatFComponent, "c-widget-stat-f", ["cWidgetStatB"], { "footer": { "alias": "footer"; "required": false; "isSignal": true; }; "icon": { "alias": "icon"; "required": false; "isSignal": true; }; "padding": { "alias": "padding"; "required": false; "isSignal": true; }; "title": { "alias": "title"; "required": false; "isSignal": true; }; "value": { "alias": "value"; "required": false; "isSignal": true; }; }, {}, ["contentTemplates"], never, true, never>;
}

declare class WidgetModule {
    static ɵfac: i0.ɵɵFactoryDeclaration<WidgetModule, never>;
    static ɵmod: i0.ɵɵNgModuleDeclaration<WidgetModule, never, [typeof WidgetStatAComponent, typeof WidgetStatBComponent, typeof WidgetStatCComponent, typeof WidgetStatDComponent, typeof WidgetStatEComponent, typeof WidgetStatFComponent], [typeof WidgetStatAComponent, typeof WidgetStatBComponent, typeof WidgetStatCComponent, typeof WidgetStatDComponent, typeof WidgetStatEComponent, typeof WidgetStatFComponent]>;
    static ɵinj: i0.ɵɵInjectorDeclaration<WidgetModule>;
}

export { AccordionButtonDirective, AccordionComponent, AccordionItemComponent, AccordionModule, AlertComponent, AlertHeadingDirective, AlertLinkDirective, AlertModule, AlignDirective, AvatarComponent, AvatarModule, BackdropService, BadgeComponent, BadgeModule, BgColorDirective, BorderDirective, BreadcrumbComponent, BreadcrumbItemComponent, BreadcrumbModule, BreadcrumbRouterComponent, BreadcrumbRouterService, BreakpointInfix, ButtonCloseDirective, ButtonDirective, ButtonGroupComponent, ButtonGroupModule, ButtonModule, ButtonToolbarComponent, CalloutComponent, CalloutModule, CardBodyComponent, CardComponent, CardFooterComponent, CardGroupComponent, CardHeaderActionsComponent, CardHeaderComponent, CardImgDirective, CardImgOverlayComponent, CardLinkDirective, CardModule, CardSubtitleDirective, CardTextDirective, CardTitleDirective, CarouselCaptionComponent, CarouselComponent, CarouselConfig, CarouselControlComponent, CarouselIndicatorsComponent, CarouselInnerComponent, CarouselItemComponent, CarouselModule, ClassToggleService, ColComponent, ColDirective, CollapseDirective, CollapseModule, ColorModeService, ContainerComponent, DropdownCloseDirective, DropdownComponent, DropdownDividerDirective, DropdownHeaderDirective, DropdownItemDirective, DropdownItemPlainDirective, DropdownMenuDirective, DropdownModule, DropdownService, DropdownToggleDirective, ElementRefDirective, FooterComponent, FooterModule, FormCheckComponent, FormCheckInputDirective, FormCheckLabelDirective, FormControlDirective, FormDirective, FormFeedbackComponent, FormFloatingDirective, FormLabelDirective, FormModule, FormSelectDirective, FormTextDirective, GridModule, GutterDirective, HeaderBrandComponent, HeaderComponent, HeaderDividerComponent, HeaderModule, HeaderNavComponent, HeaderTextComponent, HeaderTogglerDirective, HtmlAttributesDirective, ImgDirective, ImgModule, InMemoryStorageService, InputGroupComponent, InputGroupTextDirective, IntersectionService, ListGroupDirective, ListGroupItemDirective, ListGroupModule, ListenersService, LocalStorageService, ModalBodyComponent, ModalComponent, ModalContentComponent, ModalDialogComponent, ModalFooterComponent, ModalHeaderComponent, ModalModule, ModalService, ModalTitleDirective, ModalToggleDirective, NavComponent, NavItemComponent, NavLinkDirective, NavModule, NavbarBrandDirective, NavbarComponent, NavbarModule, NavbarNavComponent, NavbarTextComponent, NavbarTogglerDirective, OffcanvasBodyComponent, OffcanvasComponent, OffcanvasHeaderComponent, OffcanvasModule, OffcanvasService, OffcanvasTitleDirective, OffcanvasToggleDirective, PageItemComponent, PageItemDirective, PageLinkDirective, PaginationComponent, PaginationModule, PlaceholderAnimationDirective, PlaceholderDirective, PlaceholderModule, PopoverComponent, PopoverDirective, PopoverModule, ProgressBarComponent, ProgressBarDirective, ProgressComponent, ProgressModule, ProgressStackedComponent, RoundedDirective, RowComponent, RowDirective, RtlService, ShadowOnScrollDirective, SharedModule, SidebarBrandComponent, SidebarComponent, SidebarFooterComponent, SidebarHeaderComponent, SidebarModule, SidebarNavComponent, SidebarNavHelper, SidebarService, SidebarToggleDirective, SidebarTogglerDirective, SpinnerComponent, SpinnerModule, TabContentComponent, TabContentRefDirective, TabDirective, TabPaneComponent, TabPanelComponent, TabService, TableActiveDirective, TableColorDirective, TableDirective, TableModule, Tabs2Module, TabsComponent, TabsContentComponent, TabsListComponent, TabsModule, TabsService, TemplateIdDirective, TextBgColorDirective, TextColorDirective, ThemeDirective, ToastBodyComponent, ToastCloseDirective, ToastComponent, ToastHeaderComponent, ToastModule, ToasterComponent, ToasterHostDirective, ToasterPlacement, ToasterService, TooltipComponent, TooltipDirective, TooltipModule, UIDService, UtilitiesModule, WidgetModule, WidgetStatAComponent, WidgetStatBComponent, WidgetStatCComponent, WidgetStatDComponent, WidgetStatEComponent, WidgetStatFComponent };
export type { Alignment, BackgroundColors, BadgePositions, BooleanInput, BreakpointInfixStrings, Breakpoints, ButtonType, ColorMode, Colors, Directions, IBreadcrumbItem, IIntersectionObserverInit, IListenersConfig, INavAttributes$1 as INavAttributes, INavData, INavLinkProps$1 as INavLinkProps, IProgress, IProgressBar, IProgressBarStacked, InputType, NgCssClass, NumberInput, Placements, Positions, Shapes, Sizes, TToasterPlacement, TextColors, Triggers };
